\documentclass[a4paper,11pt,oneside]{book}

\input{../../share/tuftelike}
\input{../../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{4}

\usepackage{booktabs}

%%% DOCUMENT START

\begin{document}

\worksheettrue
\solutionstrue
\chapterwabstract{Το Παιχνίδι της Αφαίρεσης}{}{}{subtractionColor}{white}

\section{Το Στήσιμο}

Ένα πλήθος από αντικείμενα (π.χ. σπίρτα, ξυλάκια) τοποθετούνται στη σειρά και ο κάθε ένας από τους δύο παίκτες αφαιρεί με τη σειρά του από ένα μέχρι και τρία αντικείμενα, μέχρι να μη μείνει κανένα. Ο παίκτης που θα πάρει το τελευταίο αντικείμενο \emph{χάνει} το παιχνίδι. 

\begin{step}

Ας υποθέσουμε ότι τα αντικείμενα που χρησιμοποιούν οι παίκτες είναι σπίρτα. Οι κανόνες του παιχνιδιού δεν προσδιορίζουν το αρχικό πλήθος σπίρτων, μπορούμε λοιπόν να το ορίσουμε μόνοι μας. 

Γίνεται το παιχνίδι να ξεκινάει κάθε φορά μ' ένα διαφορετικό αριθμό σπίρτων; Αν ναι, ποιος είναι ο τρόπος;

% [modified] "χρήστης" σε "παίκτης"
\begin{answer}
Θα μπορούσε το παιχνίδι να ξεκινά επιλέγοντας μια \emph{τυχαία} τιμή ως αρχικό αριθμό σπίρτων ή να ερωτάται ο πρώτος παίκτης με πόσα σπίρτα θα ήθελε να ξεκινήσει. 
\end{answer}

Ας ονομάσουμε το πλήθος των σπίρτων \pyinline{matches}. Μπορούμε να αρχικοποιήσουμε τη μεταβλητή \pyinline{matches} με μια τυχαία τιμή (ας πούμε από το 7 μέχρι και το 21).

\emph{Προσθέστε} τις κατάλληλες εντολές στο πρόγραμμά, ώστε να εισάγει τη βιβλιοθήκη \pyinline{random} και να παράγει μια τυχαία τιμή ανάμεσα στο \pyinline{7} και στο \pyinline{21}, την οποία και θ' αποθηκεύει στη μεταβλητή \pyinline{matches}.

\begin{answer}
Θα ξεκινήσουμε το πρόγραμμα με τις εντολές:

\begin{pynew}
import random
matches = random.randint(7,21)
\end{pynew}
\end{answer}
\end{step}

\begin{step}
\emph{Προσθέστε} την κατάλληλη εντολή στο πρόγραμμά, προκειμένου να εμφανίζει τον αρχικό αριθμό σπίρτων στον παίκτη. Για παράδειγμα:

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Αρχικό πλήθος σπίρτων: 13
\end{pyterm}

\begin{answer}
Θα προσθέσουμε την εντολή:

\begin{pynew}
print("Αρχικό πλήθος σπίρτων:", matches)
\end{pynew}
\end{answer}

Εκτελέστε μερικές φορές το πρόγραμμά σας. Εμφανίζεται διαφορετικός αριθμός σπίρτων σε κάποιες εκτελέσεις; 

\begin{note}
Σημείωση: Δεν αποκλείεται κάποιες από τις τυχαίες τιμές να είναι οι ίδιες.
\end{note}

\begin{answer}
Εκτελώντας το πρόγραμμα πέντε φορές, εμφανίστηκε ως αρχικό πλήθος σπίρτων το \pyinline{20}, το \pyinline{18}, το \pyinline{20}, το \pyinline{15} και το \pyinline{9}. 

% [modified] προστέθηκαν λίγα λόγια ακόμα για την τυχαιότητα
Δεν είναι παράξενο που εκτελέσαμε πέντε φορές το πρόγραμμα και το \pyinline{20} εμφανίστηκε δύο φορές, όπως δεν θα ήταν παράξενο αν ρίχναμε πέντε φορές ένα ζάρι και φέρναμε δύο φορές την ίδια ζαριά (ή και περισσότερες). Αν όμως ρίχναμε 10000 φορές ένα ζάρι και φέρναμε 4000 φορές την ίδια ζαριά, τότε θα είχαμε υποψίες ότι τα αποτελέσματα του συγκεκριμένου ζαριού δεν είναι και τόσο ``τυχαία''. Υπάρχουν συγκεκριμένοι έλεγχοι που μπορούμε να κάνουμε για να ισχυριστούμε τεκμηριωμένα ότι μια διαδικασία δεν είναι πραγματικά και τόσο τυχαία, αλλά για να είναι αξιόπιστοι θα πρέπει η διαδικασία να επαναληφθεί πάρα πολλές φορές. 
% [comment] Δες http://financialcryptography.com/images/dilbert-9.gif
\end{answer}

\end{step}

\begin{step}
\label{step:ask-matches}
\emph{Συμπληρώστε} το πρόγραμμα ώστε να ζητά από τον παίκτη τον αριθμό των σπίρτων που θα αφαιρέσει, εμφανίζοντας κατάλληλη προτροπή. Για παράδειγμα:

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Πόσα σπίρτα θέλεις;
\end{pyterm}

Αποθηκεύστε την απάντηση του παίκτη στη μεταβλητή \pyinline{removed}.

\begin{answer}
Θα προσθέσουμε τις εντολές:

\begin{pynew}
print("Πόσα σπίρτα θέλεις;")
removed = int(input())
\end{pynew}

Είναι απαραίτητο να χρησιμοποιήσουμε την \pyinline{int()} για να μετατρέψουμε την τιμή που πληκτρολογεί ο παίκτης σε ακέραια, πριν την αποθηκεύσουμε στη μεταβλητή \pyinline{removed}. 
\end{answer}
\end{step}

\begin{step}
\label{step:matches-reduce}

\emph{Προσθέστε} την παρακάτω εντολή προκειμένου να μειωθεί ο αριθμός των σπίρτων \pyinline{matches} ανάλογα με το πλήθος των σπίρτων \pyinline{removed} που ζήτησε ο παίκτης να αφαιρέσει.

\begin{pynew}
    matches = matches - removed
\end{pynew}

Εκτελέστε το πρόγραμμά σας. Λειτουργεί σωστά ή εμφανίζει κάποιο μήνυμα σφάλματος; 

\begin{answer}
Το πρόγραμμα λειτουργεί χωρίς να εμφανιστεί μήνυμα σφάλματος.
\end{answer}

\marginnote{\iconcaution}
Σε περίπτωση που σας εμφανίζει το παρακάτω μήνυμα σφάλματος: 

\begin{pyterm}
TypeError: unsupported operand type(s) for -
\end{pyterm}

βεβαιωθείτε ότι έχετε χρησιμοποιήσει την \pyinline{int()} όταν ζητάτε τον αριθμό των σπίρτων που θα αφαιρέσει ο παίκτης, προκειμένου να μετατρέψετε την τιμή αυτή σε ακέραιο αριθμό.
\end{step}

\begin{step}
\emph{Συμπληρώστε} το πρόγραμμα με την κατάλληλη εντολή ώστε να εμφανίζεται στους παίκτες ο αριθμός των σπίρτων που απομένουν. Έτσι θα μπορούν ν' αποφασίζουν για το πλήθος των σπίρτων που θα αφαιρέσουν στον επόμενο γύρο. Για παράδειγμα:

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Σπίρτα που απομένουν: 15
\end{pyterm}

\clearpage
\begin{answer}
Θα προσθέσουμε την εντολή:

\begin{pynew}
print("Σπίρτα που απομένουν:", matches)
\end{pynew}
\end{answer}

Εκτελέστε το πρόγραμμά σας. Εμφανίζει σωστά τον αριθμό των σπίρτων που απομένουν;

\begin{answer}
Ναι. Κατά την εκτέλεση του προγράμματος, το παιχνίδι ξεκίνησε με \pyinline{14} σπίρτα. Ζητήσαμε να αφαιρέσουμε \pyinline{3} και εμφανίστηκε μήνυμα ότι απομένουν \pyinline{11}.
\end{answer}
\end{step}

\section{Κάνε Ένα Γύρο}

\begin{step}
Η αφαίρεση σπίρτων από τους παίκτες δεν γίνεται μόνο μια φορά, αλλά πολλές. Θα χρησιμοποιήσουμε την εντολή \pyinline{while} προκειμένου οι εντολές να εκτελούνται επαναληπτικά.

Το συγκεκριμένο παιχνίδι συνεχίζεται όσο απομένει τουλάχιστον ένα σπίρτο. Τι τιμές πρέπει να έχει η μεταβλητή \pyinline{matches}, προκειμένου να συνεχίζεται η επανάληψη;

\begin{answer}
Όσο η \pyinline{matches} παίρνει θετικές τιμές, δηλαδή όσο υπάρχουν ακόμα σπίρτα στο τραπέζι, το παιχνίδι θα πρέπει να συνεχίζεται. 
\end{answer}

\emph{Προσθέστε} την εντολή \pyinline{while} μαζί με την κατάλληλη συνθήκη που εξετάζει την τιμή της \pyinline{matches}, όπως την περιγράψατε προηγουμένως. \emph{Εμφωλεύστε} τις εντολές που πιστεύετε ότι χρειάζεται να εκτελούνται επαναληπτικά, προσθέτοντας τις κατάλληλες εσοχές.

\begin{answer}
Πρέπει να σκεφτούμε ποιες εντολές θα πρέπει να επαναλαμβάνονται, ώστε να τις εμφωλεύσουμε στη \pyinline{while}. 

Οι εντολές που αφορούν στην τυχαία επιλογή και εμφάνιση του αρχικού πλήθους σπίρτων θα πρέπει να εκτελούνται μόνο μία φορά, στην αρχή του παιχνιδιού, επομένως δεν θα συμπεριληφθούν στην επανάληψη. Αντίθετα, όλες οι εντολές που ακολουθούν, η ανάγνωση του πλήθους των σπίρτων που θα αφαιρεθούν, η απομείωση του πλήθους των σπίρτων και η εμφάνιση των σπίρτων που απομένουν, θα πρέπει να εκτελούνται σε κάθε γύρο. Γι' αυτό θα τις τοποθετήσουμε μετά τη \pyinline{while} και θα τους προσθέσουμε εσοχές.

Με την προσθήκη της \pyinline{while}, το πρόγραμμα έχει πλέον ως εξής:

\begin{pyplain}
import random
matches = random.randint(7,21)
print("Αρχικό πλήθος σπίρτων:", matches)
\end{pyplain}
\begin{pynew}
while matches > 0:
\end{pynew}
\begin{pyplain}
    print("Πόσα σπίρτα θέλεις;")
    removed = int(input())
    matches = matches - removed
    print("Σπίρτα που απομένουν:", matches)
\end{pyplain}

% Σε όλες τις εντολές που ακολουθούν τη \pyinline{while} προσθέσαμε εσοχές, δηλαδή τις τοποθετήσαμε \emph{εντός} της \pyinline{while} για να επαναλαμβάνονται. 
\end{answer}

Εκτελέστε το πρόγραμμά σας. Τερματίζει η επανάληψη και, αν ναι, πότε γίνεται αυτό; 

\begin{answer}
Εκτελέσαμε το πρόγραμμα και σε κάθε κύκλο αφαιρούσαμε τυχαία μερικά σπίρτα. Η επανάληψη τερματίστηκε όταν τα σπίρτα τελείωσαν, δηλαδή όταν η \pyinline{matches} έγινε \pyinline{0}. Δοκιμάσαμε να αφαιρέσουμε και περισσότερα σπίρτα απ' όσα απέμεναν. Το πλήθος των σπίρτων έγινε αρνητικό και πάλι η επανάληψη τερματίστηκε. 

Επομένως, η επανάληψη συνεχίζεται όσο ισχύει ότι \pyinline{matches > 0} και τερματίζεται όταν ισχύει το αντίθετο, δηλαδή όταν \pyinline{matches <= 0}.
\end{answer}

\marginnote[16pt]{\iconcaution}
Αν η επανάληψη δεν σταματά τότε ελέγξτε ότι έχετε τοποθετήσει την εντολή που μειώνει τον αριθμό των σπίρτων  μέσα στην \pyinline{while} χρησιμοποιώντας τις κατάλληλες εσοχές και εκτελέστε ξανά το πρόγραμμα. 

Τι τιμή παίρνει η συνθήκη που εξετάζει η \pyinline{while}, ώστε να σταματήσει η επανάληψη;

\begin{answer}
Για να σταματήσει η επανάληψη, η συνθήκη της \pyinline{while} πρέπει να ελεγχθεί και να διαπιστωθεί ότι είναι ψευδής, δηλαδή ότι έχει την τιμή \pyinline{False}. Αντιθέτως, κάθε φορά που διαπιστώνεται ότι συνθήκη της \pyinline{while} είναι αληθής, δηλαδή ότι έχει την τιμή \pyinline{True}, ξεκινά ένας ακόμα κύκλος της επανάληψης.
\end{answer}

\end{step}

\begin{step}
Γιατί πιστεύετε ότι χρησιμοποιήσαμε τη μεταβλητή \pyinline{matches} στο βήμα \ref{step:matches-reduce} για να αποθηκεύσουμε εκ νέου το αποτέλεσμα; Τι διαφορά θα είχε αν είχαμε χρησιμοποιήσει ένα άλλο όνομα στη θέση της;

\begin{answer}
Η τιμή της παράστασης \pyinline{matches - removed} αποθηκεύεται εκ νέου στη \pyinline{matches} επειδή η τιμή της πρέπει να τροποποιηθεί, για να αντικατοπτρίζει το γεγονός ότι τα σπίρτα που απομένουν στο τραπέζι μειώθηκαν. 

% [modified] αναδιατύπωση: η remaining δεν κατονομάζεται
Αν η τιμή της παράστασης \pyinline{matches - removed} αποθηκευτεί σε άλλη μεταβλητή, τότε η \pyinline{matches} θα μείνει αμετάβλητη και ίση με το αρχικό πλήθος σπίρτων. Σε κάθε νέο γύρο του παιχνιδιού, η τιμή της έκφρασης \pyinline{matches - removed} θα βασίζεται συνεχώς στο αρχικό πλήθος σπίρτων και δεν θα αντιστοιχεί στο πλήθος των σπίρτων που απομένουν.
\end{answer}

\emph{Τροποποιήστε} την εντολή του βήματος \ref{step:matches-reduce} που αφαιρεί τα σπίρτα που ζήτησε ο παίκτης, ώστε να μην αποθηκεύει το αποτέλεσμα της ξανά στη μεταβλητή \pyinline{matches}, αλλά σε μια νέα μεταβλητή, όπως παρακάτω:

\begin{pynew}
remaining = matches - removed
\end{pynew}

\emph{Τροποποιήστε} και την \pyinline{print} που εμφανίζει τον αριθμό των σπίρτων που απομένουν, ώστε να εμφανίζει πλέον τη μεταβλητή \pyinline{remaining}.

Εκτελέστε το πρόγραμμα δίνοντας διάφορες τιμές στον αριθμό των σπίρτων που αφαιρεί ο παίκτης.
Τι παρατηρείτε;

\begin{answer}
Εκτελώντας το πρόγραμμα, το παιχνίδι ξεκίνησε με \pyinline{13} σπίρτα. Ζητήσαμε να αφαιρέσουμε \pyinline{3} σπίρτα και το πρόγραμμα εμφάνισε μήνυμα ότι το πλήθος των σπίρτων που απομένει είναι \pyinline{10}. Στη συνέχεια όμως, ζητήσαμε να αφαιρέσουμε άλλα \pyinline{3} σπίρτα και το πρόγραμμα εμφάνισε μήνυμα ότι το πλήθος των σπίρτων που απομένει είναι και πάλι \pyinline{10}. Μετά ζητήσαμε ν' αφαιρέσουμε \pyinline{1} σπίρτο και το πρόγραμμα εμφάνισε μήνυμα ότι το πλήθος των σπίρτων που απομένει είναι \pyinline{12}. Τo πλήθος των σπίρτων που εμφανίζει το πρόγραμμα ότι απομένουν δεν είναι σωστό.
\end{answer}

Γιατί πιστεύετε ότι συμβαίνει αυτό;

\begin{answer}
Επειδή η \pyinline{matches} δεν αλλάζει ποτέ τιμή και αντιστοιχεί στο αρχικό πλήθος σπίρτων. Συνεπώς και η \pyinline{remaining}, της οποίας η τιμή δίνεται από την έκφραση \pyinline{matches - removed}, αντιστοιχεί στο πλήθος των σπίρτων που απομένουν αν αφαιρέσουμε \pyinline{removed} σπίρτα \emph{από το αρχικό πλήθος}.
\end{answer}

%Πώς υπολογίζεται κάθε φορά η τιμή της μεταβλητής \pyinline{remaining};
%\begin{answer}
%Δείτε την προηγούμενη απάντηση. 
%\end{answer}

\emph{Επαναφέρετε} το πρόγραμμα, ώστε να χρησιμοποιεί τη μεταβλητή \pyinline{matches} αντί για τη μεταβλητή \pyinline{remaining}, όπως ήταν αρχικά.
\end{step}

\section{Ποιός Παίζει;}
Σε κάθε κύκλο του παιχνιδιού, το πρόγραμμα ρωτάει πόσα σπίρτα θα αφαιρεθούν. Ωστόσο, δεν καταγράφει ποιος από τους δύο παίκτες είναι που αφαιρεί κάθε φορά τα σπίρτα κι έτσι δεν είναι σε θέση να υπολογίσει ποιος είναι ο νικητής όταν τα σπίρτα τελειώσουν.

\begin{step}
Ένας τρόπος για να λύσουμε το πρόβλημα είναι να χρησιμοποιήσουμε μια μεταβλητή \pyinline{player} που να δείχνει τον \emph{αριθμό} του παίκτη που παίζει σε κάθε γύρο. 

Τι τιμές θα παίρνει η μεταβλητή αυτή; Πώς θ' αλλάζει σε κάθε γύρο;

\begin{answer}
Η μεταβλητή θα μπορούσε να έχει ως τιμή το \pyinline{1} ή το \pyinline{2} και να εναλλάσσεται σε κάθε γύρο ανάμεσα σε αυτές τις δύο τιμές.
\end{answer}

Μια απλή προσέγγιση είναι να χρησιμοποιήσουμε μια μεταβλητή \pyinline{player}, η οποία σε κάθε γύρο θα παίρνει \emph{εναλλάξ} την τιμή \pyinline{1} ή \pyinline{2}, υποδεικνύοντας έτσι ποιος παίκτης έχει σειρά να παίξει.

Αρχικά, πριν ξεκινήσει η διαδικασία του παιχνιδιού, ορίζουμε ποιος
παίκτης ξεκινάει πρώτος: αυτός θα είναι πάντα ο παίκτης με αριθμό~\pyinline{1}.

\emph{Προσθέστε} την κατάλληλη εντολή, ώστε η μεταβλητή \pyinline{player} να παίρνει σαν αρχική τιμή το \pyinline{1}.

\begin{answer}
Θα προσθέσουμε \emph{πριν} την επανάληψη την εντολή:

\begin{pynew}
player = 1
\end{pynew}
\end{answer}

Τοποθετήσατε αυτή την εντολή πριν από τη \pyinline{while} ή μέσα σε αυτή; Ποια πιστεύετε ότι είναι η διαφορά;

\begin{answer}
Αν τοποθετήσουμε την εντολή μέσα στη \pyinline{while} τότε θα επαναλαμβάνεται \emph{σε κάθε γύρο}, με αποτέλεσμα να παίζει πάντα ο πρώτος παίκτης.
\end{answer}	
\end{step}

\begin{step}
\label{step:ask-matches-player}
\emph{Τροποποιήστε} την εντολή του βήματος~\ref{step:ask-matches} που εμφανίζει το μήνυμα προτροπής, ώστε πλέον να απευθύνεται σε συγκεκριμένο παίκτη. Χρησιμοποιήστε κατάλληλα τη μεταβλητή \pyinline{player}. Για παράδειγμα:

\clearpage
\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Παίκτη 1 πόσα σπίρτα θέλεις;
\end{pyterm}

\begin{answer}
Τροποποιούμε την εντολή που εμφανίζει το μήνυμα προτροπής ως εξής:

\begin{pynew}
    print("Παίκτη", player, "πόσα σπίρτα θέλεις;")
\end{pynew}
\end{answer}

Εκτελέστε το πρόγραμμά σας. Εμφανίζει τον αριθμό του παίκτη που παίζει σε κάθε γύρο; 

\begin{answer}
Όχι. Η \pyinline{player} έχει μονίμως την τιμή \pyinline{1} κι έτσι το πρόγραμμα εμφανίζει πάντα τον ίδιο αριθμό παίκτη. Θα πρέπει η τιμή της \pyinline{player} να εναλλάσσεται σε κάθε γύρο μεταξύ των τιμών \pyinline{1} και \pyinline{2}.
\end{answer}
\end{step}

\begin{step}
\label{step:player-switch}
Στο τέλος κάθε κύκλου της επανάληψης, η τιμή της μεταβλητής \pyinline{player} θα πρέπει να τροποποιείται, ώστε να υποδεικνύει τον επόμενο παίκτη που έχει σειρά να παίξει. 

\emph{Προσθέστε} μέσα στη \pyinline{while} τις κατάλληλες εντολές που θα δίνουν στην \pyinline{player} την τιμή \pyinline{2} όταν αυτή έχει την τιμή \pyinline{1} και αντιστρόφως. Χρησιμοποιήστε την \pyinline{if}--\pyinline{else} για το σκοπό αυτό. 

\begin{answer}
Θα προσθέσουμε τις ακόλουθες εντολές \emph{μέσα} στη \pyinline{while}:

\begin{pynew}
    if player == 1:
        player = 2
    else:
        player = 1
\end{pynew}

Είναι σημαντικό το σημείο μέσα στη \pyinline{while} στο οποίο θα τοποθετηθούν αυτές οι εντολές. Εμείς τις τοποθετήσαμε μετά από όλες τις εντολές που υπήρχαν ήδη στη \pyinline{while}, ώστε η εναλλαγή του παίκτη να είναι το τελευταίο πράγμα που γίνεται σε κάθε γύρο. Με δεδομένο ότι η \pyinline{player} ξεκινά με την τιμή \pyinline{1}, θα θέλαμε η πρώτη εναλλαγή να γίνει \emph{αφού} παίξει ο πρώτος παίκτης.
\end{answer}

Εκτελέστε το πρόγραμμά. Εναλλάσσει πλέον σε κάθε γύρο τον αριθμό του παίκτη που παίζει;

\begin{answer}
Ναι, το μήνυμα απευθύνεται εναλλάξ στον έναν και στον άλλο παίκτη. 
\end{answer}

Εμφανίζεται σωστά ο αριθμός του παίκτη, δηλαδή την πρώτη φορά ο αριθμός \pyinline{1} και στον επόμενο γύρο ο αριθμός \pyinline{2}; 

\begin{answer}
Ναι.
\end{answer}

Αν εμφανίζεται στον πρώτο γύρο ο αριθμός \pyinline{2} και στον επόμενο γύρο ο αριθμός \pyinline{1}, που πιστεύετε ότι μπορεί να οφείλεται αυτό το σφάλμα;

\begin{note}
Να απαντήσετε ακόμα κι αν η συμπεριφορά του δικού σας προγράμματος είναι ορθή.
\end{note} 

\begin{answer}
Έχουμε καθορίσει ότι η αρχική τιμή της \pyinline{player} θα είναι το \pyinline{1}. Αν η πρώτη προτροπή του προγράμματος απευθύνεται στον παίκτη \pyinline{2}, αυτό σημαίνει ότι η εναλλαγή του παίκτη γίνεται πριν την εμφάνιση της πρώτης προτροπής.
\end{answer}

Σε περίπτωση που χρησιμοποιήσατε την \pyinline{elif} και όχι την \pyinline{else} στο πρόγραμμα σας, αντικαταστήστε την με μια \pyinline{else} διαγράφοντας τη συνθήκη και εκτελέστε το πρόγραμμα. Θα διαπιστώσετε ότι λειτουργεί και πάλι σωστά.

Είτε τη χρησιμοποιήσατε, είτε όχι, γιατί είναι περιττή η \pyinline{elif} στο παράδειγμά μας;

\begin{answer}
Θα μπορούσε κάποιος να υλοποιήσει την εναλλαγή του παίκτη ως εξής:

\begin{pyplain}
    if player == 1:
        player = 2
    elif player == 2:
        player = 1
\end{pyplain}

Σίγουρα ο κώδικας λειτουργεί σωστά. 
Ωστόσο, η \pyinline{player} μπορεί να έχει μόνο δύο πιθανές τιμές: είτε την \pyinline{1}, είτε τη \pyinline{2}. Η συνθήκη της \pyinline{if} ελέγχει μήπως η τιμή της \pyinline{player} είναι η \pyinline{1}. Αν αυτό δεν ισχύει, τότε γνωρίζουμε ήδη ότι η τιμή της \pyinline{player} είναι η \pyinline{2} και είναι περιττό να ελέγξουμε κάποια επιπρόσθετη συνθήκη (όπως γίνεται με την \pyinline{elif}).
% [modified] αφαιρέθηκε, γιατί προκαλείται σύγχυση ανάμεσα στις περιπτώσεις του προβλήματος και στις περιπτώσεις της if
% Γενικά, όταν υπάρχουν μόνο δύο πιθανές περιπτώσεις, τότε αρκεί μια \pyinline{if}--\pyinline{else}.
\end{answer}
\end{step}

\begin{step}
Όταν η επανάληψη τελειώσει, η μεταβλητή \pyinline{player} δείχνει ποιος παίκτης είχε σειρά να παίξει όταν τελείωσαν τα σπίρτα. Συνεπώς, μπορούμε να χρησιμοποιήσουμε τη μεταβλητή \pyinline{player} για να διαπιστώσουμε ποιος παίκτης κέρδισε.

\emph{Προσθέστε} την κατάλληλη εντολή μετά την επανάληψη, ώστε να εμφανίζει τον αριθμό του παίκτη που κέρδισε. Για παράδειγμα:

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Παίκτη 2 κέρδισες!
\end{pyterm}

\begin{answer}
Όταν ολοκληρωθεί η επανάληψη, η τιμή της μεταβλητής \pyinline{player} δείχνει τον νικητή (αφού ο παίκτης που έπαιξε πριν από αυτόν πήρε τα τελευταία σπίρτα). Συνεπώς, θα προσθέσουμε μετά την επανάληψη (χωρίς εσοχή) την εντολή:

\begin{pynew}
print("Παίκτη", player, "κέρδισες!")
\end{pynew}
\end{answer}

Τι θα συμβεί αν τοποθετήσουμε την παραπάνω εντολή μέσα στην \pyinline{while};

\begin{answer}
Αν κατά λάθος στοιχίσουμε αυτή την τελευταία εντολή μαζί με τις προηγούμενες, τότε θα εκτελείται κι αυτή σε κάθε κύκλο της επανάληψης, ανακυρήσσοντας εναλλάξ και τους δύο παίκτες ως νικητές!
\end{answer}

Εκτελέστε το πρόγραμμά σας. Εμφανίζει σωστά τον αριθμό του παίκτη που κέρδισε;

\begin{answer}
Ναι. Αν εκτελέσουμε το πρόγραμμα δύο φορές και φροντίσουμε ώστε την πρώτη να κερδίσει ο παίκτης \pyinline{1} και τη δεύτερη να κερδίσει ο παίκτης \pyinline{2}, τότε θα δούμε ότι και στις δύο περιπτώσεις εμφανίζεται στο τέλος του παιχνιδιού το μήνυμα με τον σωστό αριθμό του παίκτη που νίκησε.
\end{answer}
\end{step}

\begin{step}
Με τις εντολές που προσθέσαμε στο βήμα~\ref{step:player-switch}, η μεταβλητή \pyinline{player} εναλλάσσεται σε κάθε γύρο μεταξύ των τιμών \pyinline{1} και \pyinline{2}. 

Τώρα θα φτιάξουμε το πρώτο μας υποπρόγραμμα, το οποίο θα συντελεί στην υλοποίηση αυτής της λειτουργίας και θα μας βοηθήσει να ``συμμαζέψουμε'' λίγο τον κώδικα του κυρίως προγράμματος. 

Το υποπρόγραμμα θα επιστρέφει τον αριθμό του παίκτη που παίζει στον επόμενο γύρο. 

\marginnote{\center\includegraphics[scale=\scaling]{../illustrations/next.pdf}
\captionof*{figure}{Η συνάρτηση \pyinline{next} δέχεται σαν παράμετρο τον αριθμό \pyinline{p} ενός παίκτη κι επιστρέφει τον αριθμό του παίκτη που παίζει μετά τον \pyinline{p}.}}

\emph{Προσθέστε} την παρακάτω εντολή που ορίζει τη συνάρτηση \pyinline{next}, με παράμετρο τον αριθμό \pyinline{p} ενός παίκτη.

\begin{pynew}
def next(p):
\end{pynew}

\emph{Προσθέστε} στη συνάρτηση τις κατάλληλες εντολές έτσι ώστε να ελέγχει τον αριθμό \pyinline{p} του παίκτη και να επιστρέφει τον αριθμό του παίκτη που έχει σειρά να παίξει μετά από αυτόν. 

\begin{note}
Στο πρόγραμμά σας υπάρχουν ήδη οι εντολές που επιτελούν την παραπάνω λειτουργία, χρησιμοποιήστε ανάλογη προσέγγιση και στη συνάρτηση. Θυμηθείτε να υπάρχουν οι κατάλληλες εσοχές στις εντολές της συνάρτησης και να χρησιμοποιήσετε την εντολή \pyinline{return}, προκειμένου να επιστρέψετε το αποτέλεσμα στο πρόγραμμα.
\end{note}

\begin{answer}
Θα συμπληρώσουμε τον ορισμό της συνάρτησης \pyinline{next} ως εξής:

\begin{pyplain}
def next(p):
\end{pyplain}
\begin{pynew}
    if p == 1:
        return 2
    else:
        return 1
\end{pynew}

Η προσέγγιση είναι παρόμοια με κείνη που χρησιμοποιήσαμε στο κύριο πρόγραμμα. Εδώ όμως σκεφτόμαστε ανεξάρτητα από το κύριο πρόγραμμα. Εδώ εστιάζουμε μόνο στη λειτουργία που θέλουμε να υλοποιεί η συνάρτηση: με δεδομένο τον αριθμό \pyinline{p} ενός παίκτη, ποιός είναι ο παίκτης που παίζει μετά από αυτόν;  
% [modified]
Με το υποπρόγραμμα δεν τροποποιείται απευθείας η τιμή της \pyinline{player} αλλα \emph{επιστρέφεται} η τιμή που θα πρέπει εκχωρηθεί στην \pyinline{player} για να γίνει η εναλλαγή του παίκτη. 
\end{answer}
\end{step}

\begin{step} 
Μέσα στη \pyinline{while}, \emph{αντικαταστήστε} τις εντολές του προγράμματος που εναλλάσσουν τον αριθμό του παίκτη με την εντολή που ακολουθεί:

\begin{pynew}
    player = next(player)
\end{pynew}

Η τιμή της μεταβλητής \pyinline{player} είναι η τιμή που επιστρέφει η συνάρτηση \pyinline{next}, δηλαδή ο αριθμός του επόμενου παίκτη.

Εκτελέστε το πρόγραμμα. Εμφανίζει σωστά τον αριθμό του παίκτη που παίζει σε κάθε γύρο; 

\begin{answer}
Ναι, όπως συνέβαινε και πριν χρησιμοποιήσουμε τη \pyinline{next}. 
\end{answer}

Παρατηρείτε κάποια διαφορά στη λειτουργία του προγράμματος;

\begin{answer}
Όχι. Ως χρήστες δεν αντιλαμβανόμαστε καμία απολύτως διαφορά στα μηνύματα που βλέπουμε και στον τρόπο που αλληλεπιδρούμε με το πρόγραμμα. Ως προγραμματιστές όμως, παρατηρούμε ότι το κύριο πρόγραμμα είναι συντομότερο και φαίνεται απλούστερο στην κατανόηση της λειτουργίας του. 
\end{answer}
\end{step}

\begin{step}
Υπάρχουν κι άλλοι τρόποι να επιτευχθεί το ίδιο αποτέλεσμα, όπως φαίνεται στις εναλλακτικές υλοποιήσεις που ακολουθούν. Ωστόσο, ο τρόπος που λειτουργεί η συνάρτηση δεν έχει σημασία για εκείνους που την καλούν.

\begin{minipage}{0.48\textwidth}
\begin{pycode}
def next(p):
    return (p % 2) + 1
\end{pycode}
\end{minipage}\hfill
\begin{minipage}{0.48\textwidth}
\begin{pycode}
def next(p):
    return 3 - p
\end{pycode}
\end{minipage}

\marginnote[18pt]{Η έκφραση \pyinline{p}\%\pyinline{2} υπολογίζει το υπόλοιπο της ακέραιας διαίρεσης του \pyinline{p} με το \pyinline{2}.}

\emph{Αντικαταστήστε} τις εντολές της συνάρτησης \pyinline{next} με όποια από τις παραπάνω εναλλακτικές υλοποιήσεις θέλετε. 

Εκτελέστε ξανά το πρόγραμμα. Παρατηρείτε κάποια διαφορά στη λειτουργία του σε σχέση με πριν;

% [modified] "φαίνεται να μην έχει σημασία" σε "δεν έχει σημασία"
\begin{answer}
Όχι, και πάλι δεν υπάρχει καμία διαφορά στη λειτουργία του προγράμματος. Έχει όμως ενδιαφέρον ότι το κύριο πρόγραμμα δεν τροποποιήθηκε καθόλου, παρόλο που άλλαξε πλήρως ο τρόπος που λειτουργεί η \pyinline{next}. Ουσιαστικά, για το κύριο πρόγραμμα δεν έχει σημασία με ποιον τρόπο λειτουργεί η \pyinline{next}, αρκεί να επιστρέφει το αποτέλεσμα που πρέπει. 
\end{answer}

Για να κατανοήσετε καλύτερα τη λειτουργία των παραπάνω εκδοχών της συνάρτησης \pyinline{next} συμπληρώστε τον πίνακα που ακολουθεί για τις τιμές \pyinline{1} και \pyinline{2} της παραμέτρου \pyinline{p}.

\begin{center}
\vspace{-3pt}
\begin{tabular}{ccc}
\parbox[c][0pt][c]{76pt}{\center\small πιθανές τιμές της παραμέτρου \pyinline{p}} & %
\parbox[c][0pt][c]{84pt}{\center\small τιμές της έκφρασης \pyinline{(p} \% \pyinline{2) + 1}} &
\parbox[c][0pt][c]{84pt}{\center\small τιμές της έκφρασης \pyinline{3 - p}}\\\addlinespace[3\parskip]
\pyinline{1} & \pyinline{(1} \% \pyinline{2) + 1} \,$\rightarrow$\, \pyinline{1 + 1} \,$\rightarrow$\, \pyinline{2} & \pyinline{3 - 1} \,$\rightarrow$\, \pyinline{2}\\\addlinespace[\parskip]
\pyinline{2} & \pyinline{(2} \% \pyinline{2) + 1} \,$\rightarrow$\, \pyinline{0 + 1} \,$\rightarrow$\, \pyinline{1} & \pyinline{3 - 2} \,$\rightarrow$\, \pyinline{1}\\%\hline
\end{tabular}
\vspace{-3pt}
\end{center}

Ποια από τις δύο υλοποιήσεις της συνάρτησης \pyinline{next} επιλέξατε να χρησιμοποιήσετε στο πρόγραμμά σας; Τι σας ώθησε να κάνετε την επιλογή αυτή;

\begin{answer}
Επέλεξα τη δεύτερη γιατί υπολογίζει το αποτέλεσμα με μια απλή αφαίρεση.
\end{answer}

Εντοπίζετε κάποιο πλεονέκτημα στις εναλλακτικές υλοποιήσεις σε σχέση με την αρχική;

\begin{answer}
Μου αρέσει το γεγονός ότι οι εναλλακτικές υλοποιήσεις υπολογίζουν το αποτέλεσμα απευθείας, χωρίς να χρειαστεί να ελεγχθεί η τιμή της παραμέτρου \pyinline{p} με μια \pyinline{if}. Ο τρόπος που λειτουργούν μοιάζει με ``κόλπο''.
\end{answer}

\marginnote[22pt]{Η γενίκευση της \pyinline{next} ζητείται ως επέκταση στο αντίστοιχο κεφάλαιο. Μπορείτε να διαβάσετε την ακριβή εκφώνηση, αλλά και να συμβουλευτείτε την προτεινόμενη λύση.}
Ποια ή ποιες από τις υλοποιήσεις της \pyinline{next}, συμπεριλαμβανομένης της αρχικής, θεωρείτε ότι μπορεί να γενικευτεί εύκολα, ώστε η \pyinline{next} να είναι επαναχρησιμοποιήσιμη σε παιχνίδια όπου συμμετέχουν περισσότεροι από δύο παίκτες;

\begin{answer}
% [modified] παράδειγμα με τέσσερις παίκτες
Όταν συμμετέχουν, για παράδειγμα, τέσσερις παίκτες, τότε ο παίκτης που παίζει μετά τον \pyinline{1} είναι ο \pyinline{2}, μετά τον \pyinline{2} ο \pyinline{3}, μετά τον \pyinline{3} ο \pyinline{4} και μετά από αυτόν πάλι ο \pyinline{1}. 

Η αρχική υλοποίηση της \pyinline{next} με την \pyinline{if}--\pyinline{else} μπορεί να επεκταθεί και σε τέτοια παιχνίδα, αφού θα έλεγε κανείς ότι υπάρχουν και πάλι δύο περιπτώσεις: αν ο \pyinline{p} δεν είναι ο τελευταίος παίκτης τότε ο επόμενος είναι ο \pyinline{p + 1}. Σε διαφορετική περίπτωση, ο επόμενος παίκτης είναι ο~\pyinline{1}. 

Η υλοποίηση με το υπόλοιπο επίσης μπορεί να γενικευτεί σε περισσότερους παίκτες. Αντί να υπολογίζουμε το υπόλοιπο της διαίρεσης με το \pyinline{2}, αρκεί να υπολογίζουμε το υπόλοιπο της διαίρεσης με το πλήθος των παικτών.

Αντιθέτως, η τρίτη υλοποίηση φαίνεται να ``πηγαινοέρχεται'' ανάμεσα σε δύο τιμές μόνο. Δεν γίνεται αυτή η προσέγγιση να γενικευτεί σε περισσότερους παίκτες.
\end{answer}
\end{step}

\section{Μη Λέμε κι Ό,τι Θέλουμε}

Το πρόγραμμά μας επιτρέπει στον παίκτη που παίζει κάθε φορά ν' αφαιρέσει όσα σπίρτα θέλει. Θα επεκτείνουμε το πρόγραμμα, έτσι ώστε να ελέγχει τον αριθμό των σπίρτων που ζητά ν' αφαιρέσει ο παίκτης και να μην επιτρέπει κινήσεις που παραβιάζουν τους κανόνες του παιχνιδιού. 

\begin{step}
\label{step:check-start}
Για το σκοπό αυτό θα υλοποιήσουμε αρχικά μια συνάρτηση που θα δέχεται σαν παράμετρο το πλήθος \pyinline{m} των σπίρτων που έχουν απομείνει και θα επιστρέφει το \emph{μέγιστο} πλήθος σπίρτων που επιτρέπεται ν' αφαιρεθούν. 

Σύμφωνα με τους κανόνες του παιχνιδιού, ένας παίκτης επιτρέπεται να αφαιρέσει από ένα μέχρι και τρία σπίρτα κάθε φορά, αρκεί τα σπίρτα που έχουν απομείνει στο τραπέζι να είναι περισσότερα από τρία. Σε διαφορετική περίπτωση, θα πρέπει πάρει το πολύ όσα σπίρτα βρίσκονται στο τραπέζι.

\emph{Προσθέστε} την παρακάτω εντολή στο πρόγραμμά σας για να δηλώσετε τη συνάρτηση \pyinline{maxMatches}.

\begin{pynew}
def maxMatches(m):
\end{pynew}

Χρησιμοποιήστε κατάλληλα την \pyinline{if}--\pyinline{else}, ώστε η συνάρτηση να επιστρέφει το μέγιστο αριθμό σπίρτων που μπορούν να αφαιρεθούν ανάλογα με τον αριθμό των σπίρτων \pyinline{m} που βρίσκονται στο τραπέζι. 

\begin{answer}
Αν τα σπίρτα \pyinline{m} που απομένουν είναι περισσότερα από τρία, τότε το μέγιστο πλήθος που μπορεί ν' αφαιρεθεί είναι τρία. Σε διαφορετική περίπτωση, ένας παίκτης μπορεί να αφαιρέσει το πολύ όσα σπίρτα απομένουν. Συνεπώς, θα συμπληρώσουμε τη \pyinline{maxMatches} ως εξής: 

\begin{pyplain}
def maxMatches(m):
\end{pyplain}
\begin{pynew}
    if m > 3:
        return 3
    else:
        return m
\end{pynew}
\end{answer}
\end{step}

\begin{step}
\label{step:check-matches}
Προσθέστε τις παρακάτω εντολές αμέσως μετά την εντολή του βήματος~\ref{step:ask-matches-player} που διαβάζει τον αριθμό των σπίρτων που θέλει ν' αφαιρέσει ο παίκτης.

\begin{pyplain}
    print("Παίκτη", player, "πόσα σπίρτα θέλεις;")
    removed = int(input())
\end{pyplain}
\begin{pynew}
    limit = maxMatches(matches)
    if removed < 1 or removed > limit:
        print("Πάρε από 1 μέχρι και", limit, "σπίρτα") 
\end{pynew}

Τι αποτέλεσμα πιστεύετε ότι θα έχει η προσθήκη των παραπάνω εντολών; 

\begin{answer}
Η πρώτη εντολή καλεί την \pyinline{maxMatches} για να υπολογίσει το μέγιστο πλήθος σπίρτων που επιτρέπεται ν' αφαιρεθούν και ονομάζει την τιμή που επιστρέφεται \pyinline{limit}. Η δεύτερη εντολή ελέγχει αν ο αριθμός σπίρτων που πληκτρολόγησε ο παίκτης είναι \emph{έγκυρος}, δηλαδή τουλάχιστον ίσος με \pyinline{1} και το πολύ ίσος με \pyinline{limit}. Σε περίπτωση που ο αριθμός σπίρτων δεν είναι έγκυρος, τότε εμφανίζεται ένα σχετικό μήνυμα.
\end{answer}

Εκτελέστε το πρόγραμμα δίνοντας μια σειρά από λανθασμένες τιμές στον αριθμό των σπίρτων που αφαιρούνται. Εμφανίζεται το μήνυμα για τον μη-έγκυρο αριθμό σπίρτων;

\begin{answer}
Εκτελώντας το πρόγραμμα, ζητήσαμε να αφαιρέσουμε διαδοχικά \pyinline{4} και \pyinline{5} σπίρτα. Και στις δύο περιπτώσεις εμφανίστηκε το μήνυμα. 
\end{answer}

Σε περίπτωση που ο παίκτης δώσει μη-έγκυρη τιμή το πρόγραμμα την ξαναζητά ή συνεχίζει κανονικά τη λειτουργία του;

\begin{answer}
% Αν και εμφανίζεται μήνυμα για μη-έγκυρη τιμή, το πρόγραμμα δεν ζητά εκ νέου από το χρήστη να πληκτρολογήσει μια έγκυρη τιμή. Αντίθετα, τα σπίρτα που ζητάμε αφαιρούνται κανονικά από το συνολικό πλήθος, ακόμα κι όταν ζητάμε περισσότερα απ' όσα επιτρέπεται.
Όταν ο παίκτης δώσει μη-έγκυρη τιμή τότε το πρόγραμμα εμφανίζει σχετικό μήνυμα, όμως αμέσως μετά εμφανίζει και το μήνυμα για τα σπίρτα που απομένουν, όπου φαίνεται ότι το πλήθος των σπίρτων που ζητήθηκαν έχει αφαιρεθεί, παρόλο που δεν ήταν έγκυρο. Επομένως, παρά το μήνυμα περί μη-έγκυρης τιμής, το πρόγραμμα συνεχίζει κανονικά την εκτέλεση των εντολών της επανάληψης, χωρίς να ζητά εκ νέου από τον παίκτη να πληκτρολογήσει μια έγκυρη τιμή. 
\end{answer}

Γιατί πιστεύετε ότι συμβαίνει αυτό;

\begin{answer}
Ο κώδικας που προσθέσαμε κάνει απλά έναν έλεγχο (με την \pyinline{if}). Δεν περιλαμβάνεται \emph{σε αυτόν τον κώδικα} κάποια εντολή που να ξαναζητά από το χρήστη να πληκτρολογήσει τιμή, σε περίπτωση που η αρχική τιμή που πληκτρολογεί δεν είναι έγκυρη. 
\end{answer}

Τι θα προτείνατε για να διορθωθεί η λειτουργία του προγράμματος;

\begin{answer}
Το πρόγραμμά μας ήδη περιλαμβάνει εντολές που ζητούν από το παίκτη να πληκτρολογήσει το πλήθος των σπίρτων που επιθυμεί να αφαιρέσει. Θα πρέπει λοιπόν αυτές τις εντολές να τις αντιγράψουμε και μέσα στην \pyinline{if}, ώστε να ξαναζητείται το πλήθος των σπίρτων σε περίπτωση μη-έγκυρης τιμής.
\end{answer}
\end{step}

\begin{step}
\label{step:check-matches-2}
\emph{Προσθέστε} εκ νέου \emph{και} μέσα στην \pyinline{if} τις εντολές του βήματος \ref{step:ask-matches-player} που προτρέπουν τον παίκτη να δώσει αριθμό σπίρτων και ζητούν την απάντησή του, ώστε όταν δίνει μη-έγκυρη απάντηση το πρόγραμμα να ξαναζητά τα σπίρτα που θέλει ο παίκτης να αφαιρέσει.

\begin{answer}
Με αυτή την προσθήκη, ο σχετικός κώδικας γίνεται πλέον:

\begin{pyplain}
    print("Παίκτη", player, "πόσα σπίρτα θέλεις;")
    removed = int(input())
    limit = maxMatches(matches)
    if removed < 1 or removed > limit:
        print("Πάρε από 1 μέχρι και", limit, "σπίρτα") 
\end{pyplain}
\begin{pynew}
        print("Παίκτη", player, "πόσα σπίρτα θέλεις;")
        removed = int(input())
\end{pynew}
\end{answer}

Εκτελέστε το πρόγραμμα δίνοντας διαδοχικά μια μη-έγκυρη τιμή και στη συνέχεια μια έγκυρη. Λειτουργεί σωστά;

\begin{answer}
Ναι! Αρχικά ζητήσαμε \pyinline{4} σπίρτα και εμφανίστηκε το μήνυμα περί μη-έγκυρης τιμής. Όμως, αντί το πρόγραμμα να προχωρήσει όπως πριν, τώρα ξαναζήτησε το πλήθος των σπίρτων που θα αφαιρεθούν. Ζητήσαμε \pyinline{3} σπίρτα και το πρόγραμμα προχώρησε κανονικά, αφαιρώντας τα από το σύνολο.
\end{answer}

Εκτελέστε ξανά το πρόγραμμα δίνοντας διαδοχικά δύο μη-έγκυρες τιμές. Τι παρατηρείτε; 

\begin{answer}
Αρχικά ζητήσαμε \pyinline{4} σπίρτα και εμφανίστηκε το μήνυμα περί μη-έγκυρης τιμής, χωρίς τα σπίρτα να αφαιρεθούν. Στη συνέχεια, ξαναζητήσαμε \pyinline{4} σπίρτα και δυστυχώς τα σπίρτα αφαιρέθηκαν κανονικά από το σύνολο.
\end{answer}
\end{step}

\begin{step}
\label{step:check-matches-loop}
Παρόλο που στην πρώτη μη-έγκυρη τιμή το πρόγραμμα εμφανίζει μήνυμα σφάλματος στον παίκτη και του ζητάει να δώσει ξανά την τιμή των σπίρτων, στην επόμενη του επιτρέπει να συνεχίσει με τον αριθμό σπίρτων που διάλεξε. Θα χρησιμοποιήσουμε τη \pyinline{while}, προκειμένου το πρόγραμμα να ξαναζητά τον αριθμό των σπίρτων που θέλει ο παίκτης όσο η απάντηση του παραμένει εκτός ορίων.

\emph{Τροποποιήστε} την \pyinline{if} και στη θέση της βάλτε την εντολή \pyinline{while} ώστε να κάνει τον έλεγχο για την εγκυρότητα του αριθμού των σπίρτων, όπως παρακάτω:

\begin{pyplain}
|\pyhighlight{while}| removed < 1 or removed > limit:
\end{pyplain}

Εκτελέστε το πρόγραμμα και δώστε μια σειρά από λανθασμένες και έγκυρες τιμές. Λειτουργεί σωστά;

\begin{answer}
H \pyinline{while} ``εγκλωβίζει'' το χρήστη σε έναν κύκλο, ο οποίος διακόπτεται μόνο όταν δοθεί έγκυρη τιμή. Όσες μη-έγκυρες τιμές κι αν δώσει ο χρήστης, το πρόγραμμα δεν συνεχίζει μέχρι να δοθεί μια τιμή εντός των επιτρεπτών ορίων. Μόνο όταν γίνει αυτό, το πρόγραμμα συνεχίζει με τις εντολές που ακολουθούν, αφαιρώντας τα σπίρτα που ζητήθηκαν και εμφανίζοντας το μήνυμα για τον αριθμό των σπίρτων που απομένουν.
\end{answer}

\end{step}

\begin{step}
% Ένα ακόμα υποπρόγραμμα που θα κατασκευάσουμε θα διαβάζει από τον παίκτη το πλήθος των σπίρτων που επιθυμεί να αφαιρέσει. 
Με τις εντολές που προσθέσαμε στα βήματα~\ref{step:check-matches}, \ref{step:check-matches-2} και \ref{step:check-matches-loop}, το πρόγραμμά μας δε διαβάζει απλά από τον παίκτη το πλήθος των σπίρτων που επιθυμεί ν' αφαιρέσει, αλλά επίσης \emph{ελέγχει} την τιμή που δίνει ο παίκτης και \emph{εξασφαλίζει} ότι αυτή δεν παραβιάζει τους κανόνες του παιχνιδιού. Τώρα θα κατασκευάσουμε ένα υποπρόγραμμα το οποίο υλοποιεί αυτή ακριβώς τη λειτουργία.

% \emph{Προσθέστε} τις παρακάτω εντολές προκειμένου να ορίσετε τη συνάρτηση \pyinline{readMatches}.
\emph{Προσθέστε} την εντολή που ακολουθεί για να ορίσετε τη συνάρτηση \pyinline{readMatches}, η οποία δέχεται ως παραμέτρους τον αριθμό \pyinline{p} του παίκτη που έχει σειρά να παίξει και το πλήθος \pyinline{m} των σπίρτων που απομένουν.

\begin{pynew}
def readMatches(p,m):            
\end{pynew} 

\emph{Προσθέστε} στη συνάρτηση τις κατάλληλες εντολές έτσι ώστε να εμφανίζει μήνυμα προτροπής προς τον παίκτη με αριθμό \pyinline{p}, να ζητά από τον παίκτη τον αριθμό των σπίρτων που επιθυμεί να αφαιρέσει και, αφού εξασφαλίσει με τους απαραίτητους ελέγχους ότι ο αριθμός των σπίρτων είναι έγκυρος με βάση τα σπίρτα \pyinline{m} που απομένουν, να επιστρέφει τον αριθμό αυτό.

\begin{note}
Στην ουσία ο κώδικας που χρειάζεστε υπάρχει έτοιμος στο κύριο πρόγραμμα. Ακολουθήστε ανάλογη προσέγγιση και στη συνάρτηση, χρησιμοποιώντας τις ``τοπικές'' μεταβλητές \pyinline{p} και \pyinline{m}. Σε περίπτωση που δυσκολευτείτε μπορείτε να ανατρέξετε στα βήματα \ref{step:check-matches}, \ref{step:check-matches-2} και \ref{step:check-matches-loop}. 

Θυμηθείτε να υπάρχουν οι κατάλληλες εσοχές στις εντολές της συνάρτησης και να χρησιμοποιήσετε την εντολή \pyinline{return}, προκειμένου να επιστρέψετε το αποτέλεσμα στο πρόγραμμα.
\end{note}

\begin{answer}
Ο ορισμός της συνάρτησης \pyinline{readMatches} θα συμπληρωθεί ως εξής:

\begin{pyplain}
def readMatches(p,m):            
\end{pyplain}
\begin{pynew}
    print("Παίκτη", p, "πόσα σπίρτα θέλεις;")
    r = int(input())
    limit = maxMatches(m)
    while r < 1 or r > limit:
        print("Πάρε από 1 μέχρι και", limit, "σπίρτα.")
        print("Παίκτη", p, "πόσα σπίρτα θέλεις;")
        r = int(input())
    return r
\end{pynew}

Η προσέγγιση είναι ουσιαστικά ίδια με εκείνη που χρησιμοποιήσαμε στο κύριο πρόγραμμα. Εδώ όμως εστιάζουμε μόνο στη λειτουργία που θέλουμε να υλοποιεί η συνάρτηση: με δεδομένο τον αριθμό \pyinline{p} ενός παίκτη, και τα σπίρτα \pyinline{m} που απομένουν, ποιό είναι το (απαραίτητα έγκυρο) πλήθος σπίρτων που επιθυμεί να αφαιρέσει ο παίκτης \pyinline{p};
\end{answer}
\end{step}

\begin{step}
Με τις εντολές που προσθέσαμε στα βήματα~\ref{step:check-matches}, \ref{step:check-matches-2} και \ref{step:check-matches-loop}, το πρόγραμμά
μας εξασφαλίζει ότι η τιμή που θα πάρει η \pyinline{removed} από τον παίκτη θα είναι συμβατή με τους κανόνες του παιχνιδιού. Τώρα διαθέτουμε για τον σκοπό αυτό την συνάρτηση \pyinline{readMatches}. 

\emph{Αντικαταστήστε} όποιες εντολές του προγράμματος κρίνετε απαραίτητο με την κλήση της συνάρτησης, όπως φαίνεται παρακάτω.

\begin{pynew}
removed = readMatches(player, matches)
\end{pynew}

\begin{answer}
Με τη χρήση της \pyinline{readMatches} για την ανάγνωση των σπίρτων που θα αφαιρεί σε κάθε κύκλο ο παίκτης, η βασική επανάληψη του παιχνιδιού παίρνει την παρακάτω μορφή:

\begin{pyplain}
while matches > 0:
\end{pyplain}
\begin{pynew}
    removed = readMatches(player, matches)    
\end{pynew}
\begin{pyplain}
    matches = matches - removed
    print("Σπίρτα που απομένουν:", matches)
    player = next(player)
\end{pyplain}
\end{answer}

Εκτελέστε το πρόγραμμα. Λειτουργεί σωστά; Παρατηρείτε κάποια διαφορά στη λειτουργία του;

\begin{answer}
Το πρόγραμμα λειτουργεί σωστά. Παρά τις εσωτερικές αλλαγές, ο χρήστης δεν αντιλαμβάνεται καμία απολύτως διαφορά στα μηνύματα που βλέπει και στον τρόπο που αλληλεπιδρά με το πρόγραμμα. 
\end{answer}

Παρατηρήστε την έκταση και την πολυπλοκότητα που έχει αυτή την στιγμή το κύριο πρόγραμμα. Πιστεύετε ότι η χρήση συναρτήσεων έχει βελτιώσει την \emph{αναγνωσιμότητα} του προγράμματος;

\begin{note}
Ένα πρόγραμμα είναι αναγνώσιμο όταν το διαβάζει κανείς και καταλαβαίνει πως λειτουργεί χωρίς να καταβάλει μεγάλη προσπάθεια.
\end{note}

\begin{answer}
Το κύριο πρόγραμμα εξακολουθεί να είναι μικρό και συμπαγές, όπως ήταν πριν ξεκινήσουμε το βήμα~\ref{step:check-start}. Όλος ο κώδικας για τον έλεγχο εγκυρότητας έχει ενσωματωθεί μέσα στις συναρτήσεις που κατασκευάσαμε. Στο κύριο πρόγραμμα, η μόνη ουσιαστική αλλαγή που έχει γίνει είναι ότι η τιμή της \pyinline{removed} δεν διαβάζεται απευθείας από το χρήστη με την \pyinline{input}, αλλά ελεγχόμενα, με τη \pyinline{readMatches}.
\end{answer}
\end{step}

\section{Χαζό Μηχάνημα}
Θα τροποποιήσουμε τώρα το πρόγραμμα, ώστε να αναλαμβάνει το ρόλο ενός από τους δύο παίκτες. Δεν είναι ανάγκη να καταλήξουμε από την αρχή σε κάποια ευφυή στρατηγική για το πρόγραμμά μας.

\begin{step}
Μπορείτε να προτείνετε έναν απλό - ``χαζό'' τρόπο για να επιλέγει το πρόγραμμα το πλήθος των σπίρτων που θα αφαιρεί όταν έχει σειρά να παίξει;

\begin{answer}
Όταν είμαστε αρχάριοι σ' ένα παιχνίδι, παίζουμε λίγο-πολύ τυχαία. Και σ' αυτή την περίπτωση, μπορεί το πρόγραμμα να επιλέγει τυχαία το πλήθος των σπίρτων που θα αφαιρεί κάθε φορά που έχει σειρά να παίξει.
\end{answer}

Θα κατασκευάσουμε μια απλή συνάρτηση η οποία θα επιλέγει \emph{τυχαία} το πλήθος των σπίρτων που θα αφαιρεί το πρόγραμμα, φροντίζοντας αυτό το πλήθος να μην υπερβαίνει το μέγιστο πλήθος σπίρτων που επιτρέπεται να αφαιρεθούν.

Πώς θα υπολογίζει η συνάρτηση τον μέγιστο πλήθος σπίρτων που μπορούν να αφαιρεθούν;

\clearpage
\begin{answer}
Θα χρησιμοποιηθεί η συνάρτηση \pyinline{maxMatches}, η οποία περιέχεται ήδη στο πρόγραμμα και υλοποιεί αυτή ακριβώς τη λειτουργία. 

Η \pyinline{maxMatches} αναπτύχθηκε για να χρησιμοποιηθεί στα πλαίσια του ελέγχου εγκυρότητας, αλλά αποδεικνύεται χρήσιμο ``εξάρτημα'' που επαναχρησιμοποιείται και σε διαφορετικό σημείο του προγράμματος, με διαφορετικό σκοπό.
\end{answer}

\emph{Προσθέστε} στο πρόγραμμα την παρακάτω εντολή που ορίζει τη συνάρτηση \pyinline{randomMatches}, με παράμετρο το πλήθος \pyinline{m} των σπίρτων που απομένουν.

\begin{pynew}
def randomMatches(m):
\end{pynew}

\emph{Προσθέστε} στη συνάρτηση την κατάλληλη εντολή ή εντολές, προκειμένου να επιστρέφει στο πρόγραμμα έναν τυχαίο ακέραιο αριθμό από το \pyinline{1} μέχρι και το μέγιστο επιτρεπτό αριθμό σπίρτων που μπορεί να αφαιρέσει ο παίκτης.

\begin{answer}
Ο ορισμός της συνάρτησης \pyinline{randomMatches} θα συμπληρωθεί ως εξής:

\begin{pyplain}
def randomMatches(m):
\end{pyplain}
\begin{pynew}
    return random.randint(1,maxMatches(m))
\end{pynew}

Ίσως όμως έτσι το πρόγραμμα να ``αυτοκτονεί'', δηλαδή να αφαιρεί όλα τα σπίρτα ακόμα κι όταν έχει τη δυνατότητα να αφήσει τον αντίπαλό του με ένα (και να τον αναγκάσει να χάσει). Μια μικρή τροποποίηση:

\begin{pyplain}
def randomMatches(m):
\end{pyplain}
\begin{pynew}
    if m == 1:
        return 1
    elif m <= 4:
        return m - 1
    else:
\end{pynew}
\begin{pyplain}
        return random.randint(1,maxMatches(m))
\end{pyplain}

Έτσι, όταν απομένει μόνο ένα σπίρτο, το πρόγραμμα αναγκάζεται να το πάρει και όταν τα σπίρτα είναι δύο, τρία ή τέσσερα, τότε το πρόγραμμα αφήνει τον αντίπαλο με το τελευταίο σπίρτο. Σε αυτές τις περιπτώσεις δεν γίνεται πια τυχαία επιλογή των σπίρτων που θ' αφαιρεθούν.
\end{answer}
\end{step}

\begin{step}
Ας εστιάσουμε τώρα στο κύριο πρόγραμμα. Θα χρησιμοποιήσουμε μια μεταβλητή \pyinline{computer}, η οποία \emph{στην αρχή του παιχνιδιού} θα παίρνει τυχαία την τιμή \pyinline{1} ή \pyinline{2}. 
Η τιμή της \pyinline{computer} υποδεικνύει τον αριθμό του παίκτη που παίζει αυτοματοποιημένα, δηλαδή το ρόλο του τον έχει αναλάβει το ίδιο το πρόγραμμα.

\emph{Προσθέστε} στο πρόγραμμα την κατάλληλη εντολή που θα επιλέγει τυχαία είτε την τιμή \pyinline{1} είτε την τιμή \pyinline{2} και θα την αποθηκεύει στη μεταβλητή \pyinline{computer}.

\begin{answer}
Πριν την αρχή της επανάληψης, θα προστεθεί η εντολή:

\begin{pynew}
computer = random.randint(1,2)
\end{pynew}
\end{answer}
\end{step}

\begin{step}
Θυμηθείτε ότι στο τέλος κάθε γύρου, η μεταβλητή \pyinline{player} εναλλάσσεται μεταξύ των τιμών \pyinline{1} και \pyinline{2}, υποδεικνύοντας ποιος παίκτης έχει σειρά να παίξει στον επόμενο γύρο. Τώρα λοιπόν θα πρέπει να ελέγχουμε αν ο επόμενος παίκτης είναι ο άνθρωπος ή το πρόγραμμά μας, ώστε να καλέσουμε σε κάθε περίπτωση την ανάλογη συνάρτηση που θα μας επιστρέψει το πλήθος των σπίρτων που θα αφαιρεθούν.

\emph{Χρησιμοποιήστε} την \pyinline{if}--\pyinline{else}, ώστε η μεταβλητή \pyinline{removed} να παίρνει την τιμή που επιστρέφει η συνάρτηση \pyinline{randomMatches} όταν ο παίκτης που παίζει είναι ο υπολογιστής, και την τιμή που επιστρέφει η συνάρτηση \pyinline{readMatches} σε διαφορετική περίπτωση. 
Για να ελέγξετε με την \pyinline{if} ποιος έχει σειρά να παίξει, συγκρίνετε τις τιμές των μεταβλητών \pyinline{player} και \pyinline{computer}.

\begin{answer}
Μέσα στην επανάληψη, στο σημείο όπου μέχρι πρότινος υπήρχε μόνο η κλήση της \pyinline{readMatches}, τώρα ο κώδικας επεκτείνεται ως εξής:

\begin{pynew}
    if player == computer:
        removed = randomMatches(matches)
    else:
\end{pynew}
\begin{pyplain}
        removed = readMatches(player, matches)    
\end{pyplain}

Όταν οι μεταβλητές \pyinline{player} και \pyinline{computer} έχουν την ίδια τιμή, αυτό σημαίνει πως είναι σειρά του προγράμματος να επιλέξει κίνηση κι έτσι καλείται η \pyinline{randomMatches} για να υπολογιστεί το πλήθος των σπίρτων που πρέπει να αφαιρεθούν. Σε διαφορετική περίπτωση, επιλέγει κίνηση ο χρήστης, μέσω της \pyinline{readMatches}, όπως γινόνταν και προηγουμένως.
\end{answer}
\end{step}

\begin{step}
\emph{Προσθέστε} την κατάλληλη εντολή, ώστε όταν παίζει ο υπολογιστής να εμφανίζεται το πλήθος των σπίρτων που αφαιρεί. Για παράδειγμα:

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Ο υπολογιστής παίρνει 2 σπίρτα.
\end{pyterm}

\begin{answer}
Στην περίπτωση που παίζει το ίδιο το πρόγραμμα, προσθέτουμε την εντολή:

\begin{pyplain}
    if player == computer:
        removed = randomMatches(matches)
\end{pyplain}
\begin{pynew}
        print("Ο υπολογιστής παίρνει", removed, "σπίρτα.")
\end{pynew}
\begin{pyplain}
    else:
        removed = readMatches(player, matches)    
\end{pyplain}
\end{answer}
\end{step}

\begin{step}
Χρειάζεται να φροντίσουμε μια ακόμα σημαντική λεπτομέρεια. Μέχρι στιγμής, στο τέλος του παιχνιδιού ανακοινώνεται ο \emph{αριθμός} του παίκτη που έχασε. Τώρα που μόνο ο ένας παίκτης είναι άνθρωπος, είναι προτιμότερο να εμφανίζουμε διαφοροποιημένα μηνύματα.

\emph{Προσθέστε} τις κατάλληλες εντολές στο πρόγραμμα, ώστε ο νικητής ν' ανακοινώνεται ως εξής: αν κερδίσει ο παίκτης, να ανακοινώνεται ο αριθμός του, όπως ακριβώς συνέβαινε μέχρι στιγμής. Αν κερδίσει το πρόγραμμα, να εμφανίζεται το μήνυμα:

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Ο υπολογιστής κέρδισε.
\end{pyterm}

\clearpage
\begin{answer}
Όπως έχουμε δει, η μεταβλητή \pyinline{player} υποδεικνύει στο τέλος του παιχνιδιού ποιος είναι ο νικητής. Αν η \pyinline{player} έχει την ίδια τιμή με την \pyinline{computer}, τότε νικητής είναι το πρόγραμμα.

\begin{pynew}
if player == computer:
    print("Ο υπολογιστής κέρδισε.")
else:
\end{pynew}
\begin{pyplain}
    print("Παίκτη", player, "κέρδισες!")
\end{pyplain}
\end{answer}

Εκτελέστε το πρόγραμμά σας δύο φορές. Φροντίστε τη μία φορά να κερδίσετε εσείς ως παίκτης, ενώ την άλλη ο υπολογιστής. Εμφανίζει το κατάλληλο μήνυμα σε κάθε περίπτωση;

\begin{answer}
Εκτελώντας το πρόγραμμα, μπορούμε να πάρουμε τα τελευταία σπίρτα, χάνοντας επίτηδες. Στην περίπτωση αυτή το πρόγραμμα εμφανίζει το σωστό μήνυμα: ότι ο υπολογιστής κέρδισε. Σε μια δεύτερη εκτέλεση, με προσεκτικές κινήσεις όταν τα σπίρτα είναι λίγα, δεν είναι ιδιαίτερα δύσκολο να αφήσουμε το πρόγραμμα με ένα σπίρτο, αναγκάζοντάς το να χάσει. Και πάλι, το πρόγραμμα εμφανίζει το σωστό μήνυμα.
\end{answer}

\end{step}

\section{Άνθρωπος Εναντίον Μηχανής}
Όταν το πρόγραμμά μου παίζει τυχαία δεν έχει και μεγάλο ενδιαφέρον. Θα το κάνουμε λίγο πιο ``έξυπνο''.

\begin{step}
Θα πρέπει πρώτα εμείς να σχεδιάσουμε έναν καλύτερο τρόπο παιχνιδιού και μετά να τον περιγράψουμε με τις κατάλληλες εντολές.
Είναι ευκολότερο ν' αρχίσουμε μελετώντας ποιες είναι οι ενδεδειγμένες κινήσεις όταν απομένουν 2, 3 ή 4 σπίρτα: ο παίκτης που έχει σειρά να παίξει μπορεί να αφαιρέσει αντίστοιχα 1, 2 ή 3 σπίρτα και να κερδίσει άμεσα. Αντίθετα, όταν απομένουν 5 σπίρτα η κατάσταση είναι δύσκολη: όσα σπίρτα και να αφαιρέσει ο παίκτης που έχει σειρά να παίξει, η έκβαση είναι στα χέρια του αντιπάλου. 

Ανάλογες δυσάρεστες καταστάσεις, που θα ονομάσουμε «ανεπιθύμητες νησίδες», αντιμετωπίζει ο παίκτης που έχει σειρά να παίξει όταν απομένουν 9, 13, 17, κ.ο.κ σπίρτα. Όσα σπίρτα κι αν αφαιρέσει, ο αντίπαλος μπορεί να τον στείλει στην επόμενη νησίδα.

Προκειμένου να κατανοήσετε καλύτερα τη στρατηγική που πρέπει να ακολουθήσει το πρόγραμμα (ή ο οποιοσδήποτε παίκτης) για να παίζει ``εξυπνότερα'' συμπληρώστε τον πίνακα που ακολουθεί. Στην πρώτη στήλη δίνεται ο αριθμός των σπίρτων. Στη δεύτερη στήλη θα συμπληρώσετε το υπόλοιπο της διαίρεσης του αριθμού των σπίρτων με το \pyinline{4}, ενώ στην τρίτη στήλη τον αριθμό των σπίρτων που πρέπει να αφαιρεθούν, προκειμένου να οδηγηθεί ο αντίπαλος σε μια ``ανεπιθύμητη'' νησίδα, σύμφωνα με την περιγραφή που προηγήθηκε.

%\marginnote[24pt]{Στην πρώτη στήλη δίνεται ο αριθμός των σπίρτων. Στη δεύτερη στήλη θα συμπληρώσετε το υπόλοιπο της διαίρεσης του αριθμού των σπίρτων με το \pyinline{4}, ενώ στην τρίτη στήλη τον αριθμό των σπίρτων που πρέπει να αφαιρεθούν, προκειμένου να οδηγηθεί ο αντίπαλος σε μια ``ανεπιθύμητη'' νησίδα, σύμφωνα με την περιγραφή που προηγήθηκε.}
\begin{center}
\begin{tabular}{cp{52pt}c}
σπίρτα & & κίνηση \\
\pyinline{m} & \pcenter{\pyinline{m}\%\pyinline{4}} & {\small πόσα αφαιρούνται} \\\addlinespace[2\parskip]
\pyinline{6} & \pcenter{\pyinline{2}} & \pyinline{1}\\\addlinespace[\parskip]
\pyinline{7} & \pcenter{\pyinline{3}} & \pyinline{2}\\\addlinespace[\parskip]
\pyinline{8} & \pcenter{\pyinline{0}} & \pyinline{3}\\\addlinespace[\parskip]
\pyinline{9} & \pcenter{\pyinline{1}} & αδιάφορο \\\addlinespace[\parskip]
\pyinline{10} & \pcenter{\pyinline{2}} & \pyinline{1}\\\addlinespace[\parskip]
\pyinline{11} & \pcenter{\pyinline{3}} & \pyinline{2}\\\addlinespace[\parskip]
\pyinline{12} & \pcenter{\pyinline{0}} & \pyinline{3}\\\addlinespace[\parskip]
\pyinline{13} & \pcenter{\pyinline{1}} & αδιάφορο \\\addlinespace[\parskip]
\pyinline{14} & \pcenter{\pyinline{2}} & \pyinline{1}\\\addlinespace[\parskip]
\pyinline{15} & \pcenter{\pyinline{3}} & \pyinline{2}\\\addlinespace[\parskip]
\pyinline{16} & \pcenter{\pyinline{0}} & \pyinline{3}\\%\hline
\end{tabular}
\end{center}

Παρατηρείτε κάποια σχέση ανάμεσα στον αριθμό της δεύτερης και της τρίτης στήλης;

\begin{answer}
Οι δύο στήλες είναι άμεσα συνδεδεμένες. Η τιμή της παράστασης \pyinline{m} \% \pyinline{4} μπορεί να καθορίσει αυτόματα πόσα σπίρτα πρέπει να αφαιρεθούν.
\end{answer}

Στις περιπτώσεις που ο αριθμός των σπίρτων που βρίσκονται στο τραπέζι είναι τέτοιος που δεν μπορεί να οδηγήσει τον παίκτη σε νίκη (για παράδειγμα το \pyinline{13}), πώς θα μπορούσε να επιλέγει τα σπίρτα που θα αφαιρέσει;

\begin{answer}
Σε αυτές τις περιπτώσεις δεν έχει σημασία πόσα σπίρτα θα επιλέξει ο παίκτης. Θα μπορούσε απλά να επιλέγει τυχαία.
\end{answer}
\end{step}

\begin{step}
Με βάση τα παραπάνω, μπορούμε να υλοποιήσουμε ένα υποπρόγραμμα που δέχεται σαν παράμετρο το πλήθος \pyinline{m} των σπίρτων που απομένουν και επιστρέφει το πλήθος των σπίρτων που πρέπει να αφαιρεθούν ώστε ο αντίπαλος να οδηγηθεί σε μια ανεπιθύμητη νησίδα. Στην περίπτωση που ο παίκτης βρίσκεται ήδη σε ανεπιθύμητη νησίδα, επιστρέφεται ένας τυχαίος αριθμός σπίρτων, καλώντας την \pyinline{randomMatches}. 

\begin{pycode}
def computeMatches(m):
    mod = m % 4
    if mod == 0:
        return 3
    elif mod == 1:
        return randomMatches(m)
    elif mod == 2:
        return 1  
    else:
        return 2
\end{pycode}
\end{step}

\begin{step}
Στο κύριο πρόγραμμα, \emph{αντικαταστήστε} την κλήση της συνάρτησης \pyinline{randomMatches} που επιλέγει ένα τυχαίο πλήθος σπίρτων, με μια κλήση στην \pyinline{computeMatches}, ώστε πλεόν το πρόγραμμα να επιλέγει το πλήθος των σπίρτων που αφαιρείται ακολουθώντας συγκεκριμένη στρατηγική.

\begin{answer}
Αντικαθιστώντας την κλήση της μιας συνάρτησης με την άλλη, ο κώδικας έχει ως εξής:

\begin{pyplain}
    if player == computer:
        removed = |\pyhighlight{computeMatches(matches)}|
\end{pyplain}
\end{answer}

Εκτελέστε το πρόγραμμά σας. Λειτουργεί σωστά;

\begin{answer}
Όταν το πρόγραμμα ξεκινά πρώτο, χωρίς ο αρχικός αριθμός των σπίρτων να αντιστοιχεί σε ανεπιθύμητη νησίδα, παίζει ακριβώς όπως προβλέπεται από τον πίνακα, οδηγεί τον αντίπαλο σε κάθε γύρο σε μια ανεπιθύμητη νησίδα και τελικά κερδίζει. Όταν το πρόγραμμα ξεκινά δεύτερο και του δίνεται η ευκαιρία να φέρει τον αντίπαλό του σε ανεπιθύμητη νησίδα τότε και πάλι παίζει όπως προβλέπεται από τον πίνακα και κερδίζει.

Υπάρχουν μόνο δύο περιπτώσεις να κερδίσει ένας παίκτης το πρόγραμμα, με δεδομένο ότι παίζει τέλεια σε κάθε κίνηση: αν ξεκινήσει πρώτος χωρίς να βρίσκεται σε ανεπιθύμητη νησίδα ή αν ξεκινήσει πρώτο το πρόγραμμα, ευρισκόμενο σε ανεπιθύμητη νησίδα.
\end{answer}

\end{step}

\end{document}
