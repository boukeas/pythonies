\documentclass[a4paper,11pt,oneside]{book}

\input{../share/tuftelike}
\input{../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{4}

\usepackage{booktabs}

%%% DOCUMENT START

% [modified] Στα σημεία *αφότου* εισάγονται οι συναρτήσεις next και readMatches επισημάνθηκε γιατί είναι συμφέρουσα η χρήση τους. Έτσι αφενός τη δικαιολογούμε και αφετέρου παραπέμπουμε στα γενικότερα πλεονεκτήματα της χρήσης υποπρογραμμάτων που αναλύονται στη θεωρητική παράγραφο, στο τέλος του κεφαλαίου.

\begin{document}

\chapterwabstract{Το Παιχνίδι της Αφαίρεσης}{Στο κεφάλαιο αυτό θα φτιάξουμε ένα απλό παιχνίδι δύο παικτών μ' ενδιαφέρουσα ιστορία. Στο τέλος, το πρόγραμμά μας θα συμμετέχει στο παιχνίδι, παίζοντας το ρόλο ενός από τους δύο παίκτες. Στην πορεία θα έχουμε την ευκαιρία να έρθουμε ξανά σε επαφή με τις αλγοριθμικές δομές που έχουμε συναντήσει μέχρι στιγμής, ενώ θα χρησιμοποιήσουμε \emph{υποπρογράμματα}, για να κατακερματίσουμε το πρόγραμμά μας σε απλούστερα τμήματα και να διαχειριστούμε την πολυπλοκότητά του.}{δομή επιλογής, δομή επανάληψης, υποπρογράμματα}{subtractionColor}{white}

\vspace{-12pt}%
Το παιχνίδι που θα φτιάξουμε ονομάζεται ΝΙΜ. Είναι πολύ παλιό και πιθανότατα προέρχεται από την Κίνα. Έχει πολλές παραλλαγές κι εδώ θ' ασχοληθούμε με μια απλή εκδοχή του που ονομάζεται \emph{το παιχνίδι της αφαίρεσης}. Ένα πλήθος από αντικείμενα (π.χ. σπίρτα, ξυλάκια) τοποθετούνται στη σειρά και ο κάθε ένας από τους δύο παίκτες αφαιρεί με τη σειρά του από ένα μέχρι και τρία αντικείμενα, μέχρι να μείνει μόνο ένα. Ο παίκτης που θα μείνει με το τελευταίο αντικείμενο όταν είναι η σειρά του να παίξει \emph{χάνει} το παιχνίδι. Στη γενικότερη εκδοχή του ΝΙΜ, υπάρχουν περισσότερες σειρές από αντικείμενα.

Το ΝΙΜ είναι ένα από τα πρώτα παιχνίδια που αυτοματοποιήθηκαν και, όπως θα δούμε στη συνέχεια, υπάρχει λόγος γι' αυτό. Ήδη από το 1940 η αμερικάνικη εταιρεία Westinghouse παρουσίασε ένα μηχάνημα που έπαιζε ΝΙΜ, το Nimatron, ενώ στις αρχές της δεκαετίας του '50 εμφανίστηκαν ειδικού σκοπού ηλεκτρονικοί υπολογιστές που έπαιζαν ΝΙΜ, όπως ο NIMROD της βρετανικής Ferranti.

%%%%%%%%

\section{Το Στήσιμο}

\begin{question}
Ας υποθέσουμε ότι τα αντικείμενα που χρησιμοποιούν οι παίκτες είναι σπίρτα. Με πόσα πρέπει να ξεκινήσουμε;
\end{question}

Οι κανόνες του παιχνιδιού δεν προσδιορίζουν το αρχικό πλήθος των σπίρτων. Μπορούμε λοιπόν να το ορίσουμε μόνοι μας.

\begin{pycode}
# αρχικό πλήθος σπίρτων
matches = 7
\end{pycode}

Εναλλακτικά, μπορούμε να αρχικοποιήσουμε τη μεταβλητή \pyinline{matches} με μια τυχαία τιμή (ας πούμε από το 7 μέχρι και το 21).

% src/nim.1.py: τυχαίο αρχικό πλήθος σπίρτων
%\marginnote[18pt]{Η βιβλιοθήκη \pyinline{random} περιέχει συναρτήσεις για την παραγωγή τυχαίων αριθμών. Για να τη χρησιμοποιήσουμε θα πρέπει να την εισάγουμε (\pyinline{import}).}
%\marginnote{Η συνάρτηση \pyinline{randint()} από τη βιβλιοθήκη \pyinline{random}, παράγει τυχαίους ακέραιους αριθμούς, μέσα στα όρια που ορίζουν οι παράμετροί της.}
\pysrc[firstline=1,lastline=3]{src/nim.1.py}{}{}

%Η απόδοση αρχικής τιμής σε μια μεταβλητή, όπως έγινε εδώ για τη μεταβλητή \pyinline{matches}, ονομάζεται \emph{αρχικοποίηση}. Κατά τη διάρκεια του παιχνιδιού, καθώς οι παίκτες αφαιρούν σπίρτα, η τιμή της \pyinline{matches} θα τροποποιηθεί, όμως η αρχική τιμή καθορίζει το σημείο εκκίνησης.

Καλό θα ήταν να ενημερώσουμε το χρήστη με ένα κατάλληλο μήνυμα για τον αρχικό αριθμό των σπίρτων.

% src/nim.1.py: εμφάνιση αρχικού πλήθους σπίρτων
\pysrc[firstline=4,lastline=5]{src/nim.1.py}{}{}

%%%%%%%%

\section{Κάνε Ένα Γύρο}

\begin{question}
Τώρα θα πρέπει να γράψω τις εντολές για έναν γύρο του παιχνιδιού και να τις κάνω να επαναλαμβάνονται μέχρι να τελειώσει το παιχνίδι.
\end{question}

Το συγκεκριμένο παιχνίδι συνεχίζεται όσο απομένουν ακόμα κάποια σπίρτα -- αυτή είναι και η \emph{συνθήκη συνέχειας} της επανάληψης.

% src/nim.1.py: επανάληψη, συνεχίζεται όσο υπάρχουν σπίρτα
\pysrc[firstline=6,lastline=7]{src/nim.1.py}{}{}

Θα ακολουθήσουν οι εντολές που είναι εμφωλευμένες στην επαναληπτική δομή, δηλαδή οι εντολές που θα εκτελούνται ξανά και ξανά σε κάθε γύρο του παιχνιδιού.

%Η συνθήκη συνέχειας της επανάληψης %\pyinline{matches > 1}
%ελέγχεται \emph{πριν} από κάθε κύκλο για να διαπιστωθεί αν η επανάληψη πρέπει να συνεχιστεί. Όταν διαπιστωθεί ότι η συνθήκη δεν ισχύει (είναι \emph{ψευδής}), η επανάληψη τερματίζεται. Σημειώστε ότι η συνθήκη μπορεί να μην ισχύει ήδη από την πρώτη φορά που θα ελεγχθεί, οπότε σε αυτή την περίπτωση οι εντολές της επανάληψης δεν θα εκτελεστούν ούτε μία φορά.

Σε κάθε γύρο θα ζητείται από έναν παίκτη το πλήθος των σπίρτων που επιθυμεί να αφαιρέσει. 
%Στη μεταβλητή \pyinline{removed} αποθηκεύεται το πλήθος των σπίρτων που πληκτρολογεί ο παίκτης. 

% src/nim.1.py: ανάγνωση σπίρτων που θα πάρει ο παίκτης
\marginnote[18pt]{Η τιμή που επιστρέφει η \pyinline{input()} είναι \emph{αλφαριθμητική}, πρόκειται για το κείμενο που πληκτρολόγησε ο χρήστης. Χρειάζεται να μετατρέψουμε την τιμή αυτή σε ακέραιο αριθμό, να της αλλάξουμε τον \emph{τύπο}, και για την μετατροπή αυτή χρησιμοποιούμε την \pyinline{int()}.}
\pysrc[firstline=8,lastline=10]{src/nim.1.py}{}{}

Η μεταβλητή \pyinline{matches} θα πρέπει να μειώνεται σε κάθε κύκλο κατά το πλήθος των σπίρτων που αφαιρούνται από το τραπέζι.

% src/nim.1.py: μείωση σπίρτων
% [modified] (σχηματική) επεξήγηση για την απομείωση της τιμής της μεταβλητής
\marginnote{\center\includegraphics[scale=\scaling]{illustrations/matches-removed.pdf}
\captionof{figure}{\label{fig:matches-removed}Παράδειγμα μείωσης του πλήθους των σπίρτων: (α) υπολογίζεται η τιμή της παράστασης \pyinline{matches - removed}, δηλαδή το πλήθος των σπίρτων που θ' απομείνουν στο τραπέζι αφού αφαιρεθούν τα σπίρτα που επιλέγει ο παίκτης και (β) η τιμή αυτή αποτελεί τη νέα τιμή της \pyinline{matches}.}}
\pysrc[firstline=11,lastline=12]{src/nim.1.py}{}{}

% Η εντολή υπολογίζει την τιμή της παράστασης \pyinline{matches - removed}, δηλαδή υπολογίζει το πλήθος των σπίρτων που θ' απομείνουν στο τραπέζι αφού αφαιρεθούν τα σπίρτα που επιλέγει ο παίκτης. Το αποτέλεσμα ονομάζεται και πάλι \pyinline{matches}, αντικαθιστώντας την παλιότερη τιμή της μεταβλητής.

Κάτι ακόμα που χρειάζεται σε κάθε κύκλο του παιχνιδιού είναι να εμφανίζουμε στους παίκτες την τιμή της μεταβλητής \pyinline{matches}, ώστε να αποφασίζουν για το πλήθος των σπίρτων που θα αφαιρέσουν.

% src/nim.1.py: εμφάνιση πλήθους σπίρτων που απομένουν
\pysrc[firstline=13,lastline=14]{src/nim.1.py}{}{nim}

%%%%%%%%

\section{Ποιός Παίζει;}

\begin{question}
Προς το παρόν δεν υπάρχει διαφοροποίηση ανάμεσα στους παίκτες. Δεν ξέρουμε ούτε ποιος παίζει κάθε φορά, ούτε ποιος νικάει.
\end{question}

Σε κάθε κύκλο του παιχνιδιού, το πρόγραμμα ρωτάει πόσα σπίρτα θα αφαιρεθούν. Ωστόσο, δεν καταγράφει ποιος από τους δύο παίκτες είναι που αφαιρεί κάθε φορά τα σπίρτα κι έτσι δεν είναι σε θέση να υπολογίσει ποιος είναι ο νικητής όταν αυτά τελειώσουν.

\clearpage
\marginnote[18pt]{\center\includegraphics[scale=\scaling]{illustrations/player.pdf}
\captionof{figure}{Η τιμή της μεταβλητής \pyinline{player} εναλλάσσεται σε κάθε γύρο μεταξύ του \pyinline{1} και του \pyinline{2}, υποδεικνύοντας τον αριθμό του παίκτη που έχει σειρά να παίξει. Η αρχική της τιμή είναι το \pyinline{1}.}}
Υπάρχουν αρκετοί τρόποι να λύσουμε αυτό το πρόβλημα. Μια απλή προσέγγιση είναι να χρησιμοποιήσουμε μια μεταβλητή \pyinline{player}, η οποία σε κάθε γύρο θα παίρνει \emph{εναλλάξ} την τιμή \pyinline{1} ή \pyinline{2}, υποδεικνύοντας με αυτόν τον τρόπο ποιος παίκτης έχει σειρά να παίξει.

Αρχικά, πριν ξεκινήσει η διαδικασία του παιχνιδιού, ορίζουμε ποιος παίκτης ξεκινάει πρώτος: αυτός θα είναι πάντα ο παίκτης με αριθμό~\pyinline{1}.

% src/nim.2.py: ορισμός παίκτη που θα παίξει πρώτος
\pysrc[firstline=6,lastline=7]{src/nim.2.py}{}{}

Τώρα πλέον η προτροπή που εμφανίζεται σε κάθε κύκλο απευθύνεται σε συγκεκριμένο παίκτη:

% src/nim.2.py: ανάγνωση σπίρτων που θα πάρει ο παίκτης
\pysrc[firstline=10,lastline=10]{src/nim.2.py}{plain}{continued}
\pysrc[firstline=11,lastline=11]{src/nim.2.py}{}{continued}
\pysrc[firstline=12,lastline=12]{src/nim.2.py}{plain}{nim}

Πριν τελειώσει κάθε κύκλος της επανάληψης, η τιμή της μεταβλητής \pyinline{player} θα πρέπει να τροποποιείται, ώστε να υποδεικνύει τον επόμενο παίκτη που έχει σειρά να παίξει. 

Για τον υπολογισμό του επόμενου παίκτη θα χρησιμοποιήσουμε ένα υποπρόγραμμα, το οποίο δέχεται σαν παράμετρο τον αριθμό \pyinline{p} ενός παίκτη και επιστρέφει τον αριθμό του επόμενου παίκτη. 

% src/nim.3.py: ορισμός υποπρογράμματος next(p)
\marginnote[12pt]{\center\includegraphics[scale=\scaling]{illustrations/next.pdf}
\captionof{figure}{Αναπαράσταση της συνάρτησης \pyinline{next}, η οποία δέχεται σαν παράμετρο τον αριθμό \pyinline{p} ένος παίκτη και επιστρέφει τον αριθμό του παίκτη που παίζει μετά τον παίκτη \pyinline{p}.}}
% \marginnote{Ο τρόπος με τον οποίο λειτουργεί ``εσωτερικά'' η \pyinline{next}, δηλαδή ο τρόπος με τον οποίο υπολογίζει την τιμή που επιστρέφει, δεν αφορά και δεν επηρρεάζει τον προγραμματιστή που επιθυμεί να τη χρησιμοποιήσει.}
\pysrc[firstline=2,lastline=10]{src/nim.3.py}{}{}

% [modified] added
Το υποπρόγραμμα δεν τροποποιεί την τιμή της μεταβλητής \pyinline{player}, απλά επιστρέφει την επόμενη τιμή της. 
Στο κύριο πρόγραμμα, στο τέλος της επανάληψης, καλείται το υποπρόγραμμα και η τιμή που επιστρέφει, δηλαδή ο αριθμός του επόμενου παίκτη, γίνεται η νέα τιμή της μεταβλητής \pyinline{player}. 

% src/nim.3.py: εναλλαγή παίκτη (κλήση της next)
\marginnote[-60pt]{\center\includegraphics[scale=\scaling]{illustrations/player-next.pdf}
\captionof{figure}{\label{fig:player-next}Παράδειγμα εναλλαγής παίκτη: στο τέλος κάθε γύρου: (α) καλείται η συνάρτηση \pyinline{next}, με παράμετρο την τιμή της μεταβλητής \pyinline{player}. H \pyinline{next} επιστρέφει μια τιμή που αντιστοιχεί στον αριθμό του παίκτη που έχει σειρά να παίξει στον επόμενο γύρο και (β) αυτή η τιμή γίνεται η νέα τιμή της \pyinline{player}. }}
\pysrc[firstline=26,lastline=27]{src/nim.3.py}{}{}

% [modified] added
Η χρήση του υποπρογράμματος στην εναλλαγή του παίκτη διατηρεί τον κώδικά μας σύντομο και ευανάγνωστο. Με μία και μοναδική γραμμή καθορίζουμε ότι η τιμή της \pyinline{player} θα μεταβληθεί ώστε ν' αντιστοιχεί στον επόμενο παίκτη. Το \emph{πως} θα γίνει αυτό καθορίζεται εντός του υποπρογράμματος και δεν επηρρεάζει το σημείο όπου καλείται το υποπρόγραμμα.

Πράγματι, δεν υπάρχει μόνο ένας τρόπος να υλοποιηθεί η \pyinline{next}. Στον κώδικα που ακολουθεί δίνεται μια εναλλακτική προσέγγιση. 
% Ωστόσο, είναι σημαντικό πως 
Ανεξάρτητα από την εκδοχή της \pyinline{next} που θα επιλέξουμε να χρησιμοποιήσουμε, η κλήση της θα παραμείνει η ίδια. 

\marginnote[18pt]{Η έκφραση \pyinline{p} \% \pyinline{2} υπολογίζει το υπόλοιπο της ακέραιας διαίρεσης του \pyinline{p} με το \pyinline{2}. Η τιμή της μπορεί να είναι \pyinline{0} ή \pyinline{1}.}
\begin{pycode}
def next(p):
    """ Επιστρέφει τον αριθμό του παίκτη
    που παίζει μετά τον παίκτη p.
    p: αριθμός παίκτη (1 ή 2)
    """
    return (p % 2) + 1
\end{pycode}

Όταν η επανάληψη τελειώσει, η μεταβλητή \pyinline{player} δείχνει ποιος παίκτης θα είχε σειρά να παίξει \emph{μετά} τον παίκτη που πήρε τα τελευταία σπίρτα. Συνεπώς, μπορούμε να χρησιμοποιήσουμε τη μεταβλητή \pyinline{player} για να διαπιστώσουμε ποιος παίκτης κέρδισε.

% src/nim.3.py: εμφάνιση αποτελέσματος παιχνιδιού
\marginnote[18pt]{Δεν υπάρχει εσοχή πριν την εντολή που εμφανίζει το αποτέλεσμα του παιχνιδιού. Η εντολή είναι στοιχισμένη πιο αριστερά απ' τις προηγούμενες κι αυτό υποδηλώνει ότι δεν ανήκει στην επανάληψη. Αντίθετα είναι η πρώτη εντολή που θα εκτελεστεί όταν η επανάληψη διακοπεί.}
\pysrc[firstline=28,lastline=29]{src/nim.3.py}{}{nim}

%%%%%%%%

\section{Μη Λέμε κι Ό,τι Θέλουμε}

\begin{question}
Το πρόγραμμά μας επιτρέπει στους παίκτες να αφαιρέσουν σ' έναν γύρο όσα σπίρτα θέλουν! 
%Περισσότερα από τρία και περισσότερα κι απ' όσα έχουν απομείνει στο τραπέζι.
\end{question}

Σύμφωνα με τους κανόνες του παιχνιδιού, ένας παίκτης επιτρέπεται να αφαιρέσει από ένα μέχρι και τρία σπίρτα κάθε φορά, αρκεί τα σπίρτα που έχουν απομείνει στο τραπέζι να είναι περισσότερα από τρία. Σε διαφορετική περίπτωση, επιτρέπεται να αφαιρέσει το πολύ όσα σπίρτα έχουν απομείνει.

Θα φτιάξουμε ένα υποπρόγραμμα που δέχεται σαν παράμετρο το πλήθος των σπίρτων που έχουν απομείνει κι επιστρέφει το \emph{μέγιστο} πλήθος σπίρτων που επιτρέπεται ν' αφαιρεθούν. Χρειαζόμαστε αυτό το άνω όριο, για να μπορούμε να ελέγξουμε παρακάτω αν το πλήθος των σπίρτων που επιθυμεί ν' αφαιρέσει ο παίκτης είναι έγκυρο. 

% src/nim.4.py: ορισμός της συνάρτησης maxMatches(m)
\pysrc[firstline=11,lastline=20]{src/nim.4.py}{}{}

% [modified]
Τώρα μπορούμε να κατασκευάσουμε ένα υποπρόγραμμα το οποίο διαβάζει από τον παίκτη το πλήθος των σπίρτων που επιθυμεί ν' αφαιρέσει, \emph{ελέγχει} την τιμή που δίνει ο παίκτης κι \emph{εξασφαλίζει} ότι αυτή δεν παραβιάζει τους κανόνες. 

Το υποπρόγραμμα δέχεται ως παραμέτρους τον αριθμό \pyinline{p} του παίκτη που έχει σειρά να παίξει (για να εμφανίσει την κατάλληλη προτροπή) και το πλήθος \pyinline{m} των σπίρτων που απομένουν (για να κάνει τους απαραίτητους ελέγχους).

% [modified] κατακερματισμός του κώδικα της συνάρτησης και προσθήκη εξηγήσεων για τον έλεγχο εγκυρότητας
% src/nim.4.py: ορισμός της συνάρτησης readMatches(p,m)
\pysrc[firstline=21,lastline=27]{src/nim.4.py}{}{}

Αρχικά ζητείται από τον παίκτη να πληκτρολογήσει το πλήθος των σπίρτων που επιθυμεί να αφαιρέσει, έχοντας ήδη υπολογίσει το μέγιστο επιτρεπόμενο πλήθος, με βάση τα σπίρτα που απομένουν:

% src/nim.4.py: ανάγνωση σπίρτων που θα πάρει ο παίκτης
\pysrc[firstline=28,lastline=32]{src/nim.4.py}{}{}

Όσο η τιμή που πληκτρολογείται από τον παίκτη δεν είναι \emph{έγκυρη} (μέσα στα επιτρεπόμενα όρια), εμφανίζεται σχετικό μήνυμα και η ανάγνωση τιμής \emph{επαναλαμβάνεται}.

% src/nim.4.py: ορισμός της συνάρτησης readMatches(p,m)
\pysrc[firstline=33,lastline=39]{src/nim.4.py}{}{}

Γιατί πρέπει ο έλεγχος να επαναλαμβάνεται; Γιατί να μην ελεγxθεί η τιμή που δίνει ο παίκτης με μια απλή δομή επιλογής; Πρέπει να σκεφτούμε ότι ο χρήστης μπορεί να πληκτρολογεί \emph{συνεχώς} τιμές που δεν είναι έγκυρες. Χρειαζόμαστε λοιπόν την επανάληψη ώστε η ανάγνωση τιμής να εγκλωβιστεί σ' έναν κύκλο, ο οποίος διακόπτεται μόνο όταν ο χρήστης δώσει έγκυρη τιμή.

Όταν ολοκληρωθεί η επανάληψη, θα έχουμε εξασφαλίσει ότι η τιμή που θα έχει διαβαστεί από το χρήστη, η τιμή της \pyinline{num}, θα είναι έγκυρη. Μπορούμε λοιπόν πλέον να επιστρέψουμε αυτή την τιμή, ως το αποτέλεσμα του υποπρογράμματος.

% src/nim.4.py: ορισμός της συνάρτησης readMatches(p,m)
\pysrc[firstline=40,lastline=41]{src/nim.4.py}{}{}

Τώρα, στο κύριο πρόγραμμα μπορούμε να αντικαταστήσουμε την εντολή εισόδου που διαβάζει χωρίς έλεγχο τον αριθμό των σπίρτων, με την κλήση του υποπρογράμματος που κατασκευάσαμε.

% src/nim.4.py: ανάγνωση σπίρτων που θα πάρει ο παίκτης (κλήση της readMatches)
\pysrc[firstline=52,lastline=52]{src/nim.4.py}{plain}{continued}
\pysrc[firstline=53,lastline=53]{src/nim.4.py}{}{nim}

% [modified]
Αν δεν είχαμε κατασκευάσει το υποπρόγραμμα, θα είχαμε τοποθετήσει όλον τον κώδικα που υλοποιεί τους απαραίτητους ελέγχους μέσα στο κύριο πρόγραμμα, αυξάνοντας έτσι σημαντικά την πολυπλοκότητά του. 

%%%%%%%%

\section{Χαζό Μηχάνημα}

\begin{question}
Βαριέμαι να παίζω μόνος μου. Δεν γίνεται να παίζω με αντίπαλο το πρόγραμμά μου;
\end{question}

Το πρόγραμμά μας θα πρέπει να αποφασίζει για το πλήθος των σπίρτων που θα αφαιρέσει. Δεν είναι ανάγκη να καταλήξουμε από την αρχή σε κάποια ευφυή στρατηγική, μπορούμε να ξεκινήσουμε με μια τυχαία επιλογή σπίρτων. 

Θα κατασκευάσουμε ένα απλό υποπρόγραμμα το οποίο δέχεται σαν παράμετρο το πλήθος των σπίρτων που έχουν απομείνει και επιλέγει τυχαία να αφαιρέσει από \pyinline{1} μέχρι το μέγιστο πλήθος σπίρτων που επιτρέπεται να αφαιρεθούν.

% src/nim.5.py: ορισμός της συνάρτησης randomMatches(m)
\marginnote[18pt]{Οι παράμετροι που χρησιμοποιούνται κατά την κλήση μιας συνάρτησης δεν είναι μόνο σταθερές ή μεταβλητές, αλλά κι ολόκληρες εκφράσεις, που μπορεί να περιλαμβάνουν κλήσεις συναρτήσεων, %
% [modified]
όπως εδώ η \pyinline{maxMatches}. Στο παράδειγμα αυτό, \emph{πρώτα} καλείται η \pyinline{maxMatches} και η τιμή που επιστρέφει χρησιμοποιείται σαν δεύτερη παράμετρος στην κλήση της \pyinline{randint}.}

\pysrc[firstline=42,lastline=47]{src/nim.5.py}{}{}

Στην τελευταία γραμμή, η τιμή που επιστρέφει η \pyinline{maxMatches()} χρησιμοποιείται ως άνω όριο για τον τυχαίο αριθμό που θα δημιουργηθεί. Είναι σχεδόν το ίδιο με τον κώδικα που ακολουθεί, αλλά χωρίς την ενδιάμεση μεταβλητή \pyinline{limit}.

\begin{pycode}
    limit = maxMatches(m)
    return random.randint(1, limit)
\end{pycode}

Είναι ενδιαφέρον ότι η συνάρτηση \pyinline{maxMatches()} χρησιμοποιείται τώρα και από την \pyinline{readMatches()} για την ανάγνωση αριθμού από τον χρήστη, αλλά και από την \pyinline{randomMatches()} για την επιλογή ενός αριθμού σπίρτων από το ίδιο το πρόγραμμα. 
% [modified] added 
Αποδεικνύεται έτσι ένα χρήσιμο ``εξάρτημα'' που \emph{επαναχρησιμοποιείται} σε διαφορετικά σημεία του προγράμματος για διαφορετικούς λόγους. 
% [comment] Εδώ υπάρχουν πολλά ακόμα να ειπωθούν σε σχέση με τα πλεονεκτήματα των υποπρογραμμάτων, αλλά θα ξεφεύγαμε. Εξάλλου, καλύπτονται από τη "θεωρητική" παράγραφο στο τέλος του κεφαλαίου. Μήπως χρειάζεται μια παραπομπή εκεί;
% Αν δεν είχαμε αναπτύξει αυτό το υποπρόγραμμα θα αναγκαζόμασταν να επαναλάβουμε τον κώδικά του σε αυτά τα σημεία.

% [modified] 
Ας εστιάσουμε τώρα στο κύριο πρόγραμμα, όπου θα πρέπει να εισάγουμε τις απαραίτητες επεκτάσεις ώστε το ίδιο το πρόγραμμα να αναλαμβάνει πλέον το ρόλο ενός από τους δύο παίκτες. Θα χρησιμοποιήσουμε τη μεταβλητή \pyinline{computer}, της οποίας η τιμή θ' αντιστοιχεί στον αριθμό του παίκτη που θα παίζει αυτοματοποιημένα. Στην αρχή του παιχνιδιού η \pyinline{computer} θα παίρνει τυχαία την τιμή \pyinline{1} ή \pyinline{2}. 

% src/nim.5.py: επιλογή παίκτη υπολογιστή
\pysrc[firstline=52,lastline=53]{src/nim.5.py}{}{}

Θυμηθείτε ότι η μεταβλητή \pyinline{player} εναλλάσσεται σε κάθε γύρο μεταξύ των τιμών \pyinline{1} και \pyinline{2}, υποδεικνύοντας ποιος παίκτης έχει σειρά να παίξει στον επόμενο γύρο. Συκρίνοντας λοιπόν την \pyinline{player} με την \pyinline{computer} %(της οποίας η τιμή δεν μεταβάλλεται)
ελέγχουμε ουσιαστικά αν ο επόμενος παίκτης είναι ο άνθρωπος ή το πρόγραμμά μας, ώστε να καλέσουμε σε κάθε περίπτωση την ανάλογη συνάρτηση που θα μας επιστρέψει το πλήθος των σπίρτων που θα αφαιρεθούν.

% src/nim.5.py: επιλογή κίνησης, ανάλογα με τον παίκτη
\marginnote{\center\includegraphics[scale=\scaling]{illustrations/player-computer.pdf}
\captionof{figure}{Επιλογή κίνησης, ανάλογα με τον παίκτη: (α) αν η \pyinline{computer} έχει ίδια τιμή με την \pyinline{player}, τότε είναι σειρά του προγράμματος να παίξει, ενώ (β) σε διαφορετική περίπτωση, έχει σειρά να παίξει ο χρήστης.}}
\pysrc[firstline=58,lastline=63]{src/nim.5.py}{}{continued}
\pysrc[firstline=64,lastline=65]{src/nim.5.py}{plain}{}

Χρειάζεται να φροντίσουμε μια ακόμα σημαντική λεπτομέρεια. Μέχρι στιγμής, στο τέλος του παιχνιδιού ανακοινώνεται ο \emph{αριθμός} του παίκτη που κέρδισε. Τώρα που μόνο ο ένας παίκτης είναι άνθρωπος, είναι προτιμότερο να εμφανίζουμε διαφοροποιημένα μηνύματα.

% src/nim.5.py: εμφάνιση αποτελέσματος παιχνιδιού
\pysrc[firstline=72,lastline=72]{src/nim.5.py}{plain}{continued}
\pysrc[firstline=73,lastline=75]{src/nim.5.py}{}{continued}
\pysrc[firstline=76,lastline=76]{src/nim.5.py}{plain}{nim}

%%%%%%%%

\section{Άνθρωπος Εναντίον Μηχανής}

\begin{question}
Όταν το πρόγραμμά μου παίζει τυχαία δεν έχει και μεγάλο ενδιαφέρον. Δεν γίνεται να το κάνουμε λίγο πιο ``έξυπνο'';
\end{question} 

Θα πρέπει πρώτα εμείς να σχεδιάσουμε έναν καλύτερο τρόπο παιχνιδιού και μετά να τον περιγράψουμε με τις κατάλληλες εντολές. Είναι ευκολότερο ν' αρχίσουμε μελετώντας ποιες είναι οι ενδεδειγμένες κινήσεις όταν απομένουν 2, 3 ή 4 σπίρτα: ο παίκτης που έχει σειρά να παίξει μπορεί να αφαιρέσει αντίστοιχα 1, 2 ή 3 σπίρτα και να κερδίσει άμεσα. Αντίθετα, όταν απομένουν 5 σπίρτα η κατάσταση είναι δύσκολη: όσα σπίρτα και ν' αφαιρέσει ο παίκτης που έχει σειρά να παίξει, η έκβαση είναι στα χέρια του αντιπάλου. 

Ανάλογες δυσάρεστες καταστάσεις, που θα ονομάσουμε «ανεπιθύμητες νησίδες», αντιμετωπίζει ο παίκτης που έχει σειρά να παίξει όταν απομένουν 9, 13, 17, κ.ο.κ σπίρτα. Όσα σπίρτα κι αν αφαιρέσει, ο αντίπαλος μπορεί να τον στείλει στην επόμενη νησίδα και να τον αναγκάσει να χάσει (σχήμα~\ref{fig:strategy}).

\clearpage
\marginnote[12pt]{\center\includegraphics[scale=\scaling]{illustrations/strategy.pdf}
\captionof{figure}{\label{fig:strategy}Οι κύκλοι αντιστοιχούν στις διαφορετικές καταστάσεις του παιχνιδιού: ο αριθμός κάθε κύκλου είναι τα σπίρτα που απομένουν σε κάθε κατάσταση.
Οι καταστάσεις 1, 5, 9, ... είναι οι «ανεπιθύμητες νησίδες»: όταν ένας παίκτης βρίσκεται σε μια από αυτές τότε ο αντίπαλός του μπορεί πάντα να τον οδηγήσει στην επόμενη νησίδα και, τελικά, στην ήττα.}}%

% [modified] προσθήκη πινάκων και συνοδευτικών επεξηγήσεων

% Ας φτιάξουμε λοιπόν έναν πίνακα για να καταγράψουμε το ενδεδειγμένο πλήθος των σπίρτων που θα πρέπει ν' αφαιρεθούν από έναν παίκτη, έτσι ώστε ο αντίπαλός του να οδηγηθεί σε μια ανεπιθύμητη νησίδα. Αν ο παίκτης βρίσκεται ήδη σε μια τέτοια νησίδα, τότε το πλήθος των σπίρτων που θα αφαιρέσει δεν έχει σημασία. 

\begin{center}
\begin{tabular}{ccc}
\parbox[c][0pt][c]{78pt}{\center\small σπίρτα \pyinline{m}\\που απομένουν\\στον παίκτη} & %
\parbox[c][0pt][c]{78pt}{\center\small σπίρτα που πρέπει\\ν' αφαιρέσει\\ο παίκτης} & %
\parbox[c][0pt][c]{78pt}{\center\small σπίρτα \\που θ' απομείνουν\\στον αντίπαλο} \\\addlinespace[4\parskip]
\pyinline{2} & \pyinline{1} & \pyinline{1} \\\addlinespace[\parskip]
\pyinline{3} & \pyinline{2} & \pyinline{1}  \\\addlinespace[\parskip]
\pyinline{4} & \pyinline{3} & \pyinline{1}  \\\addlinespace[\parskip]
{\textcolor{red}{\textbf{\pyinline{5}}}} & αδιάφορο  \\\addlinespace[\parskip]
\pyinline{6} & \pyinline{1} & \pyinline{5}  \\\addlinespace[\parskip]
\pyinline{7} & \pyinline{2} & \pyinline{5}  \\\addlinespace[\parskip]
\pyinline{8} & \pyinline{3} & \pyinline{5}  \\\addlinespace[\parskip]
{\textcolor{red}{\textbf{\pyinline{9}}}} & αδιάφορο \\\addlinespace[\parskip]
\pyinline{10} & \pyinline{1} & \pyinline{9}  \\\addlinespace[\parskip]
... \\\addlinespace[\parskip]
\end{tabular}
\end{center}

\vspace{-12pt}%
Στον πίνακα υπάρχει εμφανής \emph{περιοδικότητα}: οι ενδεδειγμένες κινήσεις επαναλαμβάνονται \emph{ανά τέσσερα σπίρτα}. Αυτό είναι ένδειξη ότι για να υπολογίσουμε το πλήθος των σπίρτων που θα πρέπει ν' αφαιρεθούν, θα πρέπει να χρησιμοποιήσουμε το υπόλοιπο της ακέραιας διαίρεσης του πλήθους των σπίρτων \pyinline{m} με το \pyinline{4}. Η δεύτερη στήλη του πίνακα που ακολουθεί περιέχει την τιμή της έκφρασης \pyinline{m % 4}. 

\vspace{-12pt}%
\begin{center}
\begin{tabular}{cccc}
\parbox[c][0pt][c]{78pt}{\center\small σπίρτα \pyinline{m}\\που απομένουν\\στον παίκτη} & %
\parbox[c][0pt][c]{54pt}{\center\small τιμή έκφρασης\\\pyinline{m} \% \pyinline{4}} & %
\parbox[c][0pt][c]{54pt}{\center\small τιμή έκφρασης\\\pyinline{(m - 1)} \% \pyinline{4}} & %
\parbox[c][0pt][c]{78pt}{\center\small σπίρτα που πρέπει\\ν' αφαιρέσει\\ο παίκτης} \\\addlinespace[4\parskip]
\pyinline{2} & \pyinline{2} & \pyinline{1} & \pyinline{1} \\\addlinespace[\parskip]
\pyinline{3} & \pyinline{3} & \pyinline{2} & \pyinline{2} \\\addlinespace[\parskip]
\pyinline{4} & \pyinline{0} & \pyinline{3} & \pyinline{3}  \\\addlinespace[\parskip]
{\textcolor{red}{\textbf{\pyinline{5}}}} & \pyinline{1} & \pyinline{0} & αδιάφορο  \\\addlinespace[\parskip]
\pyinline{6} & \pyinline{2}  & \pyinline{1} & \pyinline{1}  \\\addlinespace[\parskip]
\pyinline{7} & \pyinline{3}  & \pyinline{2} & \pyinline{2}  \\\addlinespace[\parskip]
\pyinline{8} & \pyinline{0}  & \pyinline{3} & \pyinline{3}  \\\addlinespace[\parskip]
{\textcolor{red}{\textbf{\pyinline{9}}}} & \pyinline{1} & \pyinline{0} & αδιάφορο \\\addlinespace[\parskip]
\pyinline{10} & \pyinline{2} & \pyinline{1} & \pyinline{1}  \\\addlinespace[\parskip]
... \\\addlinespace[\parskip]
\end{tabular}
\end{center}

\vspace{-12pt}%
Το υποπρόγραμμα που ακολουθεί δέχεται σαν παράμετρο το πλήθος \pyinline{m} των σπίρτων που απομένουν (πρώτη στήλη), υπολογίζει την τιμή της έκφρασης \pyinline{m % 4} (δεύτερη στήλη) και, με βάση την αντιστοιχία του πίνακα, επιστρέφει το πλήθος των σπίρτων που χρειάζεται ν' αφαιρεθούν ώστε ο αντίπαλος να οδηγηθεί σε μια ανεπιθύμητη νησίδα (τέταρτη στήλη). Αν το πλήθος~\pyinline{m} αντιστοιχεί σε ανεπιθύμητη νησίδα, το υποπρόγραμμα επιστρέφει έναν τυχαίο αριθμό σπίρτων.
% καλώντας την \pyinline{randomMatches()}. 

\begin{pycode}
def computeMatches(m):
    """ Επιλέγει κι επιστρέφει το βέλτιστο
    πλήθος σπίρτων που θα πρέπει να αφαιρεθούν. 
    Αν δεν υπάρχει, επιστρέφει μια τυχαία τιμή.
    m: πλήθος σπίρτων που απομένουν
    """
    # υπολογισμός υπολοίπου
    mod = m % 4
    if mod == 0:
        return 3
    elif mod == 1:
        # ανεπιθύμητη νησίδα: τυχαία κίνηση
        return randomMatches(m)
    elif mod == 2:
        return 1  
    else:
        return 2
\end{pycode}

Θα μπορούσαμε να υπολογίσουμε πιο άμεσα το πλήθος των σπίρτων που χρειάζεται ν' αφαιρεθούν σε κάθε περίπτωση; Ουσιαστικά, θα θέλαμε να υπολογίσουμε ποια είναι η \emph{απόσταση} από την κοντινότερη ανεπιθύμητη νησίδα ή, με άλλα λόγια, πόσα σπίρτα \emph{περισσεύουν} σε σχέση με την πλησιέστερη νησίδα, ώστε να τα αφαιρέσουμε. 

Μελετώντας τον προηγούμενο πίνακα, προκύπτει ότι η έκφραση που δίνει αυτή την απόσταση είναι η \pyinline{(m - 1) % 4},
της οποίας η τιμή δίνεται στην τρίτη στήλη. Παρατηρήστε πως οι τιμές στην τρίτη και την τέταρτη στήλη ουσιαστικά ταυτίζονται. Οδηγούμαστε έτσι σε μια κομψότερη εναλλακτική υλοποίηση του υποπρογράμματος:

% src/nim.6.py: ορισμός συνάρτησης computeMatches(m)
\pysrc[firstline=48,lastline=60]{src/nim.6.py}{}{}

Στο κύριο πρόγραμμα, η κλήση της \pyinline{randomMatches()} για την επιλογή ενός τυχαίου πλήθους σπίρτων πρέπει τώρα να αντικατασταθεί από την κλήση της \pyinline{computeMatches()}. %Είναι βέβαια ενδιαφέρον ότι η τελευταία ίσως χρειαστεί και η ίδια να καλέσει την \pyinline{randomMatches()}, εφόσον το πρόγραμμά μας βρεθεί σε ανεπιθύμητη νησίδα.

% src/nim.6.py: σπίρτα που θα πάρει ο υπολογιστής (κλήση της computeMatches)
\pysrc[firstline=73,lastline=73]{src/nim.6.py}{plain}{continued}
\pysrc[firstline=74,lastline=74]{src/nim.6.py}{}{continued}
\pysrc[firstline=75,lastline=75]{src/nim.6.py}{plain}{nim}

%%%%%%%%

\vspace{-12pt}
\section{Πλήρες Τελικό Πρόγραμμα}

% [comment] αυτή η αποσπασματική παράθεση γίνεται για τη σελιδοποίηση
\pysrc[firstline=1,lastline=1]{src/nim.final.py}{}{continued}
\pysrc[firstline=2,firstnumber=2,lastline=11]{src/nim.final.py}{}{continued}
\pysrc[firstline=12,firstnumber=11,lastline=22]{src/nim.final.py}{}{continued}
\pysrc[firstline=23,firstnumber=21,lastline=44]{src/nim.final.py}{}{continued}
\pysrc[firstline=46,firstnumber=42,lastline=51]{src/nim.final.py}{}{continued}
\pysrc[firstline=52,firstnumber=48,lastline=65]{src/nim.final.py}{}{continued}
\pysrc[firstline=66,firstnumber=61,lastline=74]{src/nim.final.py}{}{continued}
\pysrc[firstline=75,firstnumber=69,lastline=91]{src/nim.final.py}{}{continued}
\pysrc[firstline=93,firstnumber=85]{src/nim.final.py}{}{nim}
%\tobecontinued

%%%%%%%%

\section{Τροποποιήσεις -- Επεκτάσεις}

% [modified] added
\begin{exercise}
Το τελικό πρόγραμμα συμπεριφέρεται λίγο ανόητα όταν απομείνει μόνο ένα σπίρτο: ενώ είναι βέβαιο ότι ο παίκτης που έχει σειρά να παίξει έχει χάσει, τον ρωτάει κανονικότατα πόσα σπίρτα θέλει να αφαιρέσει. Μάλιστα, αν πληκτρολογήσει έναν μη-έγκυρο αριθμό, του απαντά με το μήνυμα \terminline{Πάρε από 1 μέχρι και 1 σπίρτα}. 

Να τροποποιήσετε το πρόγραμμα έτσι ώστε το παιχνίδι να σταματά αυτόματα όταν απομένει μόνο ένα σπίρτο, χωρίς να ρωτάει τον παίκτη πόσα σπίρτα θέλει να αφαιρέσει. 

\begin{note}
Για να σταματάει το παιχνίδι όταν απομένει μόνο ένα σπίρτο, αρκεί μια μικρή τροποποίηση στη συνθήκη της \pyinline{while}. Όμως το σημείο που χρειάζεται προσοχή είναι η ανακοίνωση του νικητή.
\end{note}
\solutionlink{nim}{subtraction-oneleft.py}
\end{exercise}

\begin{exercise}
Να υλοποιήσετε την συνάρτηση \pyinline{readMatches()} χρησιμοποιώντας μόνο την \pyinline{break} για να διακόψετε τον επαναληπτικό έλεγχο. Η συνθήκη συνέχειας της \pyinline{while} θα πρέπει να είναι η \pyinline{True}.
\solutionlink{nim}{subtraction-break.py}
\end{exercise}

\begin{exercise}
Να υλοποιήσετε μια συνάρτηση η οποία ανακοινώνει το νικητή του παιχνιδιού, αφού δεχτεί τις κατάλληλες παραμέτρους. Χρησιμοποιήστε την συνάρτησή σας καλώντας την από το κύριο πρόγραμμα.
\solutionlink{nim}{subtraction-announce.py}
\end{exercise}

\begin{exercise}
Να τροποποιήσετε το παιχνίδι έτσι ώστε ο παίκτης που παίρνει τα τελευταία σπίρτα να κερδίζει. Ποιά είναι τώρα η βέλτιση στρατηγική για έναν παίκτη; Τροποποιήστε ανάλογα την συνάρτηση \pyinline{computeMatches()} που υπολογίζει τον αριθμό σπίρτων που πρέπει ν' αφαιρεθούν σε μια δεδομένη κατάσταση.
\solutionlink{nim}{subtraction-nonmisere.py}
\end{exercise}

%\begin{exercise}
%Να επεκτείνετε το πρόγραμμα έτσι ώστε να ζητούνται τα ονόματα των δύο παικτών. Τώρα όλα τα μηνύματα που απευθύνονται στους παίκτες θα πρέπει να χρησιμοποιούν τα ονόματα αυτά, αντί του αριθμού κάθε παίκτη.
%\end{exercise}

% [modified] added
\begin{exercise}
Η συνάρτηση \pyinline{next} δέχεται σαν παράμετρο τον αριθμό \pyinline{p} ενός παίκτη και επιστρέφει τον αριθμό του παίκτη που παίζει μετά από τον \pyinline{p}. Θεωρείται όμως δεδομένο ότι στο παιχνίδι συμμετέχουν δύο παίκτες. 

Να επεκτείνετε τη συνάρτηση \pyinline{next}, έτσι ώστε να δέχεται σαν επιπρόσθετη παράμετρο το πλήθος \pyinline{q} των παικτών που συμμετέχουν στο παιχνίδι. Έτσι, η ίδια συνάρτηση θα μπορεί να χρησιμοποιηθεί σε διαφορετικά παιχνίδια.

\begin{note}
Η τιμή της παραμέτρου \pyinline{q} μπορεί να είναι οποιοσδήποτε ακέραιος. Δε χρειάζεται να υποθέσετε ότι υπάρχει κάποιο όριο.
\end{note}
\solutionlink{nim}{next-generalized.py}
\end{exercise}

\section{Ασκήσεις}

% [review] josep

\begin{exercise}
Στο παιχνίδι «Τα Ζυγά Κερδίζουν» οι δύο παίκτες ξεκινούν με μια σειρά από αντικείμενα. Το αρχικό πλήθος των αντικειμένων πρέπει να είναι περιττός αριθμός. Κάθε ένας από τους δύο παίκτες αφαιρεί με τη σειρά του από ένα μέχρι και τέσσερα αντικείμενα, μέχρι ν' αφαιρεθούν όλα. Νικητής είναι ο παίκτης που στο τέλος του παιχνιδιού απομένει με άρτιο (ζυγό) πλήθος αντικειμένων. Να αναπτύξετε ένα πρόγραμμα που θα διαβάζει σε κάθε γύρο τον αριθμό των σπίρτων που αφαιρεί ο παίκτης που έχει σειρά και στο τέλος ανακοινώνει το νικητή.
\solutionlink{nim}{evenwins.py}
\end{exercise}

\begin{exercise}
Στο παιχνίδι «Τα Ζυγά Κερδίζουν» υπάρχουν επίσης ανεπιθύμητες νησίδες, δηλαδή καταστάσεις από τις οποίες ένας παίκτης δεν μπορεί ν' αποφύγει την ήττα, εφόσον ο αντίπαλός του παίξει σωστά. Αν ένας παίκτης δεν βρίσκεται σε ανεπιθύμητη νησίδα τότε μπορεί να οδηγήσει τον αντίπαλό του σε μία και να κερδίσει. Προσπαθήστε να καταγράψετε τις πιθανές καταστάσεις του παιχνιδιού όταν απομένουν λίγα σπίρτα (π.χ. από 1 μέχρι και 6) και ποια είναι η καλύτερη κίνηση σε κάθε μία απ' αυτές. Το εγχείρημα είναι δυσκολότερο απ' ότι στο Παιχνίδι της Αφαίρεσης γιατί εδώ η καλύτερη κίνηση δεν εξαρτάται μόνο από το πλήθος των σπίρτων που απομένουν. Πρέπει να λάβετε υπόψη αν ο καθένας από τους δύο παίκτες έχει συγκεντρώσει άρτιο ή περιττό πλήθος σπίρτων. Τελικός σας σκοπός είναι να τροποποιήσετε το πρόγραμμα της προηγούμενης άσκησης έτσι ώστε να παίζει με αντίπαλο το χρήστη.
\solutionlink{nim}{evenwins-auto.py}
\end{exercise}

\begin{exercise}
Να επεκτείνετε το παιχνίδι Ανάμεσα ή Acey Ducey (κεφ. 2), έτσι ώστε να παίζεται επαναληπτικά. Το πρόγραμμά σας θα πρέπει αρχικά να ρωτάει τον παίκτη το συνολικό ποσό με το οποίο επιθυμεί να ξεκινήσει το παιχνίδι. Με το ίδιο ακριβώς ποσό θα ξεκινήσει και η «μάνα». Σε κάθε γύρο, όταν ο παίκτης ερωτάται για το ποσό που θα στοιχηματίσει, το πρόγραμμά σας θα πρέπει να ελέγχει ότι το ποσό αυτό είναι θετικό και δεν ξεπερνά το συνολικό ποσό που διαθέτει \emph{εκείνη την στιγμή} ο παίκτης, διαφορετικά θα πρέπει να επαναλαμβάνει την ερώτηση μέχρι το στοίχημα να είναι έγκυρο. Το παιχνίδι θα τελειώνει όταν εξαντληθούν τα χρήματα του παίκτη ή της «μάνας». 
%\begin{note}
%Αν η «μάνα» δεν έχει επαρκή χρήματα για να πληρώσει τον παίκτη τότε του δίνει όσα έχει (και φυσικά τερματίζεται το παιχνίδι).
%\end{note} 
\solutionlink{nim}{aceyducey-iterative.py}
% [suggested] Να γραφτεί και μια εναλλακτική λύση με χρήση υποπρογραμμάτων. Να δοθούν σε ένα note στην εκφώνηση προτάσεις σχετικά με τα υποπρογράμματα που θα ήταν βολικό να χρησιμοποιηθούν.
\end{exercise}

% [modified] added
\begin{exercise}
Να μετατρέψετε το «Μάντεψε τον Αριθμό» σε παιχνίδι δύο παικτών, ανάμεσα στο χρήστη και το πρόγραμμά σας. Τόσο ο χρήστης, όσο και το πρόγραμμα, θα επιλέγουν στην αρχή του παιχνιδιού έναν μυστικό αριθμό και θα προσπαθούν να μαντέψουν ο ένας τον αριθμό του άλλου, διαθέτοντας ένα συγκεκριμένο πλήθος προσπαθειών. Σε κάθε γύρο του παιχνιδιού, κάθε ένας από τους δύο παίκτες θα επιλέγει έναν αριθμό και ο άλλος παίκτης θα τον ενημερώνει αν ο μυστικός αριθμός του είναι ίσος, μικρότερος ή μεγαλύτερος από αυτόν. 

Στο παράδειγμα που ακολουθεί δίνεται η αλληλεπίδραση μεταξύ χρήστη και προγράμματος για έναν γύρο του παιχνιδιού. Πρώτα επιλέγει αριθμό ο παίκτης, προσπαθώντας να μαντέψει τον μυστικό αριθμό του προγράμματος, και στη συνέχεια το ίδιο το πρόγραμμα, προσπαθώντας να μαντέψει τον μυστικό αριθμό του παίκτη.

\begin{pyterm}
Σου απομένουν 3 προσπάθειες.
Μάντεψε τον αριθμό μου: |\textbf{25}|
Λάθος. Είναι μεγαλύτερος.

Μου απομένουν 3 προσπάθειες.
Επιλέγω τον αριθμό 24. Ο αριθμός σου είναι: 
1. Μικρότερος 2. Μεγαλύτερος 3. Ίσος; |\textbf{1}|
\end{pyterm}

Το ποιος από τους δύο παίκτες θα ξεκινήσει πρώτος θα επιλέγεται τυχαία. Αν ο παίκτης που παίξει πρώτος βρει τον μυστικό αριθμό, το πρόγραμμα δεν θα πρέπει να διακόπτεται άμεσα, αλλά να ολοκληρώνει το γύρο, δίνοντας ουσιαστικά και στο δεύτερο παίκτη το ίδιο πλήθος προσπαθειών.
\solutionlink{nim}{guess-twoplayer.py}
\end{exercise}

\begin{exercise}
Τα παιδιά στο δημοτικό μαθαίνουν πρόσθεση μέσα από ασκήσεις αυξανόμενης δυσκολίας. Αρχικά, τους ζητείται να προσθέσουν δύο μονοψήφιους αριθμούς, το άθροισμα των οποίων δεν ξεπερνά το 9. 

\begin{note}
Παράδειγμα: 4 + 2 = \_
\end{note}

%Στη συνέχεια, μαθαίνουν τα «ζευγαράκια του 10», τους δίνεται δηλαδή ένας μονοψήφιος αριθμός και τους ζητείται ένας δεύτερος έτσι ώστε το άθροισμά τους να ισούται με 10. 

%{\small\upshape Παράδειγμα: 4 + \_ = 10}

Μετά τους ζητείται να προσθέσουν δύο μονοψήφιους αριθμούς, το άθροισμα των οποίων ξεπερνά το 10. 

\begin{note}
Παράδειγμα: 4 + 8 = \_
\end{note}

Το επόμενο στάδιο είναι η πρόσθεση ενός διψήφιου κι ενός μονοψήφιου, το άθροισμα των οποίων πιθανώς να ξεπερνά τη δεκάδα του διψήφιου, αλλά όχι το 99.

\begin{note}
Παράδειγμα: 42 + 9 = \_
\end{note}

Μπορείτε να φτιάξετε ένα πρόγραμμα εξάσκησης για τα παιδιά του Δημοτικού. Αρχικά, το πρόγραμμά σας θα πρέπει να ρωτά ποιο είναι το επιθυμητό επίπεδο ασκήσεων και να παράγει πέντε από αυτές. Εδώ έχουμε περιγράψει τα τρία πρώτα επίπεδα, αλλά εσείς μπορείτε να φτιάξετε κι άλλα ή ακόμα και να περάσετε σε άλλες πράξεις εκτός από την πρόσθεση. Μην σας απασχολεί αν καμιά φορά τυχαίνει να εμφανίζονται διπλότυπες ασκήσεις, αυτό προς το παρόν είναι δύσκολο να το αποφύγετε. Αν το παιδί κάνει λάθος σε κάποια από τις ερωτήσεις το πρόγραμμα μπορεί να του εμφανίζει άμεσα την σωστή απάντηση ή να του δίνει κι άλλες ευκαιρίες. Ακόμα καλύτερο θα ήταν αν το πρόγραμμά σας εξηγούσε πως προκύπτει η σωστή απάντηση ή έδινε μια υπόδειξη πριν το παιδί ξαναπροσπαθήσει.

\begin{note}
Παράδειγμα: 42 + 9 = \_. Το παιδί πληκτρολογεί 52 και το πρόγραμμα του ζητά να ξαναπροσπαθήσει, υποδεικνύοντας ότι 42 + 9 = 42 + 8 + 1 = \_
\end{note}
\solutionlink{nim}{mathgame.py}
% [suggested] Να περιγραφούν υποπρογράμματα τα οποία θα μπορούσαν να φανούν χρήσιμα (με βάση την υπάρχουσα λύση)
\end{exercise}

%%%%%%%%

\section*{}
\vspace{4\parskip}
\hrulefill

\begin{theory}{Υποπρογράμματα}
Είδαμε ήδη ότι για να αντιμετωπίσουμε την αυξανόμενη έκταση και πολυπλοκότητα των προγραμμάτων χρησιμοποιούμε \emph{υποπρογράμματα}, μικρά προγράμματα που τα συνδυάζουμε για να φτιάξουμε συνθετότερα, κατά τον ίδιο τρόπο με τον οποίο κατασκευάζουμε μια περίπλοκη μηχανή από απλούστερα εξαρτήματα, κάθε ένα από τα οποία εξυπηρετεί μια συγκεκριμένη λειτουργία. Ο κατακερματισμός των προγραμμάτων σε απλούστερα μας βοηθά να σκεφτόμαστε τμηματικά και να αναλύουμε το γενικότερο πρόβλημα σε επιμέρους απλούστερα προβλήματα. Τα υποπρογράμματα θα πρέπει να θεωρούνται όσο το δυνατόν ανεξάρτητα από το πλαίσιο μέσα στο οποίο χρησιμοποιούνται. Αντιμετωπίζουμε κάθε υποπρόγραμμα ως ένα κομμάτι κώδικα που λύνει ένα μικρό πρόβλημα με γενικό τρόπο και έτσι είναι \emph{επαναχρησιμοποιήσιμο}. Μπορεί να κληθεί από διαφορετικά σημεία και για διαφορετικούς λόγους μέσα σ' ένα πρόγραμμα, αλλά και να χρησιμοποιηθεί και σε άλλα προγράμματα στο μέλλον. 
%Λόγω ανεξαρτησίας και μικρού μεγέθους, είναι επίσης ευκολότερο να \emph{ελεγχθεί} η ορθότητα της λειτουργίας ενός υποπρογράμματος
Οι εσωτερικές λεπτομέρειες της λειτουργίας κάθε υποπρογράμματος είναι κρυμμένες για εκείνους που το χρησιμοποιούν. Όποιος θέλει να χρησιμοποιήσει ένα υποπρόγραμμα δεν χρειάζεται να καταλαβαίνει πως λειτουργεί και με ποια μέθοδο υπολογίζεται το αποτέλεσμα. Ο Al Sweigart, στο εξαιρετικό του βιβλίο Invent Your Own Computer Games with Python, γράφει: «Το ωραίο με τις συναρτήσεις είναι ότι χρειάζεται μόνο να ξέρουμε τι κάνουν, αλλά όχι πως το κάνουν.» Αντίστοιχα κρυμμένες είναι και τυχόν αλλαγές στα υποπρογράμματά μας. Αν το υποπρόγραμμα τροποποιηθεί (επειδή βρήκαμε κάποιο λάθος, κάποιο τρόπο να λειτουργεί καλύτερα ή ακόμα και κάποια καλύτερη μέθοδο) οι αλλαγές θ' αφορούν μόνο το εσωτερικό του υποπρογράμματος, ενώ το υπόλοιπο πρόγραμμα θα παραμείνει αμετάβλητο.

\end{theory}

\begin{theory}{Υπολογιστές και Παιχνίδια}
Στις αρχές της δεκαετίας του 1950 άρχισε να εξετάζεται συστηματικά η δυνατότητα χρήσης των ηλεκτρονικών υπολογιστών, που ήταν ακόμα στα πρώτα τους βήματα, για το παίξιμο παιχνιδιών.
Ο Claude Shannon %, που άφησε την σφραγίδα του στο πεδίο των τηλεπικοινωνιών γράφοντας το A Mathematical Theory of Communication, 
δημοσίευσε το 1950 μια εργασία με τίτλο Programming a Computer for Playing Chess. Εκεί περιέγραψε ένα σύνολο τεχνικών που θα επέτρεπαν σ' έναν υπολογιστή να απαριθμεί συστηματικά τις πιθανές κινήσεις ενός παιχνιδιού, να τις αξιολογεί και να παίρνει αποφάσεις σχετικά με τις κινήσεις που θα έπρεπε να επιλέξει. Μια παρόμοια εργασία, με τίτλο Digital Computers Applied to Games, δημοσίευσε το 1953 και ο Alan Turing. Το 1997, ένας υπολογιστής της IBM με το όνομα Deep Blue, κέρδισε τον παγκόσμιο πρωταθλητή Gary Kasparov. Σήμερα, ένας οικιακός υπολογιστής έχει την υπολογιστική ισχύ του Deep Blue και λέγεται ότι ο τρόπος παιχνιδιού των πρωταθλητών έχει αλλάξει σημαντικά από τότε που ισχυρά σκακιστικά προγράμματα χρησιμοποιούνται για προπόνηση και ανάλυση θέσεων. Αν και το σκάκι θεωρείται ο βασιλιάς των παιχνιδιών και συνδέεται παραδοσιακά με τη νοημοσύνη, δεν είναι φυσικά το μόνο παιχνίδι που έχει απασχολήσει τους ερευνητές. Ένα ιστορικό πρόγραμμα που έπαιζε ντάμα αναπτύχθηκε από τον Arthur Samuel τη δεκαετία του 1950. To 1989 ξεκίνησε η ανάπτυξη του προγράμματος Chinook, το οποίο έπαιξε με τον παγκόσμιο πρωταθλητή το 1992. Το 2007, μετά από σχεδόν 20 χρόνια υπολογισμών, έγινε ανίκητο ``λύνοντας'' το παιχνίδι της ντάμας, έχοντας απαριθμήσει όλες τις πιθανές θέσεις του παιχνιδιού (περίπου 500 δισεκατομμύρια δισεκατομμύρια) και γνωρίζοντας τη βέλτιστη κίνηση για κάθε μια από αυτές. Το ΝΙΜ είναι πολύ απλούστερο παιχνίδι. Οι  (αποδεδειγμένα) καλύτερες δυνατές κινήσεις είναι γνωστές και υπολογίζονται εύκολα. Αυτός είναι ο λόγος που το ΝΙΜ ήταν πιθανότατα το πρώτο παιχνίδι που αυτοματοποιήθηκε.
\end{theory}

\begin{theory}{Υπολογιστές και Νοημοσύνη}
Είναι αναπόφευκτο να αναρωτηθεί κανείς πόσο ``έξυπνο'' είναι ένα σκακιστικό πρόγραμμα που κερδίζει παγκόσμιους πρωταθλητές. Το ερώτημα αν οι υπολογιστές έχουν τη δυνατότητα να επιδεικνύουν ``νοημοσύνη'' προέκυψε πολύ νωρίς και είναι τόσο δύσκολο ν' απαντηθεί όσο να ορίσει κανείς τι είναι η ευφυία και η νοημοσύνη. Η Ada Lovelace, κόρη του λόρδου Βύρωνα και στενή συνεργάτης του Charles Babbage είχε γράψει το 1842 ότι οι υπολογιστικές μηχανές μπορούν να κάνουν μόνο αυτά που εμείς μπορούμε να τις προγραμματίσουμε να κάνουν. Ο χαρισματικός Alan Turing έγραψε το 1950 ένα ιστορικό άρθρο με τίτλο Computing Machinery and Intelligence (Υπολογιστικές Μηχανές και Νοημοσύνη), το οποίο ξεκινούσε με την πρόταση ``Προτείνω να εξετάσουμε την ερώτηση: Μπορούν οι μηχανές να σκεφτούν;'' Πολύ συνοπτικά, ο Turing ισχυρίστηκε ότι η απάντηση μπορεί να είναι καταφατική όταν μια μηχανή μπορεί να συνομιλήσει μ' έναν άνθρωπο και να τον πείσει ότι δεν είναι μηχανή. Είναι σημαντικό ότι ο Turing εστίασε στον τρόπο με τον οποίο οι εξωτερικοί παρατηρητές αντιλαμβάνονται την συμπεριφορά μιας μηχανής ως εφυή, χωρίς να έχει σημασία με ποιες εσωτερικές διεργασίες επιτυγχάνεται αυτό. Οι απόψεις του Turing δεν είναι καθολικά αποδεκτές, το αντίθετο μάλιστα. Είναι πάντως σημαντικό να θυμάστε ότι οι υπολογιστές είναι σχεδιασμένοι για να κάνουν μόνο \emph{ένα} πράγμα: να \emph{εκτελούν προγράμματα}, τα οποία επεξεργάζονται τις τιμές που δέχονται στην είσοδό τους και επιστρέφουν αποτελέσματα στην έξοδό τους. Με την πάροδο του χρόνου, τα εξαρτήματά των υπολογιστών εξελίσσονται, οι ταχύτητες με τις οποίες λειτουργούν αυξάνονται και οι συσκευές εισόδου-εξόδου που διαθέτουν επιτρέπουν πλέον μια πολύ φυσική αλληλεπίδραση με τους χρήστες. Όμως το γεγονός παραμένει πως για κάθε τι που κάνουν, υπάρχει ένα πρόγραμμα, γραμμένο από ανθρώπους, που τους υπαγορεύει με απόλυτη ακρίβεια \emph{πως} να το κάνουν. Υπάρχουν βέβαια και προγράμματα που μαθαίνουν και προσαρμόζουν την συμπεριφορά τους. Υπό αυτή την έννοια, η συμπεριφορά τους δεν είναι προγραμματισμένη, αλλά ο μηχανισμός μέσω του οποίου την τροποποιούν καθώς μαθαίνουν είναι. Έτσι, τα αυτοκίνητα της Google κινούνται χωρίς οδηγό για χιλιάδες μίλια χωρίς ατυχήματα, το ρομπότ της NASA Curiosity πλοηγείται αυτόνομα στην επιφάνεια του Άρη, το σύστημα Watson της IBM κερδίζει σε τηλεπαιχνίδια και βοηθά στη διάγνωση ασθενειών, επειδή ομάδες ανθρώπων καθόρισαν (με πολύ κόπο) πως ακριβώς μπορούν να γίνουν όλα αυτά. 

%Στις αρχές του 19ου αιώνα, ο Charles Babbage σχεδίασε και προσπάθησε να κατασκευάσει έναν \emph{μηχανικό} προγραμματιζόμενο υπολογιστή. Η αρχική σύλληψη της ιδέας είχε μάλλον πεζές ρίζες: ήθελε απλά να αυτοματοποιήσει την κατασκευή λογαριθμικών πινάκων, μια διαδικασία που είναι επίπονη, επαναληπτική και οδηγεί εύκολα σε λάθη, όταν γίνεται χειρωνακτικά. Περίπου εκατό χρόνια αργότερα, ο ENIAC, ένας από τους πρώτους \emph{ηλεκτρονικούς} υπολογιστές χρησιμοποιήθηκε για υπολογισμούς που σχετίζονταν με την ανάπτυξη της υδρογονοβόμβας και την κατασκευή πινάκων για τις βολές του πυροβολικού. Παρόλο που ο ENIAC προωθήθηκε ως ένας ``γιγαντιαίος εγκέφαλος'', οι ηλεκτρονικοί υπολογιστές της εποχής χρησιμοποιούνταν ουσιαστικά για την αυτοματοποίηση αριθμητικών υπολογισμών. Ξεφεύγοντας εντελώς από αυτό το πλαίσιο, ο χαρισματικός Alan Turing έγραψε το 1950 ένα ιστορικό άρθρο με τίτλο Computing Machinery and Intelligence (Υπολογιστικές Μηχανές και Νοημοσύνη), το οποίο ξεκινούσε με την πρόταση ``Προτείνω να εξετάσουμε την ερώτηση: Μπορούν οι μηχανές να σκεφτούν;'' Οι απόψεις που εξέθεσε ο Turing στο άρθρο του διχάζουν ακόμα και σήμερα. Ουσιαστικά ισχυρίστηκε ότι μια μηχανή μπορεί να θεωρηθεί ευφυής όταν μπορεί να συνομιλήσει με έναν άνθρωπο, χωρίς αυτός να μπορεί να διακρίνει αν πρόκειται για άνθρωπο ή μηχανή.

% αναφορά στο έξυπνο χαρτί
\end{theory}

% \begin{theory}{Ανάλυση και Γενίκευση}
% \end{theory}

\hrulefill

%%%%%%%%%

%Καθώς προχωράμε από κεφάλαιο σε κεφάλαιο, τα προβλήματα που θα αντιμετωπίζουμε θα γίνονται ολοένα και πιο σύνθετα και τα προγράμματά μας θα μεγαλώνουν ανάλογα σε έκταση. Για να μπορέσουμε να διαχειριστούμε αυτή την αυξανόμενη πολυπλοκότητα των προβλημάτων και των αντίστοιχων προγραμμάτων θα προσπαθήσουμε από τώρα να προσεγγίζουμε τα σύνθετα προβλήματα ως σύνολα μικρότερων, απλούστερων και (σχετικά) ανεξάρτητων προβλημάτων. Κατ' αναλογία, θα επιχειρήσουμε να συνθέτουμε τα προγράμματά μας από μικρότερα και απλούστερα προγράμματα, που ονομάζονται \emph{υποπρογράμματα}.

\end{document}
