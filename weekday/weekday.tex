\documentclass[a4paper,11pt,oneside]{book}

\input{../share/tuftelike}
\input{../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{4}

\usepackage{graphicx}

%%% DOCUMENT START

\begin{document}

\bonustrue
\chapterwabstract{Η Μέρα της Εβδομάδας}{Στο κεφάλαιο αυτό θ' αναπτύξουμε ένα πρόγραμμα για να υπολογίζουμε σε ποια ημέρα της εβδομάδας αντιστοιχεί μια συγκεκριμένη ημερομηνία. Θα δανειστούμε τη μέθοδο υπολογισμού από τον Gauss. Στην πορεία θα έχουμε την ευκαιρία να εξασκηθούμε σε όλα τα προγραμματιστικά εργαλεία που έχουμε συναντήσει μέχρι τώρα.}{δομή επιλογής, δομή επανάληψης, υποπρογράμματα, πλειάδες}{guessColor}{white}

Η επίλυση ημερολογιακών και αστρονομικών προβλημάτων ήταν ένα από τα πρώτα πεδία εφαρμογής υπολογιστικών μεθόδων. Η μέτρηση του χρόνου και η πρόβλεψη των κινήσεων των ουράνιων σωμάτων ήταν προβλήματα εξαιρετικής σημασίας καθ' όλη την ιστορία της ανθρωπότητας, με πρακτικές εφαρμογές αλλά κι επιπτώσεις πολιτικές, επιστημονικές και φιλοσοφικές. Η ύπαρξη του μηχανισμού των Αντικυθήρων δείχνει από πόσο νωρίς επιδιώχθηκε η αυτοματοποίηση τέτοιου είδους υπολογισμών. 

Το να υπολογίσει κανείς την ημέρα της εβδομάδας για μια συγκεκριμένη ημερομηνία είναι ένα καλά μελετημένο πρόβλημα. Για την επίλυση του προβλήματος υπάρχουν πολλές προσεγγίσεις. Μερικές βασίζονται σε μνημονικούς κανόνες, με αποτέλεσμα ορισμένοι άνθρωποι να είναι σε θέση να λύσουν το πρόβλημα μέσα σε μερικά δευτερόλεπτα, κάνοντας υπολογισμούς μόνο με το μυαλό τους.\marginnote[-110pt]{\includegraphics{images/gauss.jpg}\\Carl Friedrich Gauss (1777-1855)\vspace{3pt}\\Ο ιδιοφυής μαθηματικός που ασχολήθηκε με αναρίθμητα προβλήματα σε πολλά διαφορετικά πεδία.} Εμείς θα χρησιμοποιήσουμε μια μέθοδο του Gauss, η οποία είναι απλούστατη στην υλοποίησή της, αν και ο τρόπος με τον οποίο λειτουργεί δεν είναι προφανής.



%%%%%%%%

\section{Πες Μου Πότε}

Ας ξεκινήσουμε ρωτώντας το χρήστη ποια είναι η ημερομηνία για την οποία θα ήθελε να μάθει την αντίστοιχη ημέρα της εβδομάδας.

%%\marginnote[18pt]{Η παράμετρος \pyinline{end} της \pyinline{print()} καθορίζει τι θα εμφανίζεται μετά από ένα μήνυμα. Η προκαθορισμένη τιμή της \pyinline{end} είναι η αλλαγή γραμμής. Εδώ δεν θέλουμε να αλλάζει η γραμμή, γι' αυτό ορίζουμε την \pyinline{end} να είναι κενή.}
%%\marginnote{Η συνάρτηση \pyinline{input()} επιστρέφει πάντα το \emph{κείμενο} που πληκτρολόγησε ο χρήστης. Εδώ είναι απαραίτητη η μετατροπή του κειμένου σε ακέραιο αριθμό, κι αυτό επιτυγχάνεται με τη χρήση της \pyinline{int()}.}
\pyfile[firstline=1,lastline=7]{src/weekday.1.py}

Εναλλακτικά:

%%\marginnote[18pt]{Η εμφάνιση ενός μηνύματος πριν την ανάγνωση τιμών είναι τόσο συνηθισμένη που η \pyinline{input} μπορεί να δεχθεί ως παράμετρο το μήνυμα, την \emph{προτροπή} που πρέπει να εμφανιστεί.}%
\begin{pycode}
# είσοδος ημερομηνίας από το χρήστη
year = int(input("Έτος: "))
month = int(input("Mήνας: "))
day = int(input("Ημέρα: "))
\end{pycode}

%%%%%%%%

\section{Τί Μέρα Έχουμε Σήμερα;}

\begin{question}
Και τώρα που έχουμε την ημερομηνία πώς θα υπολογίσουμε το ζητούμενο; Ποιά είναι η μέθοδος του Gauss;
\end{question}

Οι γραμμές που ακολουθούν είναι μια υλοποίηση της μεθόδου του Gauss. Πρόκειται για εντολές που υπολογίζουν την τιμή ορισμένων αριθμητικών παραστάσεων, για να μας δώσουν τελικά το αποτέλεσμα που χρειαζόμαστε: έναν ακέραιο από το 0 μέχρι και το 6, που αντιστοιχεί στις ημέρες από την Κυριακή μέχρι και το Σάββατο. Ο τρόπος που λειτουργεί η μέθοδος δεν είναι προφανής, αλλά εδώ μας ενδιαφέρει να τη χρησιμοποιήσουμε, όχι να την αναλύσουμε.
%και αν σας ενδιαφέρει να την καταλάβετε, σε γενικές γραμμές, θα χρειαστεί να διαβάσετε μια σύντομη εξήγηση στο τέλος του κεφαλαίου. Πάντως δεν είναι αυτός ο σκοπός μας. 

\pyfile[firstline=8,lastline=18]{src/weekday.1.py}

Μπορείτε να ελέγξετε αν οι εντολές λειτουργούν σωστά κάνοντας μια δοκιμή με την σημερινή ημερομηνία. Δεν θα πρέπει βέβαια να παραλείψουμε την εμφάνιση του αποτελέσματος στην οθόνη.

\pyfilesrc[firstline=19,lastline=20]{src/weekday.1.py}

%%%%%%%%

\section{Κλεισμένη στο Κουτάκι}

\begin{question}
Αυτή η μέθοδος είναι εντυπωσιακή: υπολογίζει το αποτέλεσμα με λίγες πράξεις, αν και το πρόβλημα είναι περίπλοκο. Ωστόσο με ενοχλεί να βλέπω μέσα στο πρόγραμμα αυτόν τον ακατάληπτο κώδικα.
\end{question}

Μπορούμε να απομονώσουμε τον ομολογουμένως δυσνόητο υπολογισμό της ημέρας της εβδομάδας μέσα σ' ένα υποπρόγραμμα. Αυτό θα δέχεται μια τριάδα παραμέτρων (ημέρα, μήνας, έτος) που αντιστοιχούν σε μια ημερομηνία και θα επιστρέφει έναν ακέραιο από το 0 μέχρι και το 6, που αντιστοιχεί σε μια ημέρα της εβδομάδας. 

\pyfile[firstline=1,lastline=16]{src/weekday.2.py}

Ο κώδικας της μεθόδου δεν έχει αλλάξει, αλλά πλέον είναι «κλεισμένος» μέσα στο υποπρόγραμμα. Όποιος θέλει να το χρησιμοποιήσει δεν χρειάζεται να καταλαβαίνει πως λειτουργεί. Δεν χρειάζεται καν να γνωρίζει με ποια μέθοδο υπολογίζεται το αποτέλεσμα. 

Στο κύριο πρόγραμμα, απλά καλούμε την συνάρτηση, δίνοντας ως παραμέτρους τις τιμές που διαβάσαμε από το χρήστη.

\pyfilesrc[firstline=17,lastline=25]{src/weekday.2.py}

%%%%%%%%

\section{Στις 32 Του Μηνός}

\begin{question}
Ο χρήστης μπορεί να δώσει αυθαίρετους αριθμούς για το έτος, τον μήνα και την ημέρα. Δεν χρειάζεται κάποιος έλεγχος;
\end{question}

Είναι απαραίτητο η τιμή που θα δοθεί για το μήνα να είναι ανάμεσα στο 1 και το 12. Επίσης, είναι απαραίτητο η τιμή που θα δοθεί για την ημέρα να είναι ανάμεσα στο 1 και το πλήθος των ημερών του μήνα. Για το έτος υπάρχει περιθώριο ελαστικότητας, αλλά και πάλι θα ήταν καλό να περιορίσουμε την τιμή σε λογικά όρια. 

% \clearpage
Ας εξετάσουμε αρχικά πως θα μπορούσαμε να ελέγξουμε ότι η τιμή που δίνεται για τον μήνα είναι έγκυρη. Πιθανώς το πρώτο πράγμα που θα έγραφε κανείς να ήταν το εξής:

\begin{pycode}
print("Mήνας: ", end="")
month = int(input())
if month < 1 or month > 12:
    # μήνυμα λάθους
    print("Δώστε τιμή από 1 μέχρι 12")
\end{pycode}

Όμως αυτό δεν αρκεί γιατί, σε περίπτωση μη-έγκυρης τιμής, ο χρήστης θα πρέπει και πάλι να πληκτρολογήσει μια τιμή για τον μήνα, η οποία θα πρέπει και πάλι να ελεγχθεί και, πιθανώς, να μην είναι ούτε αυτή την φορά έγκυρη, κ.ο.κ. Με άλλα λόγια, η ανάγνωση τιμής και ο έλεγχός της θα πρέπει να \emph{επαναλαμβάνονται}, μέχρι να διαβαστεί έγκυρη τιμή. Θα χρειαστούμε λοιπόν μια \emph{δομή επανάληψης}.%, η οποία καθιστά δυνατή την εκτέλεση των ίδιων εντολών πολλές φορές.
        
%\marginnote[18pt]{Η επαναληπτική δομή \pyinline{while} συνοδεύεται από μια \emph{συνθήκη συνέχειας}, η οποία ελέγχεται στην αρχή κάθε νέου κύκλου της επανάληψης. Όσο η συνθήκη ισχύει (είναι \emph{αληθής}), η επανάληψη συνεχίζεται. Μην παραλείπετε το σύμβολο \pyinline{:} μετά την συνθήκη.}
%%\marginnote{Οι εντολές που ακολουθούν τη \pyinline{while} είναι στοιχισμένες δεξιότερα από αυτή. Η στοίχιση αυτή επιτυγχάνεται εισάγοντας κενά πριν από τις εντολές και υποδηλώνει ότι αυτές οι εντολές ανήκουν, είναι \emph{εμφωλευμένες} μέσα στη \pyinline{while} κι επαναλαμβάνονται. Η πρώτη εντολή μετά τη \pyinline{while} που δεν θα είναι στοιχισμένη δεξιότερα δεν θα επαναλαμβάνεται, αλλά θα εκτελεστεί μόνο μια φορά, όταν η επανάληψη τερματιστεί.}
%\marginnote{Οι εντολές που ακολουθούν τη \pyinline{while} είναι στοιχισμένες δεξιότερα, υποδηλώνοντας ότι αυτές οι εντολές ανήκουν, είναι \emph{εμφωλευμένες} μέσα στη \pyinline{while} κι επαναλαμβάνονται. Η πρώτη εντολή μετά τη \pyinline{while} που δεν θα είναι στοιχισμένη δεξιότερα θα εκτελεστεί μόνο μια φορά, όταν η επανάληψη τερματιστεί.}
%\marginnote{Μια συνθήκη μπορεί να είναι σύνθετη, αποτελούμενη από επιμέρους απλούστερες συνθήκες. Οι λογικοί τελεστές με τους οποίους σχηματίζουμε σύνθετες συνθήκες είναι οι \pyinline{and} (\emph{σύζευξη}), \pyinline{or} (\emph{διάζευξη}) και \pyinline{not} (\emph{άρνηση}).}
\pyfilenl[firstline=20,lastline=28]{src/weekday.3.break.py}

Εδώ ο χρήστης πρακτικά εγκλωβίζεται σ' έναν κύκλο. Η ανάγνωση τιμής (μαζί με το σχετικό μήνυμα λάθους) επαναλαμβάνεται μέχρι ο χρήστης να παρέχει μια αποδεκτή τιμή. %Αν ο χρήστης πληκτρολογήσει απευθείας μια έγκυρη τιμή τότε ο κύκλος της επανάληψης δεν ξεκινά καν, αφού η συνθήκη της είναι εξαρχής ψευδής.
Μια εναλλακτική προσέγγιση της ίδιας ιδέας είναι η εξής:

\pyfilesrc[firstline=20,lastline=27]{src/weekday.3.py}

Και σε πολλά άλλα προγράμματα θα χρειαστεί να διαβάσουμε από το χρήστη τιμές, εξασφαλίζοντας ότι οι τιμές αυτές είναι \emph{έγκυρες}, δηλαδή ικανοποιούν κάποιους περιορισμούς.

%%%%%%%%

\section{Μια Απ' Τα Ίδια;}

\begin{question}
Μου φαίνεται πως αυτό ακριβώς που κάναμε για το μήνα θα πρέπει να το κάνουμε για το έτος και για την ημέρα (αλλά με διαφορετικά όρια). Πάλι τα ίδια θα γράφουμε;
\end{question}

%\clearpage
Και για τις τρεις τιμές (έτος, μήνας, ημέρα) έχουμε το ίδιο ακριβώς πρόβλημα: θέλουμε να εμφανίζεται στο χρήστη μια \emph{προτροπή} και στη συνέχεια να διαβάζεται από το χρήστη μια ακέραια τιμή που θα πρέπει να βρίσκεται εντός συγκεκριμένων ορίων. 

Θα λύσουμε αυτό το πρόβλημα με γενικό τρόπο, κατασκευάζοντας ένα \emph{υποπρόγραμμα} που δέχεται σαν παραμέτρους την προτροπή και τα όρια κι επιστρέφει την τιμή που διαβάστηκε από το χρήστη. Ουσιαστικά θα γενικεύσουμε τον κώδικα που αναπτύξαμε λίγο πριν για τον έλεγχο της τιμής του μήνα.

\pyfile[firstline=17,lastline=35]{src/weekday.4.py}

%Φανταστείτε αυτό το υποπρόγραμμα σαν ``εξάρτημα'' που υλοποιεί μια συγκεκριμένη λειτουργία, παρέχοντας λύση σε ένα συγκεκριμένο υποπρόβλημα. Για να το χρησιμοποιήσουμε θα πρέπει να το \emph{καλέσουμε}, παρέχοντας συγκεκριμένες τιμές για τις παραμέτρους του κι ενεργοποιώντας την εκτέλεση των εντολών του. Εμείς 
Θα χρησιμοποιήσουμε αυτό το υποπρόγραμμα τρεις φορές, καλώντας το κάθε φορά με διαφορετικές παραμέτρους, για να εισάγουμε τιμές για το έτος, το μήνα και την ημέρα.

\pyfilesrc[firstline=36,lastline=41]{src/weekday.4.py}

Το 1923 είναι η χρονιά που υιοθετήθηκε η χρήση του Γρηγοριανού ημερολογίου στην Ελλάδα. Το άνω όριο είναι αυθαίρετο. 

Αναπτύξαμε αυτό το υποπρόγραμμα γιατί ήταν απαραίτητο σε τρία διαφορετικά σημεία του προγράμματός μας να διαβάζουμε έναν ακέραιο αριθμό εντός συγκεκριμένων ορίων. Αντί να αντιγράψουμε τις ίδιες εντολές σε τρία σημεία, τις τοποθετήσαμε μέσα στο υποπρόγραμμα για να τις καλούμε όποτε τις χρειαζόμαστε. 

Όμως το υποπρόγραμμα που αναπτύξαμε δεν λειτουργεί μόνο για έτη, μήνες και ημέρες, αλλά μπορεί να χρησιμοποιηθεί και σε οποιαδήποτε άλλη περίπτωση θέλουμε να διαβάσουμε από το χρήστη έναν ακέραιο αριθμό εντός ορίων. Με άλλα λόγια, το υποπρόγραμμα λύνει το πρόβλημα με γενικό τρόπο και είναι επαναχρησιμοποιήσιμο.

% θα μπορούσαμε να επεκτείνουμε την συνάρτηση για να ελέγχουμε ότι πράγματι δόθηκε ακέραιος
% >>> Χρειάζεται περισσότερος (γενικός) σχολιασμός για τον τρόπο που δουλεύουν οι συναρτήσεις και (κυρίως) η κλήση τους. Σύγκρινε με τον τρόπο που εισάγεται στο ΝΙΜ.

%%%%%%%%

\section{Πόσες Έχει Ο Μήνας;}

\begin{question}
Δεν έχουν όμως όλοι οι μήνες 31 ημέρες. Αφού τον κάνουμε τον έλεγχο, ας τον κάνουμε σωστά.
\end{question}

Στο σημείο αυτό χρειάζεται να υπολογίσουμε το πλήθος των ημερών ενός μήνα. Όπως φαντάζεστε, θα λύσουμε αυτό το υποπρόβλημα κατασκευάζοντας το αντίστοιχο υποπρόγραμμα, ένα ακόμα ``εξάρτημα'' που κάνει μια συγκεκριμένη δουλειά: δέχεται σαν παράμετρο το μήνα και το έτος κι επιστρέφει τον αριθμό των ημερών του μήνα.

Οι κανόνες που καθορίζουν πόσες ημέρες έχει ο κάθε μήνας είναι οι εξής: 
πριν τον Αύγουστο, οι άρτιοι μήνες έχουν 30 ημέρες και οι περιττοί έχουν 31, ενώ από τον Αύγουστο και μετά ισχύει το αντίστροφο. Εξαίρεση αποτελεί ο Φλεβάρης που έχει 28 ημέρες, εκτός κι αν το έτος είναι δίσεκτο, οπότε έχει 29.

Από τα παραπάνω φαίνεται πως τίθεται ένα ακόμα μικρότερο πρόβλημα: χρειάζεται να γνωρίζουμε αν ένα έτος είναι δίσεκτο ή όχι. Ας ξεκινήσουμε λοιπόν με την επίλυση αυτού του υποπροβλήματος, κατασκευάζοντας το αντίστοιχο υποπρόγραμμα, το οποίο θα δέχεται σαν παράμετρο ένα έτος και θα αποφαίνεται αν είναι δίσεκτο ή όχι. Εξ' ορισμού, δίσεκτα είναι τα έτη που διαιρούνται με το 4, αλλά όχι με το 100, καθώς και τα έτη που διαιρούνται με το 400.

%\marginnote[18pt]{Ο τελεστής \% είναι το υπόλοιπο της ακέραιας διαίρεσης δύο αριθμών. Εξετάζουμε αν το έτος διαιρείται με το 4, το 100 και το 400 ελέγχοντας αν το υπόλοιπο της ακέραιας διαίρεσης με το 4, το 100 και το 400 είναι ή όχι μηδενικό.}
\begin{pycode}
def isLeap(year):
    """ Επιστρέφει την τιμή True αν το έτος year
    είναι δίσεκτο, αλλιώς επιστρέφει False.
    """
    if (year % 4 == 0 and year % 100 > 0) or
      year % 400 == 0:
        return True
    else:
        return False
\end{pycode}

Στην πραγματικότητα, η δομή επιλογής δεν είναι απαραίτητη. Ορθότερη προσέγγιση είναι η εξής:

%\clearpage
\marginnote[18pt]{Η τιμή μιας συνθήκης είναι είτε αληθής (\pyinline{True}), είτε ψευδής (\pyinline{False}). Εδώ λοιπόν επιστρέφεται απευθείας η τιμή της συνθήκης που ελέγχει αν το έτος \pyinline{year} είναι δίσεκτο.}
\pyfile[firstline=36,lastline=41]{src/weekday.5.py}

Τώρα μπορούμε να υλοποιήσουμε το υποπρόγραμμα που υπολογίζει τον αριθμό των ημερών ενός μήνα. Το έτος είναι απαραίτητο σαν παράμετρος στο υποπρόγραμμα γιατί ο μήνας μπορεί να είναι ο Φλεβάρης, οπότε το έτος επηρρεάζει τον αριθμό των ημερών. 

%\marginnote[18pt]{Η δεσμευμένη λέξη \pyinline{elif} είναι σαν συντομογραφία του \pyinline{else if}. Χρησιμοποιείται στη δομή \emph{πολλαπλής επιλογής}, δηλαδή όταν χρειάζεται να ελέγξουμε διαδοχικά περισσότερες από δύο περιπτώσεις.}
%\marginnote[8pt]{Η συνάρτηση αποτελείται από μία δομή πολλαπλής επιλογής με τρεις περιπτώσεις. Σε κάθε μια από αυτές βρίσκεται \emph{εμφωλευμένη} μια δομή επιλογής με δύο περιπτώσεις. Οι εμφωλεύσεις καθορίζονται από την στοίχιση των εντολών.}
\pyfile[firstline=42,lastline=64]{src/weekday.5.py}

H ανάγνωση τιμής για την ημέρα μπορεί πλέον να γίνει καθορίζοντας σωστά το πλήθος των ημερών του μήνα.

\pyfilesrc[firstline=65,lastline=68]{src/weekday.5.py}

Από τα παραπάνω βγαίνει στην επιφάνεια το μεγαλύτερο πλεονέκτημα που προκύπτει από τη χρήση υποπρογραμμάτων. Είμαστε ``αναγκασμένοι'' να αναλύουμε τα προβλήματα και να τ' αντιμετωπίζουμε \emph{τμηματικά}. Κάθε φορά εστιάζουμε την προσοχή μας σε μικρότερα κι απλούστερα κομμάτια του γενικού προβλήματος. Στη συνέχεια, συνθέτουμε τη λύση, συναρμολογώντας τα κομμάτια αυτά.

%%%%%%%%

\section{Και Κάτι Ακόμα}

\begin{question}
Δεν μου αρέσει που το πρόγραμμα εμφανίζει έναν αριθμό και πρέπει ο χρήστης να σκέφτεται την αντιστοιχία με τις ημέρες.
\end{question}

Υπάρχουν αρκετοί τρόποι ν' αντιστοιχίσουμε τους ακέραιους από το 0 μέχρι και το 6 με τις ημέρες από την Κυριακή μέχρι και το Σάββατο. Ένας από αυτούς είναι να τοποθετήσουμε τα ονόματα των ημερών της εβδομάδας μέσα σε μια \emph{πλειάδα}. Η πλειάδα είναι μια λίστα τιμών \emph{που δεν μπορεί να τροποποιηθεί}.
\clearpage

%\marginnote[18pt]{Τα ονόματα των ημερών περικλείονται σε εισαγωγικά, αφού πρόκειται για αλφαριθμητικές τιμές (κείμενο).}
\marginnote[18pt]{Το πρώτο στοιχείο της πλειάδας είναι το \pyinline{dayNames[0]}, με τιμή \pyinline{'Κυρ'}, το δεύτερο είναι το \pyinline{dayNames[1]}, με τιμή \pyinline{'Δευ'}, ενώ το τελευταίο είναι το \pyinline{dayNames[6]}, με τιμή \pyinline{'Σαβ'}. Η αρίθμηση μπορεί να είναι κι αντίστροφη, με το πρώτο στοιχείο από το τέλος να είναι το \pyinline{dayNames[-1]}, με τιμή \pyinline{'Σαβ'}, κ.ο.κ.}
\begin{pycode}
# πλειάδα με τα ονόματα των ημερών
dayNames = ('Κυρ','Δευ','Τρι','Τετ','Πεμ','Παρ','Σαβ')
\end{pycode}

Είναι η πρώτη φορά που ένα όνομα, το \pyinline{dayNames}, δεν αντιστοιχεί σε μια μεμονωμένη τιμή αλλά σε μια \emph{συλλογή τιμών}, όπως είναι εδώ η πλειάδα με τα ονόματα των ημερών. 

Η σειρά των ημερών μέσα στην πλειάδα έχει σημασία γιατί κάθε θέση είναι αριθμημένη, με την αρίθμηση να ξεκινάει από το μηδέν. Μπορούμε λοιπόν να χρησιμοποιήσουμε την (ακέραια) ημέρα της εβδομάδας που έχουμε υπολογίσει για να έχουμε πρόσβαση στην αντίστοιχη θέση της πλειάδας που περιέχει το όνομα της ημέρας.

\pyfilesrc[firstline=69,lastline=74]{src/weekday.6.py}

%%%%%%%%

\section{Πλήρες Τελικό Πρόγραμμα}

\pyfile[firstline=1,lastline=16]{src/weekday.final.py}
\tobecontinued

\pyfile[firstline=18,firstnumber=17,lastline=67]{src/weekday.final.py}
%\tobecontinued

\pyfilesrc[firstline=69,firstnumber=65]{src/weekday.final.py}

%%%%%%%%

\section*{}
\vspace{-4\parskip}
\hrulefill

\begin{theory}{Δομές Δεδομένων}
Οργανωμένες συλλογές τιμών όπως οι πλειάδες ονομάζονται \emph{δομές δεδομένων}. Μια δομή δεδομένων δεν είναι ένα απλό σύνολο από τιμές, δεν αποτελεί μια απλή γενίκευση των μεταβλητών, αλλά είναι δομημένη με συγκεκριμένο τρόπο. Τα διαφορετικά είδη δομών δεδομένων διαφοροποιούνται κυρίως από τον τρόπο με τον οποίο τα δεδομένα αποθηκεύονται, ανακτώνται και συσχετίζονται μεταξύ τους. 
\end{theory}

\hrulefill

\end{document}
