\documentclass[a4paper,11pt,oneside]{book}

\newcommand{\standalone}{}
\input{../../share/tuftelike}
\input{../../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{1}

\usepackage{booktabs}

%%% DOCUMENT START

\begin{document}

\chapterwabstract{Μάντεψε τον Αριθμό}{Ένα από τα πρώτα προγράμματα που συνηθίζεται να φτιάχνουν οι μαθητευόμενοι προγραμματιστές είναι ένα παιχνίδι στο οποίο ο παίκτης προσπαθεί να μαντέψει τον \emph{μυστικό αριθμό} που έχει ``σκεφτεί'' ο υπολογιστής (ή το αντίστροφο).

Υπάρχουν πολλοί καλοί λόγοι που αυτό το παιχνίδι είναι μια τόσο δημοφιλής επιλογή για τους αρχάριους: το πρόγραμμα δεν είναι ιδιαίτερα περίπλοκο, αν και συνδυάζει όλες τις βασικές αλγοριθμικές έννοιες, ενώ το παιχνίδι καθεαυτό είναι πολύ διασκεδαστικό.
}{}{guessColor}{guessColor}

%%%%%%%%

\marginnote[21pt]{Στη διεύθυνση \href{http://pythonies.mysch.gr/}{\url{pythonies.mysch.gr}} μπορείτε να βρείτε κι άλλα φύλλα εργασίας σαν και αυτό, καθώς και το συνοδευτικό τους υλικό.}%
Με αυτό το φύλλο εργασίας θα γνωρίσουμε τα βασικά είδη εντολών που επιτρέπουν στα προγράμματά μας να \emph{αλληλεπιδρούν} με το χρήστη, δηλαδή να του εμφανίζουν μηνύματα στην οθόνη και να του ζητούν να εισάγει τιμές από το πληκτρολόγιο. 

Θα εξετάσουμε επίσης πως μπορούμε να κάνουμε τα προγράμματά μας να \emph{επιλέγουν} τον τρόπο που θα συμπεριφερθούν, εξετάζοντας τις \emph{συνθήκες} που επικρατούν κατά την εκτέλεσή τους. Θα δούμε ακόμα πως μπορούμε να κάνουμε τα προγράμματά μας να εκτελούν \emph{επαναληπτικά}, δηλαδή ξανά και ξανά, τις ίδιες εντολές.

\section{Οδηγίες}

Αρχικά, το πρόγραμμά μας θα δίνει κάποιες οδηγίες στον παίκτη σχετικά με το παιχνίδι.

\begin{step}
Ξεκινήστε το πρόγραμμα με την εντολή:

\begin{pynew}
print("Θα σκεφτώ έναν αριθμό από το 1 μέχρι το 32.")
\end{pynew}

Εκτελέστε το πρόγραμμα και δείτε τι συμβαίνει.
\end{step}

\begin{step}
Βασιστείτε στην εντολή του προηγούμενου βήματος και συμπληρώστε το πρόγραμμα με μια ακόμα εντολή, έτσι ώστε να εμφανίζεται στην οθόνη το μήνυμα:

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Εσύ θα προσπαθήσεις να τον μαντέψεις.
\end{pyterm}

Εκτελέστε ξανά το πρόγραμμα. Τα καταφέρατε;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
\label{step:secret-assign}
Το πρόγραμμά θα ορίζει τώρα τον μυστικό αριθμό. Έστω ότι επιλέγει το τυχερό \pyinline{13}. Προσθέστε την παρακάτω εντολή στο πρόγραμμα:

\begin{pynew}
secret = 13
\end{pynew}

Η \pyinline{secret} είναι μια \emph{μεταβλητή} στην οποία αποθηκεύεται η τιμή του μυστικού αριθμού που επιλέγει το πρόγραμμά μας. 
%Με την εντολή αυτή ορίζουμε ότι ο μυστικός αριθμός είναι ο \pyinline{13}. 
Τώρα μπορούμε να αναφερόμαστε στον μυστικό αριθμό με το όνομα \pyinline{secret}, χωρίς να έχει σημασία ποια είναι η τιμή του.

Εκτελέστε το πρόγραμμα. Παρατηρείτε κάποια διαφορά στην εκτέλεση μετά την προσθήκη της παραπάνω εντολής;

\marginnote[14pt]{\icondiscuss}
\dottedline

\end{step}

\section{Γνωριμίες}

Το πρόγραμμά μας θα ζητά από τον παίκτη το όνομά του και θα τον καλωσορίζει στο παιχνίδι.

\begin{step}
\label{step:name-input}
\emph{Προσθέστε} τις παρακάτω εντολές οπουδήποτε στο πρόγραμμα.

\begin{pynew}
print("Πώς σε λένε;")
player = input()
\end{pynew}

Η \pyinline{input()} επιστρέφει το κείμενο που πληκτρολόγησε ο χρήστης, επιστρέφει δηλαδή μια \emph{αλφαριθμητική τιμή}. Εδώ χρησιμοποιούμε την \pyinline{input()} για να διαβάσουμε την απάντηση του χρήστη, η οποία αποθηκεύεται στη μεταβλητή \pyinline{player}.

Εκτελέστε το πρόγραμμα. Η μεταβλητή \pyinline{player} παίρνει την τιμή που πληκτρολογείτε (αναλαμβάνοντας το ρόλο του χρήστη πλέον).
\end{step}

\begin{step}
\label{step:print-variable}
Συμπληρώστε το πρόγραμμα με την παρακάτω εντολή.

\begin{pynew}
print("Γεια σου", player)
\end{pynew}

Εκτελέστε το πρόγραμμα σας 2--3 φορές, παίζοντας το ρόλο του χρήστη, πληκτρολογήστε κάθε φορά διαφορετικά ονόματα και παρατηρήστε τι εμφανίζει.

Ποια πιστεύετε ότι θα ήταν η διαφορά αν είχατε πληκτρολογήσει \pyinline{print("Γεια σου player")};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Ποια θα ήταν η διαφορά αν αντί της εντολής \pyinline{player = input()} χρησιμοποιούσαμε την εντολή \pyinline{player = "Μυρσίνη"};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Ποια θα ήταν η διαφορά αν στο βήμα~\ref{step:secret-assign} γράφαμε \pyinline{secret = input()}, αντί για \pyinline{secret = 13};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\section{Φρέναρε λίγο}

Το πρόγραμμά μας εμφανίζει όλα τα μηνύματα μαζεμένα. Θα δώσουμε μια ανάσα στον παίκτη, ώστε να προλαβαίνει να τα διαβάζει έχοντας λίγο χρόνο στη διάθεσή του, πριν του εμφανίσουμε το επόμενο μήνυμα. 

Στο σημείο αυτό θα χρειαστούμε μια λειτουργία που δεν προσφέρεται από τις βασικές εντολές της Python. Για το σκοπό αυτό θα χρειαστεί να εισάγουμε στο πρόγραμμά μας μια βιβλιοθήκη και συγκεκριμένα τη βιβλιοθήκη \pyinline{time}, η οποία παρέχει τη λειτουργικότητα που μας χρειάζεται. Οι βιβλιοθήκες είναι συλλογές από μικρά προγράμματα που μπορούμε να χρησιμοποιήσουμε στα προγράμματά μας.

\begin{step}
\emph{Προσθέστε στην αρχή του προγράμματος} την εντολή που ακολουθεί, για να \emph{εισάγετε} τη βιβλιοθήκη \pyinline{time}:

\begin{pynew}
import time
\end{pynew}
\end{step}

\begin{step}
Εισάγετε, ανάμεσα στις δύο πρώτες \pyinline{print}, την παρακάτω εντολή:

\begin{pynew}
time.sleep(1)
\end{pynew}

Με την εντολή αυτή χρησιμοποιείται η \emph{συνάρτηση} \pyinline{sleep} από τη βιβλιοθήκη \pyinline{time}. 
Τί αποτέλεσμα έχει η προσθήκη αυτής της εντολής;

\marginnote[14pt]{\icondiscuss}
\dottedline

Tί ρόλο παίζει η \emph{παράμετρος} \pyinline{1}; Διερευνήστε τι θα συμβεί αν χρησιμοποιήσουμε άλλον αριθμό στη θέση του \pyinline{1}.

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\section{Ας παίξουμε}

Ήρθε η ώρα να ξεκινήσει το πραγματικό παιχνίδι. Το πρόγραμμά θα ζητά από τον παίκτη έναν αριθμό και στη συνέχεια θα εμφανίζει μήνυμα αν βρήκε τον μυστικό αριθμό ή όχι.

\begin{step}
\label{step:number-input}
\emph{Προσθέστε} τις παρακάτω εντολές στο πρόγραμμα:

\begin{pynew}
print("Δώσε αριθμό:")
number = int(input())
\end{pynew}

Τι διαφορά παρατηρείτε σε σχέση με τις εντολές που χρησιμοποιήσατε για να ζητήσετε το όνομα του παίκτη στο βήμα~\ref{step:name-input};

\clearpage
\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Ποια διαφορά πιστεύετε ότι έχει η τιμή του ονόματος του παίκτη από την τιμή του \pyinline{number};

% [comment][rejected] Δεν πιστεύω ότι αξίζει να τους παιδέψουμε με αυτήν την ερώτηση. Έχουν επισημάνει τη διαφορά, ας τους εξηγήσουμε απλά που οφείλεται.

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\begin{step}
Συμπληρώστε το πρόγραμμα, ώστε να εμφανίζει στον παίκτη τον αριθμό που πληκτρολόγησε, για παράδειγμα:

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Έδωσες τον αριθμό 20
\end{pyterm}

Αν δυσκολευτείτε, ανατρέξτε στο βήμα~\ref{step:print-variable}.
%, όπου γίνεται κάτι ανάλογο.
\end{step}

\begin{step}

\emph{Προσθέστε} στο πρόγραμμα σας τις εντολές: %που θα εμφανίζουν αυτά τα μηνύματα:

\begin{pynew}
print("Σωστά!")
print("Λάθος...")
\end{pynew}

Τι \emph{πιστεύετε} ότι θα εμφανίσει το πρόγραμμα αν το εκτελέσουμε τώρα;

\marginnote[14pt]{\icondiscuss}
\dottedline

Εκτελέστε το πρόγραμμα. Επιβεβαιώνεται η απάντησή σας;

\marginnote[14pt]{\icondiscuss}
\dottedline

Σε ποια περίπτωση είναι επιθυμητό να εμφανίζεται το \pyinline{"Σωστά!"}; Αντίστοιχα, σε ποια περίπτωση είναι επιθυμητό να εμφανίζεται το \pyinline{"Λάθος..."};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\end{step}

\begin{step}
Θα τροποποιήσουμε το πρόγραμμά μας, έτσι ώστε να \emph{ελέγχει} αν ο παίκτης μάντεψε τον μυστικό αριθμό και στη συνέχεια να εμφανίζει \emph{μόνο} το κατάλληλο μήνυμα.

\emph{Προσθέστε} τις παρακάτω εντολές:

%\marginnote{Με το \pyinline{!=} ελέγχεται αν δύο τιμές είναι διαφορετικές.}
\marginnote[18pt]{Με το \pyinline{==} ελέγχεται αν δύο τιμές είναι ίσες. Μην το συγχέετε με το \pyinline{=} που χρησιμοποιείται για να δώσουμε τιμή σε μια μεταβλητή.}
\begin{pynew}
if number == secret:
\end{pynew}
\begin{pyplain}
print("Σωστά!")
\end{pyplain}
\begin{pynew}
else:
\end{pynew}
\begin{pyplain}
print("Λάθος...")
\end{pyplain}

\marginnote[14pt]{\iconcaution}
Εκτελέστε το πρόγραμμα. Παρατηρήστε το \emph{σφάλμα} που εμφανίζει.

Στις περισσότερες γλώσσες προγραμματισμού δεν θα αντιμετωπίζατε κάποιο πρόβλημα, όμως η Python έχει μια ``ευαισθησία'': Οι εντολές που εκτελούνται στη μία ή στην άλλη περίπτωση πρέπει να \emph{ξεχωρίζουν}, πρέπει με κάποιον τρόπο να επισημανθεί ότι οι εντολές αυτές \emph{ανήκουν} αντίστοιχα στην \pyinline{if} και την \pyinline{else}. 

Στην Python, αυτό επιτυγχάνεται με τις \emph{εσοχές}.
\end{step}

\begin{step}
\emph{Προσθέστε} 4 κενά πριν από τις δύο \pyinline{print} και εκτελέστε το πρόγραμμα.

\begin{pyplain}
if number == secret:
|\pyhighlight{\vphantom{λρ}    }|print("Σωστά!")
else:
|\pyhighlight{\vphantom{λρ}    }|print("Λάθος...")
\end{pyplain}

Εκτελέστε το πρόγραμμα σας δύο φορές. Στην πρώτη δώστε σωστά τον μυστικό αριθμό, ενώ στην επόμενη δώστε έναν διαφορετικό.

% \marginnote[36pt]{\iconcaution}
% Εκτελέστε το πρόγραμμα. Σε περίπτωση που δε λειτουργεί σωστά, βεβαιωθείτε ότι έχετε χρησιμοποιήσει το σωστό συγκριτικό τελεστή για τον έλεγχο ισότητας.

Εμφανίζεται το κατάλληλο μήνυμα σε κάθε περίπτωση;

\marginnote[14pt]{\icondiscuss}
\dottedline

Σε ποια περίπτωση εκτελούνται οι εντολές της else;
% [comment] Μήπως αυτή η ερώτηση να έμπαινε πρώτη, ακόμα και πριν το εκτελέσουν;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

% \begin{step}
% \emph{Τροποποιήστε} το πρόγραμμα, ώστε να εξετάζει τις περιπτώσεις με αντίστροφη σειρά.

% \begin{pynew}
% if |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
%     print("Σωστά!")
% else:
%    print("Λάθος...")
% \end{pynew}
% \end{step}

\begin{step}
\label{step:secret-print}

\emph{Προσθέστε} στο πρόγραμμα μια \pyinline{print}, η οποία θα εμφανίζει τον μυστικό αριθμό στην περίπτωση που ο παίκτης απαντήσει λάθος, όπως παρακάτω:

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Ο μυστικός αριθμός ήταν ο 13.
\end{pyterm}

%Σε ποιο σημείο του προγράμματος προσθέσατε την εντολή εμφάνισης του μυστικού αριθμού;

%\marginnote[14pt]{\icondiscuss}
%\dottedline

%Τί σας έκανε να την προσθέσετε στο συγκεκριμένο σημείο;

%\marginnote[14pt]{\icondiscuss}
%\dottedline

Εκτελέστε το πρόγραμμα δύο φορές. Στην πρώτη δώστε σωστά τον μυστικό αριθμό, ενώ στην επόμενη δώστε έναν διαφορετικό.

Εμφανίζει το μυστικό αριθμό \emph{μόνο} στην περίπτωση που ο παίκτης δεν τον μαντέψει; Αν όχι, γιατί πιστεύετε ότι συμβαίνει αυτό;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\marginnote[16pt]{\iconcaution}
Αν ο μυστικός αριθμός εμφανίζεται είτε ο χρήστης τον μαντέψει, είτε όχι, τότε πιθανότατα δεν τοποθετήσατε τη νέα εντολή \emph{μέσα} στην \pyinline{else}, αλλά μετά από αυτή. Προσθέστε 4 κενά πριν την εντολή, για να υποδηλώσετε ότι κι αυτή ανήκει στην \pyinline{else}.
\end{step}

\begin{step}
Στο μήνυμα που εμφανίσατε προηγουμένως χρησιμοποιήσατε την μεταβλητή \pyinline{secret};

\marginnote[14pt]{\icondiscuss}
\dottedline

Αν απαντήσατε όχι, \emph{τροποποιήστε} κατάλληλα την εντολή \pyinline{print}, ώστε να χρησιμοποιεί τη \pyinline{secret} και όχι το \pyinline{13}.

Τι πλεονέκτημα πιστεύετε ότι έχει η χρήση της μεταβλητής \pyinline{secret} στο μήνυμα, αντί της απευθείας εμφάνισης του αριθμού \pyinline{13};

\marginnote[14pt]{\icondiscuss}
\dottedline

Δοκιμάστε να παίξετε 2--3 φορές ακόμα. Υπάρχει κάτι που σας ενοχλεί στον τρόπο που λειτουργεί το πρόγραμμα;

\marginnote[14pt]{\icondiscuss}
\dottedline

\end{step}

\section{Τυχαιότητα}

Το παιχνίδι μας δεν αξίζει να το παίξεις πάνω από μία-δύο φορές, αν ο μυστικός αριθμός είναι πάντα το \pyinline{13}. Αυτό που πραγματικά χρειαζόμαστε είναι να επιλέγεται κάθε φορά ένας διαφορετικός αριθμός.

Για τον σκοπό αυτό, θα χρειαστούμε τη βιβλιοθήκη \pyinline{random}, όπως προηγουμένως είχαμε χρησιμοποιήσει τη βιβλιοθήκη \pyinline{time}. 

\begin{step}
\label{step:secret-random}
\emph{Προσθέστε} στο πρόγραμμα την εντολή εισαγωγής της βιβλιοθήκης \pyinline{random}.

\begin{pynew}
import random
\end{pynew}

\emph{Τροποποιήστε} την εντολή του βήματος~\ref{step:secret-assign}, όπου ορίζεται η τιμή της μεταβλητής \pyinline{secret}, ως εξής:

\begin{pyplain}
secret = |\pyhighlight{random.randint(1,32)}|
\end{pyplain}

Εκτελέστε το πρόγραμμα αρκετές φορές. Τί είδους τιμές παρατηρείτε ότι παίρνει η μεταβλητή \pyinline{secret};

%Ποια διαφορά παρατηρείτε στη λειτουργία του;
%\marginnote[14pt]{\icondiscuss}
%\dottedline


\marginnote[14pt]{\icondiscuss}
\dottedline

Ποιος πιστεύετε ότι είναι ο ρόλος των παραμέτρων \pyinline{1} και \pyinline{32}; Τί συμβαίνει αν δοκιμάσετε άλλες τιμές στη θέση τους, για παράδειγμα \pyinline{33} και \pyinline{64}; Αν χρειαστεί εκτελέστε πάλι το πρόγραμμα αρκετές φορές προκειμένου να απαντήσετε στην ερώτηση.

\marginnote[14pt]{\icondiscuss}
\dottedline

%Ποιά πιστεύετε ότι θα είναι η τιμή της μεταβλητής \pyinline{secret} μετά την εκτέλεση της εντολής \pyinline{secret = random.randint(1,32)};

%\marginnote[14pt]{\icondiscuss}
%\dottedline

%Πως θα χρησιμοποιούσατε τη \pyinline{randint} για να προσομοιώσετε τη ρίψη ενός ζαριού, τη ρίψη ενός κέρματος ή την επιλογή ενός τυχαίου χαρτιού από μια τράπουλα;

%\marginnote[14pt]{\icondiscuss}
%\dottedline

%\dottedline

%\dottedline

%Μπορείτε να σκεφτείτε άλλες περιπτώσεις στις οποίες θα χρειαζόσασταν τη \pyinline{randint};

%\marginnote[14pt]{\icondiscuss}
%\dottedline
\end{step}

\begin{step}
Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\section{Γύρω-Γύρω Όλοι}

\begin{step}
\emph{Προσθέστε} τη γραμμή που ακολουθεί \emph{αμέσως πριν} από τις εντολές που προσθέσατε στο βήμα~\ref{step:number-input}, όπου ζητείται από το χρήστη να μαντέψει τον μυστικό αριθμό.

\begin{pynew}
while True:
\end{pynew}

\emph{Προσθέστε} τέσσερα κενά μπροστά από \emph{όλες τις εντολές που ακολουθούν} τη \pyinline{while}, σηματοδοτώντας έτσι ότι αυτές οι εντολές \emph{εμφωλεύονται} στη \pyinline{while}, δηλαδή περιέχονται σε αυτήν.

Εκτελέστε το πρόγραμμα. Ποια αλλαγή παρατηρείτε ότι επιφέρει η χρήση της \pyinline{while};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Η εντολή του βήματος~\ref{step:secret-random}, που δίνει μια τυχαία τιμή στην μεταβλητή \pyinline{secret}, βρίσκεται \emph{πριν} από τη \pyinline{while}. Ποια πιστεύετε ότι θα ήταν η διαφορά αν βρισκόνταν \emph{μέσα} στη \pyinline{while};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\label{step:secret-print-remove}
Η εντολή του βήματος~\ref{step:secret-print} που εμφανίζει τον μυστικό αριθμό στο χρήστη τώρα δημιουργεί πρόβλημα. Γιατί;
% πιο hardcode εναλλακτική διατύπωση: %\emph{Μία} από τις εντολές που βρίσκεται μέσα στη \pyinline{while} δημιουργεί πλέον πρόβλημα στο παιχνίδι. Εξηγήστε ποιο πρόβλημα δημιουργείται και \emph{διαγράψτε} την εντολή.

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

% [comment][removed] Ο σχολιασμός έχει νόημα σε αυτό το σημείο γιατί ακόμα έχουμε μια if με δύο περιπτώσεις. Όμως η περίπτωση που ο χρήστης δεν βρίσκει τον μυστικό αριθμό αργότερα σπάσει στα δύο και μάλιστα οι περιπτώσεις αναδιατάσσονται, οπότε η συγκεκριμένη εντολή δεν "ανήκει" ακριβώς σε ένα σημείο και φέρνει σε αμηχανία τους μαθητές.
% \emph{Προσθέστε} μπροστά από την εντολή το σύμβολο \#. Αυτό έχει σαν αποτέλεσμα η εντολή αυτή να θεωρείται \emph{σχόλιο} και να αγνοείται κατά την εκτέλεση του προγράμματος.
%\begin{note}
%Είναι συνηθισμένο να ``σχολιάζουμε'' μια εντολή όταν θέλουμε, δοκιμαστικά, να παρακαμφθεί. Στην συγκεκριμένη περίπτωση, το κάνουμε γιατί θα τη χρειαστούμε αργότερα, σε άλλο σημείο.
%\end{note}

\emph{Διαγράψτε} την εντολή που εμφανίζει τον μυστικό αριθμό.

Παίξτε το παιχνίδι μέχρι να μαντέψετε τον μυστικό αριθμό. Υπάρχει κάτι που σας ενοχλεί; Κάτι που φαίνεται να μη δουλεύει σωστά;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\end{step}

\begin{step}
Η εντολή \pyinline{break} διακόπτει την επανάληψη μέσα στην οποία βρίσκεται \emph{αμέσως} μόλις εκτελεστεί.
\emph{Προσθέστε} την \pyinline{break} στο σημείο που θεωρείτε κατάλληλο, έτσι ώστε το παιχνίδι να τερματίζεται όταν ο παίκτης μαντέψει τον αριθμό.

Παίξτε και πάλι το παιχνίδι μέχρι να μαντέψετε τον μυστικό αριθμό, για να επιβεβαιώσετε ότι τοποθετήσατε την \pyinline{break} σε σωστό σημείο.
\end{step}

\begin{step}
Για δοκιμαστικούς λόγους, κάτω από την \pyinline{break} \emph{προσθέστε} την εντολή:

\begin{pynew}
print("Ζντονκ!")
\end{pynew}

Εκτελέστε πάλι το πρόγραμμα μέχρι να μαντέψετε τον αριθμό. Εμφανίζεται το μήνυμα \pyinline{"Ζντονκ!"}; Γιατί πιστεύετε ότι συμβαίνει αυτό;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\emph{Αφαιρέστε} τώρα την εντολή που προσθέσατε.
\end{step}

\begin{step}
Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\section{Επιλογές, Επιλογές}

Θα επεκτείνουμε το πρόγραμμα έτσι ώστε να δίνει στο χρήστη περισσότερη πληροφορία: αντί να τον ενημερώνει απλά αν βρήκε τον μυστικό αριθμό ή όχι, θα τον κατευθύνει αν πρέπει να τον αναζητήσει ψηλότερα ή χαμηλότερα.

Για την επέκταση αυτή δεν αρκεί πια η απλή \pyinline{if}--\pyinline{else}, η οποία μπορεί να διακρίνει μόνο ανάμεσα σε δύο περιπτώσεις. 

\begin{step}
\emph{Τροποποιήστε} την \pyinline{if} που ελέγχει αν ο χρήστης βρήκε τον μυστικό αριθμό. Συμπληρώσετε την συνθήκη που λείπει:

\begin{pyplain}
    if number == secret:
        print("Σωστά!")
        break
\end{pyplain}
\begin{pynew}
    elif |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
    else:
        print("Ο μυστικός αριθμός είναι μικρότερος.")
\end{pynew}

Εκτελέστε το πρόγραμμα και βεβαιωθείτε ότι λειτουργεί σωστά. 

Σε ποια περίπτωση εκτελούνται οι εντολές της \pyinline{else}; Γιατί πιστεύετε ότι δεν ελέγχουμε καμία συνθήκη σε αυτή την τρίτη περίπτωση;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\dottedline
\end{step}

\begin{step}
\emph{Αναδιατάξτε} τις περιπτώσεις της \pyinline{if} όπως φαίνεται παρακάτω. Και πάλι, θα πρέπει να συμπληρώσετε τις συνθήκες που ελέγχονται σε κάθε περίπτωση.

\begin{pynew}
    if |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
        print("Ο μυστικός αριθμός είναι μικρότερος.")
    elif |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
    else:
        print("Σωστά!")
        break
\end{pynew}

% Πιστεύετε ότι έχει σημασία, στο συγκεκριμένο παράδειγμα, η σειρά με την οποία διατάσσουμε τις τρεις πιθανές περιπτώσεις;
% [comment][removed] Είναι διαφορετική ερώτηση το αν η σειρά έχει σημασία (που έχει) και το αν η σειρά επηρεάζει τη λειτουργία του προγράμματος. Σε μια πιο εκτεταμένη εκδοχή μπορούν να γίνουν ερωτήσεις και για τα δύο.
\end{step}

\begin{step}
Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\section{Μέτρημα}

Ο αριθμός των προσπαθειών που διαθέτει ο παίκτης δεν θα έπρεπε να είναι απεριόριστος. Θα επεκτείνουμε το παιχνίδι ώστε να τερματίζεται όταν εξαντληθούν οι προσπάθειες του παίκτη.

\begin{step}
\label{step:tries-print}
\emph{Προσθέστε} την εντολή που ακολουθεί αμέσως μετά τη \pyinline{while}, δηλαδή στην αρχή της επανάληψης.

\begin{pynew}
print("Απομένουν", tries, "προσπάθειες.")
\end{pynew}

Είναι εμφανές ότι η τιμή της μεταβλητής \pyinline{tries} θα αντιστοιχεί στο πλήθος των προσπαθειών που απομένουν στον παίκτη. 

\marginnote[16pt]{\iconcaution}
Αν εκτελέσετε το πρόγραμμα όπως έχει θα εμφανιστεί μήνυμα λάθους, αφού επιχειρούμε να εμφανίσουμε την τιμή της \pyinline{tries}, χωρίς πουθενά προηγουμένως να της έχουμε αποδώσει μια τιμή.

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
NameError: name 'tries' is not defined
\end{pyterm}
\end{step}

\begin{step}
\label{step:tries-init}
Δώστε στην \pyinline{tries} μια αρχική τιμή, ίση με το πλήθος των προσπαθειών που διαθέτει ο χρήστης όταν ξεκινά το παιχνίδι. Αποφασίστε εσείς μια τιμή που να σας φαίνεται ``δίκαιη''.

Τοποθετήσατε τις νέες εντολές \emph{πριν} την επανάληψη ή \emph{μέσα} σε αυτή; Για ποιο λόγο κάνατε αυτή την επιλογή;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Ποιο είναι το αρχικό πλήθος προσπαθειών που δώσατε στον παίκτη και γιατί θεωρήσατε αυτή την τιμή ``δίκαιη''.

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Εκτελέστε το πρόγραμμα. Τί παρατηρείτε;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
Η μεταβλητή \pyinline{tries} θα πρέπει να μειώνεται σε κάθε γύρο του παιχνιδιού, δηλαδή \emph{εντός της επανάληψης}. Μετά την \pyinline{print} του βήματος~\ref{step:tries-print} που εμφανίζει την τιμή της \pyinline{tries}, \emph{προσθέστε} τη γραμμή:

\begin{pynew}
    tries = tries - 1
\end{pynew}

Εκτελέστε το πρόγραμμα. Μειώνεται το πλήθος των προσπαθειών που απομένουν στον παίκτη;
%\marginnote[14pt]{\icondiscuss}
%\dottedline
\marginnote[14pt]{\iconcaution}
Αν το πλήθος των προσπαθειών δεν μειώνεται, βεβαιωθείτε ότι η εντολή που προσθέσατε στο βήμα~\ref{step:tries-init} και δίνει αρχική τιμή στην \pyinline{tries} βρίσκεται \emph{πριν} από την επανάληψη και όχι μέσα σε αυτή.

Περιγράψτε πως ακριβώς πιστεύετε ότι λειτουργεί η εντολή που προσθέσατε για να μειώνεται η \pyinline{tries}.

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\dottedline

%Αυτή η εντολή μπορεί να σας μπερδέψει αν την ερμηνεύσετε σαν μαθηματική ισότητα (ενώ δεν είναι). Για να γίνει κατανοητή, πρέπει να διαβαστεί ως εξής: υπολόγισε την τιμή της παράστασης \pyinline{tries - 1} κι ονόμασε το αποτέλεσμα \pyinline{tries}. Η νέα τιμή της \pyinline{tries} υπολογίζεται με βάση την τρέχουσα τιμή της, την οποία και αντικαθιστά.

Υπάρχει κάτι που σας ενοχλεί και φαίνεται να μη δουλεύει σωστά;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}
 
\section{Τερματισμός}

Το παιχνίδι δεν πρέπει να τερματίζεται μόνο όταν ο παίκτης μαντέψει τον αριθμό, αλλά και όταν τελειώσουν οι προσπάθειές του.

% [comment][removed] Αφαιρείται, λόγω χρονικών περιορισμών.

%\begin{step}
%Προς το παρόν, \emph{προσθέστε} τις εντολές που ακολουθούν στο σημείο που κρίνετε κατάλληλο ώστε η επανάληψη να τερματίζεται όταν εξαντληθούν οι προσπάθειες του παίκτη.

%\begin{pynew}
%    if tries == 0:
%        break
%\end{pynew}

%Εκτελέστε το πρόγραμμα. Φροντίστε, ως παίκτες, να εξαντλήσετε τις προσπάθειές σας χωρίς να μαντέψετε τον αριθμό. 

%Τί είδους τιμές δίνετε στο πρόγραμμα, ως παίκτες, για να εξαντλήσετε τις προπάθειές σας;

%\marginnote[14pt]{\icondiscuss}
%\dottedline

%Τερματίζεται το πρόγραμμα όταν εξαντληθούν οι προσπάθειες του παίκτη;

%\marginnote[14pt]{\icondiscuss}
%\dottedline

%\marginnote[10pt]{\iconcaution}
%Είστε βέβαιοι ότι το πρόγραμμα επιτρέπει στον παίκτη να χρησιμοποιήσει \emph{όλες} του τις προσπάθειες; Αν προσθέσετε τις εντολές σε λάθος σημείο τότε πιθανώς το πρόγραμμά σας να στερεί από τον παίκτη μια προσπάθεια!

%Ποια \emph{συνθήκη} θα πρέπει να ισχύει ώστε να \emph{μην} τερματιστεί η επανάληψη με την \pyinline{break} που προσθέσατε;

%\marginnote[14pt]{\icondiscuss}
%\dottedline
%\end{step}

\begin{step}
%\emph{Διαγράψτε} τις εντολές που προσθέσατε στο προηγούμενο βήμα. 
%Αντί για την \pyinline{break}, θα διερευνήσουμε έναν εναλλακτικό (και συχνά προτιμότερο) τρόπο για να τερματίζουμε την επανάληψη όταν εξαντληθούν οι προσπάθειες.

Η \pyinline{while} συνοδεύεται από μια \emph{συνθήκη}. Στην \emph{αρχή} κάθε κύκλου, η συνθήκη αυτή ελέγχεται εκ νέου. Αν η συνθήκη είναι αληθής τότε η επανάληψη συνεχίζεται για άλλον έναν κύκλο. 

Εμείς χρησιμοποιήσαμε μέχρι τώρα την τετριμμένη συνθήκη \pyinline{True}, η οποία είναι πάντα αληθής, γι' αυτό και η επανάληψη δεν διακόπτονταν λόγω της συνθήκης.

\emph{Αντικαταστήστε} την συνθήκη \pyinline{True} με την συνθήκη \pyinline{tries > 0}, που είναι αληθής μόνο όταν απομένουν κι άλλες προσπάθειες στον παίκτη. Σε περίπτωση που αυτό δεν ισχύει, η επανάληψη θα διακοπεί.

\begin{pyplain}
while |\pyhighlight{tries > 0}|:
\end{pyplain}

Εκτελέστε και πάλι το πρόγραμμα και διερευνήστε την συμπεριφορά του. Λειτουργεί σωστά ή εντοπίζετε προβλήματα;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
Για δοκιμαστικούς λόγους, \emph{προσθέστε} αμέσως κάτω από την εντολή \pyinline{tries = tries - 1} τη γραμμή:

\begin{pynew}
print("Ζντονκ!", tries)
\end{pynew}

Εκτελέστε το πρόγραμμα μέχρι να εξαντληθούν οι προσπάθειες. Eμφανίζεται στο τέλος το μήνυμα \pyinline{"Ζντονκ! 0"};

\marginnote[14pt]{\icondiscuss}
\dottedline

Ενώ η συνθήκη της \pyinline{while} είναι \pyinline{tries > 0}, από το μήνυμα φαίνεται ότι η εκτέλεση των εντολών της επανάληψης δεν διακόπτεται \emph{άμεσα} όταν μηδενιστεί η μεταβλητή \pyinline{tries} και η συνθήκη πάψει να ισχύει. Άρα η συνθήκη \pyinline{tries > 0} της \pyinline{while} δεν ελέγχεται συνεχώς αλλά μόνο στην αρχή κάθε νέου κύκλου της επανάληψης.

\emph{Αφαιρέστε} τώρα την εντολή που προσθέσατε.
\end{step}

%\begin{step}
%\begin{question}
%Από ποια σημεία, με ποιους τρόπους και σε ποιες περιπτώσεις γίνεται η έξοδος από την επανάληψη;
%\end{question}
%\end{step}

\begin{step}
Αν ο παίκτης εξαντλήσει τις προσπάθειές του χωρίς να βρει τον αριθμό τότε χάνει και το παιχνίδι σταματά. \emph{Προσθέστε} τις κατάλληλες εντολές στο πρόγραμμα έτσι ώστε, στην περίπτωση αυτή, να εμφανίζει στον παίκτη τον αριθμό που αναζητούσε, για παράδειγμα:

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Ο μυστικός αριθμός ήταν ο 13.
\end{pyterm}

\begin{note}
Ουσιαστικά θα επανεισάγετε την εντολή που αφαιρέσατε στο βήμα~\ref{step:secret-print-remove}, η οποία εμφανίζει τον μυστικό αριθμό. Θα πρέπει να την τοποθετήσετε στο κατάλληλο σημείο του προγράμματος.
\end{note} 

Φροντίστε να εμφανίζεται το μήνυμα \emph{μόνο όταν είναι απαραίτητο}: αν ο παίκτης βρει τον μυστικό αριθμό, τότε το μήνυμα δε χρειάζεται.

Εκτελέστε το πρόγραμμα. Λειτουργεί σωστά στην περίπτωση που ο παίκτης μαντέψει τον αριθμό; Μήπως στο τέλος του παιχνιδιού του εμφανίζει τον μυστικό αριθμό, παρόλο που τον έχει βρει;

\marginnote[14pt]{\icondiscuss}
\dottedline

Σε αυτή την περίπτωση, \emph{διορθώστε} το πρόγραμμα.

Tο πρόγραμμα λειτουργεί σωστά στην περίπτωση που ο παίκτης μαντεύει τον αριθμό \emph{στην τελευταία του προσπάθεια}; Μήπως του εμφανίζει και πάλι τον μυστικό αριθμό, παρόλο που τον έχει βρει;

\marginnote[14pt]{\icondiscuss}
\dottedline

Αν η απάντηση ήταν καταφατική, μάλλον προσπαθείτε να διαπιστώσετε αν ο παίκτης έχασε ελέγχοντας την συνθήκη \pyinline{tries == 0}. Σκεφτείτε όμως: αν ο παίκτης μαντέψει τον αριθμό στην τελευταία του προσπάθεια τότε θα ισχύει ότι \pyinline{tries == 0} όμως ο παίκτης δεν θα έχει χάσει. Χρειάζεται να διορθώσετε το πρόγραμμα ελέγχοντας με \emph{διαφορετική συνθήκη} αν ο παίκτης απέτυχε να μαντέψει τον αριθμό.
\end{step}

\section{Περισσότερη Βοήθεια}

% \setcounter{step}{23}
\begin{step}
Εκτελέστε το πρόγραμμα. Στην πρώτη σας προσπάθεια δοκιμάστε τον αριθμό \pyinline{13}. Ο μυστικός αριθμός είναι μικρότερος ή μεγαλύτερος;

\begin{note}
Αν o μυστικός αριθμός είναι το \pyinline{13}, απλά εκτελέστε και πάλι το πρόγραμμα.
\end{note}

\marginnote[14pt]{\icondiscuss}
\dottedline

Σε ποιο διάστημα θ' αναζητήσετε τώρα τον μυστικό αριθμό, δηλαδή 
ποια είναι η ελάχιστη και ποια η μέγιστη δυνατή τιμή που γνωρίζετε τώρα ότι μπορεί να έχει ο μυστικός αριθμός;
%ποιός είναι ο μικρότερος αριθμός που έχει πλέον νόημα να δοκιμάσετε και ποιός ο μεγαλύτερος;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
\label{step:table}
Στη δεύτερη προσπάθεια, δοκιμάστε έναν αριθμό που ανήκει στο διάστημα που απαντήσατε προηγουμένως. 
%Ποιος ήταν ο αριθμός που δοκιμάσατε και τί απάντηση πήρατε; 
%Ο μυστικός αριθμός είναι μικρότερος ή μεγαλύτερος;
%Σε ποιο διάστημα θ' αναζητήσετε τον αριθμό μετά τη δεύτερη προσπάθεια; 
%\marginnote[14pt]{\icondiscuss}
%\dottedline
Συνεχίστε μέχρι να τελειώσει το παιχνίδι, συμπληρώνοντας τον πίνακα που ακολουθεί. Σημειώστε σε κάθε βήμα τον αριθμό που δοκιμάσατε, την απάντηση του προγράμματος και το διάστημα μέσα στο οποίο ``εγκλωβίσατε'' κάθε φορά τον μυστικό αριθμό. Το διάστημα αυτό ορίζεται από την ελάχιστη (\pyinline{low}) και τη μέγιστη (\pyinline{high}) δυνατή τιμή που έχει νόημα να δοκιμάσετε μετά από κάθε προσπάθεια. %Να δοκιμάζετε κάθε φορά έναν αριθμό που ανήκει στο διάστημα ανάμεσα στα \pyinline{low} και \pyinline{high}.

\marginnote[32pt]{\icondiscuss}
\begin{center}
\begin{tabular}{ccp{52pt}p{52pt}}
%\hline%
αριθμός & ο μυστικός είναι & \pcenter{ελάχιστη} & \pcenter{μέγιστη} \\
\pyinline{number} & \footnotesize{(μικρότερος / μεγαλύτερος)} & \pcenter{\pyinline{low}} & \pcenter{\pyinline{high}} \\\addlinespace[2\parskip]
\pyinline{13} & \dotfill & \dotfill & \dotfill\\\addlinespace[\parskip]
\dotfill & \dotfill & \dotfill & \dotfill\\\addlinespace[\parskip]
\dotfill & \dotfill & \dotfill & \dotfill\\\addlinespace[\parskip]
\dotfill & \dotfill & \dotfill & \dotfill\\%\hline
\end{tabular}
\end{center}

%\marginnote[14pt]{\icondiscuss}
%\dottedline
%\dottedline
\end{step}

\begin{step}
Τώρα θα επεκτείνουμε το πρόγραμμα έτσι ώστε να βοηθάει το χρήστη ακόμα περισσότερο. Θα χρησιμοποιήσουμε δύο μεταβλητές \pyinline{low} και \pyinline{high}, οι οποίες αντιστοιχούν στην ελάχιστη και τη μέγιστη δυνατή τιμή που γνωρίζουμε ότι μπορεί να έχει ο μυστικός αριθμός. 

Στην αρχή του προγράμματος, αποδώστε αρχικές τιμές σε αυτές τις μεταβλητές:

\begin{pynew}
low = 1
high = 32
\end{pynew}

%Τώρα \emph{τροποποιήστε} την εντολή που επιλέγει τον μυστικό αριθμό:
%\begin{pyplain}
%secret = random.randint(|\pyhighlight{low}|,|\pyhighlight{high}|)
%\end{pyplain}
\end{step}

\begin{step}
Αμέσως πριν από την \pyinline{input()} με την οποία το πρόγραμμα διαβάζει από το χρήστη έναν αριθμό, \emph{προσθέστε} μια εντολή που εμφανίζει στο χρήστη τα \pyinline{low} και \pyinline{high}, για να τον βοηθά στην επιλογή του. Για παράδειγμα, αν τα \pyinline{low} και \pyinline{high} είναι αντίστοιχα \pyinline{14} και \pyinline{23}, τότε να εμφανίζει:

\marginnote[24pt]{\iconcomputer}
\begin{pyterm}
Δοκίμασε ανάμεσα στο 14 και το 23.
\end{pyterm}

Εκτελέστε το πρόγραμμα. Υπάρχει κάτι που σας ενοχλεί και φαίνεται να μη δουλεύει σωστά;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
%Όπως φαίνεται κι από τον πίνακα που συμπληρώσατε στο βήμα~\ref{step:table}, ανάλογα με την απάντηση του προγράμματος (μικρότερος ή μεγαλύτερος) μεταβάλλεται \emph{μόνο ένα} από τα δύο άκρα του διαστήματος στο οποίο εγκλωβίζουμε τον μυστικό αριθμό, δηλαδή μόνο μια από τις \pyinline{low} ή \pyinline{high}.

Στο πρόγραμμα \emph{υπάρχει ήδη} μια \pyinline{if} που ελέγχει αν ο μυστικός αριθμός είναι μικρότερος από τον αριθμό του χρήστη:

\begin{pyplain}
    if secret < number:
        print("Ο μυστικός αριθμός είναι μικρότερος.")
\end{pyplain}

Στην περίπτωση αυτή, όπως φαίνεται κι από τον πίνακα που συμπληρώσατε στο βήμα~\ref{step:table}, \emph{μόνο μία} από τις μεταβλητές \pyinline{low} και \pyinline{high} χρειάζεται ν' αλλάξει τιμή. Ποιά από τις δύο;

\marginnote[14pt]{\icondiscuss}
\dottedline

Να \emph{προσθέσετε} σε αυτή την περίπτωση της \pyinline{if} μια εντολή που μεταβάλλει κατάλληλα την τιμή της \pyinline{low} ή της \pyinline{high}. Αν δυσκολευτείτε, ανατρέξτε στον πίνακα που συμπληρώσατε στο βήμα~\ref{step:table}.

Στο πρόγραμμα υπάρχει επίσης μια \pyinline{if} που ελέγχει αν ο μυστικός αριθμός είναι μεγαλύτερος από τον αριθμό του χρήστη:

\begin{pyplain}
    elif secret > number:
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
\end{pyplain}

Να \emph{προσθέσετε} και σε αυτή την περίπτωση την εντολή που μεταβάλλει κατάλληλα την τιμή της \pyinline{low} ή της \pyinline{high}. 

%Σε ποια από τις δύο περιπτώσεις μεταβάλλεται η τιμή της \pyinline{low}; Όταν ο μυστικός αριθμός είναι μικρότερος ή μεγαλύτερος από τον αριθμό που δοκιμάζει ο χρήστης;

%\marginnote[14pt]{\icondiscuss}
%\dottedline

%Να \emph{προσθέσετε} στην αντίθετη περίπτωση την εντολή που μεταβάλλει κατάλληλα την τιμή της \pyinline{high}. 

%\begin{note}
%Προσέξτε, θα χρειαστεί να προσθέσετε \emph{μόνο} μια εντολή.
%\end{note}

%Να \emph{προσθέσετε} μια εντολή που να μεταβάλλει κατάλληλα την τιμή της \pyinline{high}, \emph{όταν αυτό είναι απαραίτητο}. 

%\begin{note}
%Κι εδώ θα χρειαστεί να προσθέσετε \emph{μόνο} μια εντολή.
%\end{note}
\end{step}

\begin{step}
Εκτελέστε το πρόγραμμά σας αρκετές φορές και ελέγξτε το διεξοδικά, για να διαπιστώσετε αν οι τιμές των μεταβλητών \pyinline{low} και \pyinline{high} μεταβάλλονται σωστά.

Λειτουργεί σωστά το πρόγραμμα; Υπάρχει κάποια περίπτωση στην οποία η συμπεριφορά του είναι προβληματική; 

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\begin{step}
\begin{note}
\textbf{Επέκταση}: Το βήμα αυτό είναι προαιρετικό. 
%Προχωρήστε στην υλοποίησή του μόνο εφόσον ο χρόνος επαρκεί.
\end{note}

Εκτελέστε ακόμα μερικές φορές το πρόγραμμα. Δοκιμάστε, ως παίκτης, να δίνετε τιμές που είναι \emph{εκτός των ορίων} που προτείνει το πρόγραμμα. Τί παρατηρείτε; Δημιουργείται πρόβλημα;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Αν υπάρχει πρόβλημα όταν ο χρήστης δίνει τιμές εκτός του διαστήματος που ορίζουν οι \pyinline{low} και \pyinline{high}, προσθέστε τους κατάλληλους ελέγχους στο πρόγραμμα ώστε να διορθωθούν τυχόν σφάλματα.
\end{step}

\section{Δραστηριότητες για Εξάσκηση}

\marginnote[16pt]{\href{http://pythonies.mysch.gr/complete/}{\url{pythonies.mysch.gr/complete}}}%
Για περισσότερη εξάσκηση στις έννοιες που γνωρίσατε σ' αυτό το φύλλο εργασίας, μπορείτε ν' ανατρέξετε στις ασκήσεις των %
Κεφαλαίων \href{http://pythonies.mysch.gr/chapters/craps.pdf}{``Μπαρμπούτι''} και \href{http://pythonies.mysch.gr/chapters/guess.pdf}{``Μάντεψε τον Αριθμό''}.

\end{document}
