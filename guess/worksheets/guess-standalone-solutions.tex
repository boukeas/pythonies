\documentclass[a4paper,11pt,oneside]{book}

\newcommand{\standalone}{}
\input{../../share/tuftelike}
\input{../../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{1}

\usepackage{booktabs}

%%% DOCUMENT START

\begin{document}

\worksheettrue
\solutionstrue
\chapterwabstract{Μάντεψε τον Αριθμό}{}{}{guessColor}{guessColor}

\section{Οδηγίες}

Αρχικά, το πρόγραμμά μας θα δίνει κάποιες οδηγίες στον παίκτη σχετικά με το παιχνίδι.

\begin{step}
Ξεκινήστε το πρόγραμμα με την εντολή:

\begin{pynew}
print("Θα σκεφτώ έναν αριθμό από το 1 μέχρι το 32.")
\end{pynew}

Εκτελέστε το πρόγραμμα και δείτε τι συμβαίνει.

\begin{answer}
Εμφανίζεται στην οθόνη το μήνυμα: 

\terminline{Θα σκεφτώ έναν αριθμό από το 1 μέχρι το 32.}
\end{answer}
\end{step}

\begin{step}
Βασιστείτε στην εντολή του προηγούμενου βήματος και συμπληρώστε το πρόγραμμα με μια ακόμα εντολή, έτσι ώστε να εμφανίζεται στην οθόνη το μήνυμα:

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Εσύ θα προσπαθήσεις να τον μαντέψεις.
\end{pyterm}

\begin{answer}
Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:
	
\begin{pynew}
print("Εσύ θα προσπαθήσεις να τον μαντέψεις.")	
\end{pynew}
\end{answer}

Εκτελέστε ξανά το πρόγραμμα. Τα καταφέρατε;

\begin{answer}
Ναι, εμφανίζεται στην οθόνη και το δεύτερο μήνυμα.
\end{answer}
\end{step}

\begin{step}
\label{step:secret-assign}
Το πρόγραμμά θα ορίζει τώρα τον μυστικό αριθμό. Έστω ότι επιλέγει το τυχερό \pyinline{13}. Προσθέστε την παρακάτω εντολή στο πρόγραμμα:

\begin{pynew}
secret = 13
\end{pynew}

Η \pyinline{secret} είναι μια \emph{μεταβλητή} στην οποία αποθηκεύεται η τιμή του μυστικού αριθμού που επιλέγει το πρόγραμμά μας. 

Τώρα μπορούμε να αναφερόμαστε στον μυστικό αριθμό με το όνομα \pyinline{secret}, χωρίς να έχει σημασία ποια είναι η τιμή του.

Εκτελέστε το πρόγραμμα. Παρατηρείτε κάποια διαφορά στην εκτέλεση μετά την προσθήκη της παραπάνω εντολής;

\begin{answer}
Όχι, δεν υπάρχει διαφορά στην εκτέλεση του προγράμματος. Η ανάθεση τιμής σε ένα όνομα γίνεται από τον προγραμματιστή και δεν είναι ``ορατή'' στον χρήστη. Ο χρήστης δεν γνωρίζει τα ονόματα και τις τιμές των μεταβλητών που χρησιμοποιούνται σε ένα πρόγραμμα. Ο προγραμματιστής επιλέγει να εμφανίσει την τιμή κάποιας μεταβλητής χρησιμοποιώντας το όνομά της μαζί με την \pyinline{print}.
\end{answer}
\end{step}

\section{Γνωριμίες}
Το πρόγραμμά μας θα ζητά από τον παίκτη το όνομά του και θα τον καλωσορίζει στο παιχνίδι.

\begin{step}
\label{step:name-input}
\emph{Προσθέστε} τις παρακάτω εντολές οπουδήποτε στο πρόγραμμα.

\begin{pynew}
print("Πώς σε λένε;")
player = input()
\end{pynew}

Η \pyinline{input()} επιστρέφει το κείμενο που πληκτρολόγησε ο χρήστης, δηλαδή επιστρέφει πάντα μια \emph{αλφαριθμητική τιμή}. Στην συγκεκριμένη περίπτωση, χρησιμοποιούμε την \pyinline{input()} για να διαβάσουμε την απάντηση του χρήστη, η οποία αποθηκεύεται στη μεταβλητή \pyinline{player}.

Εκτελέστε το πρόγραμμα. Η μεταβλητή \pyinline{player} παίρνει την τιμή που πληκτρολογείτε (αναλαμβάνοντας το ρόλο του χρήστη πλέον).
\end{step}

\begin{step}
\label{step:print-variable}
Συμπληρώστε το πρόγραμμα με την παρακάτω εντολή.

\begin{pynew}
print("Γεια σου", player)
\end{pynew}

Εκτελέστε το πρόγραμμα σας 2--3 φορές, παίζοντας το ρόλο του χρήστη, πληκτρολογήστε κάθε φορά διαφορετικά ονόματα και παρατηρήστε τι εμφανίζει.

\begin{answer}
Το πρόγραμμα εμφανίζει το μήνυμα \terminline{Γεια σου} ακολουθούμενο από το όνομα που πληκτρολόγησε κάθε φορά ο παίκτης.
\end{answer}

Ποια πιστεύετε ότι θα ήταν η διαφορά αν είχατε πληκτρολογήσει \pyinline{print("Γεια σου player")};

\begin{answer}
Θα εμφανίζονταν στην οθόνη το μήνυμα \terminline{Γεια σου player}. Οτιδήποτε βρίσκεται μέσα σε εισαγωγικά αποτελεί μια αλφαριθμητική τιμή, δηλαδή κείμενο, και δεν αφορά ονόματα μεταβλητών.
\end{answer}

Ποια θα ήταν η διαφορά αν αντί της εντολής \pyinline{player = input()} χρησιμοποιούσαμε την εντολή \pyinline{player = "Μυρσίνη"};

\begin{answer}
	Η μεταβλητή \pyinline{player} θα ήταν καθορισμένη από τον προγραμματιστή και όχι από τον χρήστη και θα είχε σε κάθε εκτέλεση του προγράμματος την τιμή \terminline{"Μυρσίνη"}.
\end{answer}

Ποια θα ήταν η διαφορά αν στο βήμα~\ref{step:secret-assign} γράφαμε \pyinline{secret = input()}, αντί για \pyinline{secret = 13};

\begin{answer}
Ο χρήστης θα καθόριζε την τιμή της \pyinline{secret}, ανάλογα με το τι θα πληκτρολογούσε σε κάθε εκτέλεση του προγράμματος. Η μεταβλητή \pyinline{secret} δεν θα είχε απαραίτητα την τιμή \pyinline{13}. 
\end{answer}
\end{step}

\section{Φρέναρε λίγο}

Το πρόγραμμά μας εμφανίζει όλα τα μηνύματα μαζεμένα. Θα δώσουμε μια ανάσα στον παίκτη, ώστε να προλαβαίνει να τα διαβάζει έχοντας λίγο χρόνο στη διάθεσή του, πριν του εμφανίσουμε το επόμενο μήνυμα. 

Στο σημείο αυτό θα χρειαστούμε μια λειτουργία που δεν προσφέρεται από τις βασικές εντολές της Python. Για το σκοπό αυτό θα χρειαστεί να εισάγουμε στο πρόγραμμά μας μια βιβλιοθήκη και συγκεκριμένα τη βιβλιοθήκη \pyinline{time}, η οποία παρέχει τη λειτουργικότητα που μας χρειάζεται. Οι βιβλιοθήκες είναι συλλογές από μικρά προγράμματα που μπορούμε να χρησιμοποιήσουμε στα προγράμματά μας.

\begin{step}
\emph{Προσθέστε στην αρχή του προγράμματος} την εντολή που ακολουθεί, για να \emph{εισάγετε} τη βιβλιοθήκη \pyinline{time}:

\begin{pynew}
import time
\end{pynew}
\end{step}

\begin{step}
Εισάγετε, ανάμεσα στις δύο πρώτες \pyinline{print}, την παρακάτω εντολή:

\begin{pynew}
time.sleep(1)
\end{pynew}

Με την εντολή αυτή χρησιμοποιείται η \emph{συνάρτηση} \pyinline{sleep} από τη βιβλιοθήκη \pyinline{time}. 
Τί αποτέλεσμα έχει η προσθήκη αυτής της εντολής;

\begin{answer}
	Εισάγεται μια καθυστέρηση ανάμεσα στην εμφάνιση των δύο μηνυμάτων.
\end{answer}

Tί ρόλο παίζει η \emph{παράμετρος} \pyinline{1}; Διερευνήστε τι θα συμβεί αν χρησιμοποιήσουμε άλλον αριθμό στη θέση του \pyinline{1}.

\begin{answer}
Η παράμετρος \pyinline{1} καθορίζει ότι θα υπάρχει μια καθυστέρηση ενός δευτερολέπτου. Αν χρησιμοποιήσουμε άλλον αριθμό στη θέση του \pyinline{1} θα αλλάξει η περίοδος της χρονικής καθυστέρησης.
\end{answer}
\end{step}

\section{Ας παίξουμε}

Ήρθε η ώρα να ξεκινήσει το πραγματικό παιχνίδι. Το πρόγραμμά θα ζητά από τον παίκτη έναν αριθμό και στη συνέχεια θα εμφανίζει μήνυμα αν βρήκε τον μυστικό αριθμό ή όχι.

\begin{step}
\label{step:number-input}
\emph{Προσθέστε} τις παρακάτω εντολές στο πρόγραμμα:

\begin{pynew}
print("Δώσε αριθμό:")
number = int(input())
\end{pynew}

Τι διαφορά παρατηρείτε σε σχέση με τις εντολές που χρησιμοποιήσατε για να ζητήσετε το όνομα του παίκτη στο βήμα~\ref{step:name-input};

\begin{answer}
Χρησιμοποιούμε την \pyinline{int()} μαζί με την \pyinline{input()}. Το αποτέλεσμα που επιστρέφεται από την \pyinline{input()}, δηλαδή το κείμενο που πληκτρολόγησε ο χρήστης, δίνεται στη συνέχεια στην \pyinline{int()} για να το επεξεργαστεί (δες σχετικά την απάντηση στην επόμενη ερώτηση).
\end{answer}

Ποια διαφορά πιστεύετε ότι έχει η τιμή του ονόματος του παίκτη από την τιμή του \pyinline{number};

\begin{answer}
Η τιμή του \pyinline{number} είναι αριθμητική και όχι αλφαριθμητική, όπως είναι το όνομα του παίκτη. Επειδή η τιμή που επιστρέφει η \pyinline{input()} είναι αλφαριθμητική είναι απαραίτητο να την μετατρέψουμε σε ακέραιο αριθμό, κάτι που επιτυγχάνεται με τη βοήθεια της \pyinline{int()}.
\end{answer}
\end{step}

\begin{step}
Συμπληρώστε το πρόγραμμα, ώστε να εμφανίζει στον παίκτη τον αριθμό που πληκτρολόγησε, για παράδειγμα:

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Έδωσες τον αριθμό 20
\end{pyterm}

Αν δυσκολευτείτε, ανατρέξτε στο βήμα~\ref{step:print-variable}.
%, όπου γίνεται κάτι ανάλογο.

\begin{answer}
Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:
	
\begin{pynew}
print("Έδωσες τον αριθμό", number)
\end{pynew}
\end{answer}
\end{step}

\begin{step}

\emph{Προσθέστε} στο πρόγραμμα σας τις εντολές: %που θα εμφανίζουν αυτά τα μηνύματα:

\begin{pynew}
print("Σωστά!")
print("Λάθος...")
\end{pynew}

Τι \emph{πιστεύετε} ότι θα εμφανίσει το πρόγραμμα αν το εκτελέσουμε τώρα;

\begin{answer}
Θα εμφανίζονται και τα δύο μηνύματα. Και το \terminline{Σωστά!} και το \terminline{Λάθος}, αφού θα εκτελούνται σε κάθε περίπτωση και οι δύο εντολές.
\end{answer}

Εκτελέστε το πρόγραμμα. Επιβεβαιώνεται η απάντησή σας;

\begin{answer}
	Ναι, επιβεβαιώνεται.
\end{answer}

Σε ποια περίπτωση είναι επιθυμητό να εμφανίζεται το \pyinline{"Σωστά!"}; Αντίστοιχα, σε ποια περίπτωση είναι επιθυμητό να εμφανίζεται το \pyinline{"Λάθος..."};

\begin{answer}
	Το μήνυμα \terminline{Σωστά!} πρέπει να εμφανίζεται στην περίπτωση που ο αριθμός που πληκτρολόγησε ο χρήστης είναι ίδιος με το μυστικό αριθμό. Στην αντίθετη περίπτωση πρέπει να εμφανίζεται το μήνυμα \terminline{Λάθος}.
\end{answer}
\end{step}

\begin{step}
Θα τροποποιήσουμε το πρόγραμμά μας, έτσι ώστε να \emph{ελέγχει} αν ο παίκτης μάντεψε τον μυστικό αριθμό και στη συνέχεια να εμφανίζει \emph{μόνο} το κατάλληλο μήνυμα.

\emph{Προσθέστε} τις παρακάτω εντολές:

%\marginnote{Με το \pyinline{!=} ελέγχεται αν δύο τιμές είναι διαφορετικές.}
\marginnote[18pt]{Με το \pyinline{==} ελέγχεται αν δύο τιμές είναι ίσες. Μην το συγχέετε με το \pyinline{=} που χρησιμοποιείται για να δώσουμε τιμή σε μια μεταβλητή.}
\begin{pynew}
if number == secret:
\end{pynew}
\begin{pyplain}
print("Σωστά!")
\end{pyplain}
\begin{pynew}
else:
\end{pynew}
\begin{pyplain}
print("Λάθος...")
\end{pyplain}

\marginnote[14pt]{\iconcaution}
Εκτελέστε το πρόγραμμα. Παρατηρήστε το \emph{σφάλμα} που εμφανίζει.

Στις περισσότερες γλώσσες προγραμματισμού δεν θα αντιμετωπίζατε κάποιο πρόβλημα, όμως η Python έχει μια ``ευαισθησία'': Οι εντολές που εκτελούνται στη μία ή στην άλλη περίπτωση πρέπει να \emph{ξεχωρίζουν}, πρέπει με κάποιον τρόπο να επισημανθεί ότι οι εντολές αυτές \emph{ανήκουν} αντίστοιχα στην \pyinline{if} και την \pyinline{else}. 

Στην Python, αυτό επιτυγχάνεται με τις \emph{εσοχές}.
\end{step}

\begin{step}
\emph{Προσθέστε} 4 κενά πριν από τις δύο \pyinline{print} και εκτελέστε το πρόγραμμα.

\begin{pyplain}
if secret == number:
|\pyhighlight{\vphantom{λρ}    }|print("Σωστά!")
else:
|\pyhighlight{\vphantom{λρ}    }|print("Λάθος...")
\end{pyplain}

Εκτελέστε το πρόγραμμα σας δύο φορές. Στην πρώτη δώστε σωστά τον μυστικό αριθμό, ενώ στην επόμενη δώστε έναν διαφορετικό.

Εμφανίζεται το κατάλληλο μήνυμα σε κάθε περίπτωση;

\begin{answer}
	Ναι. Όταν ο αριθμός που δίνουμε είναι ίσος με το μυστικό, δηλαδή \pyinline{13}, τότε το πρόγραμμα εμφανίζει το μήνυμα \terminline{Σωστά}, ενώ σε κάθε άλλη περίπτωση εμφανίζει το μήνυμα \terminline{Λάθος}.
\end{answer}

Σε ποια περίπτωση εκτελούνται οι εντολές της else;

\begin{answer}
	Όταν ο αριθμός που πληκτρολογεί ο χρήστης δεν είναι ίδιος με το μυστικό αριθμό.
\end{answer}
\end{step}

\begin{step}
\label{step:secret-print}

\emph{Προσθέστε} στο πρόγραμμα μια \pyinline{print}, η οποία θα εμφανίζει τον μυστικό αριθμό στην περίπτωση που ο παίκτης απαντήσει λάθος, όπως παρακάτω:

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Ο μυστικός αριθμός ήταν ο 13.
\end{pyterm}

\begin{answer}
Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:
	
\begin{pynew}
    print("Ο μυστικός αριθμός ήταν ο", secret)
\end{pynew}
\end{answer}

Εκτελέστε το πρόγραμμα δύο φορές. Στην πρώτη δώστε σωστά τον μυστικό αριθμό, ενώ στην επόμενη δώστε έναν διαφορετικό.

Εμφανίζει το μυστικό αριθμό \emph{μόνο} στην περίπτωση που ο παίκτης δεν τον μαντέψει; Αν όχι, γιατί πιστεύετε ότι συμβαίνει αυτό;

\begin{answer}
	Η εντολή πρέπει να προστεθεί μέσα στην \pyinline{else}, επομένως πρέπει να προηγηθούν τέσσερα κενά, ώστε να δημιουργηθεί η κατάλληλη εσοχή. Σε διαφορετική περίπτωση θα εκτελείται ανεξάρτητα από τον αν ο παίκτης μαντέψει το μυστικό αριθμό.
\end{answer}

\marginnote[16pt]{\iconcaution}
Αν ο μυστικός αριθμός εμφανίζεται είτε ο χρήστης τον μαντέψει, είτε όχι, τότε πιθανότατα δεν τοποθετήσατε τη νέα εντολή \emph{μέσα} στην \pyinline{else}, αλλά μετά από αυτή. Προσθέστε 4 κενά πριν την εντολή, για να υποδηλώσετε ότι κι αυτή ανήκει στην \pyinline{else}.
\end{step}

\begin{step}
Στο μήνυμα που εμφανίσατε προηγουμένως χρησιμοποιήσατε την μεταβλητή \pyinline{secret};

\begin{answer}
	Ναι.
\end{answer}

Αν απαντήσατε όχι, \emph{τροποποιήστε} κατάλληλα την εντολή \pyinline{print}, ώστε να χρησιμοποιεί τη \pyinline{secret} και όχι το \pyinline{13}.

Τι πλεονέκτημα πιστεύετε ότι έχει η χρήση της μεταβλητής \pyinline{secret} στο μήνυμα, αντί της απευθείας εμφάνισης του αριθμού \pyinline{13};

\begin{answer}
	Αν δεν χρησιμοποιήσουμε τη μεταβλητή \pyinline{secret} η \pyinline{print()} θα εμφανίζει πάντα ακριβώς το ίδιο, σταθερό μήνυμα, ενώ αν χρησιμοποιήσουμε τη μεταβλητή \pyinline{secret} η \pyinline{print()} θα εμφανίζει την τιμή της, η οποία εδώ είναι \pyinline{13}, αλλά θα μπορούσε να είναι διαφορετική.
\end{answer}

Δοκιμάστε να παίξετε 2--3 φορές ακόμα. Υπάρχει κάτι που σας ενοχλεί στον τρόπο που λειτουργεί το πρόγραμμα;

\begin{answer}
	Μετά από λίγες εκτελέσεις ο παίκτης θα αντιληφθεί ότι ο μυστικός αριθμός είναι πάντα το \pyinline{13}.
\end{answer}
\end{step}

\section{Τυχαιότητα}

Το παιχνίδι μας δεν αξίζει να το παίξεις πάνω από μία-δύο φορές, αν ο μυστικός αριθμός είναι πάντα το \pyinline{13}. Αυτό που πραγματικά χρειαζόμαστε είναι να επιλέγεται κάθε φορά ένας διαφορετικός αριθμός.

% [comment][review] Υπάρχουν σχόλια που έχεις κάνει στο guess-worksheet, όπως εδώ το "πραγματικά" και ισχύουν και για εδώ. Πρέπει να τα μεταφέρουμε; [update] το σημείωσα, στοχευμένο commit για την "ομογενοποίηση" των φύλλων εργασίας.

Για τον σκοπό αυτό, θα χρειαστούμε τη βιβλιοθήκη \pyinline{random}, όπως προηγουμένως είχαμε χρησιμοποιήσει τη βιβλιοθήκη \pyinline{time}. 

\begin{step}
\label{step:secret-random}
\emph{Προσθέστε} στο πρόγραμμα την εντολή εισαγωγής της βιβλιοθήκης \pyinline{random}.

\begin{pynew}
import random
\end{pynew}

\emph{Τροποποιήστε} την εντολή του βήματος~\ref{step:secret-assign}, όπου ορίζεται η τιμή της μεταβλητής \pyinline{secret}, ως εξής:

\begin{pyplain}
secret = |\pyhighlight{random.randint(1,32)}|
\end{pyplain}

Εκτελέστε το πρόγραμμα αρκετές φορές. Τί είδους τιμές παρατηρείτε ότι παίρνει η μεταβλητή \pyinline{secret};

\begin{answer}
	Η \pyinline{secret} παίρνει τυχαίες τιμές.
\end{answer}

Ποιος πιστεύετε ότι είναι ο ρόλος των παραμέτρων \pyinline{1} και \pyinline{32}; Τί συμβαίνει αν δοκιμάσετε άλλες τιμές στη θέση τους, για παράδειγμα \pyinline{33} και \pyinline{64}; Αν χρειαστεί εκτελέστε πάλι το πρόγραμμα αρκετές φορές προκειμένου να απαντήσετε στην ερώτηση.

\begin{answer}
	Οι παράμετροι \pyinline{1} και \pyinline{32} καθορίζουν το διάστημα στο οποίο βρίσκεται η τυχαία τιμή. Αν χρησιμοποιήσουμε άλλους αριθμούς για παράδειγμα \pyinline{33} και \pyinline{64}, η τυχαία τιμή θα βρίσκεται μεταξύ των αριθμών \pyinline{33} και \pyinline{64}, συμπεριλαμβανομένων αυτών.
\end{answer}
\end{step}

\begin{step}
Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\begin{answer}
	Ο παίκτης έχει μόνο μια ευκαιρία να μαντέψει το μυστικό αριθμό. Θα θέλαμε το πρόγραμμα να εκτελείται επαναληπτικά, ώστε να έχει περισσότερες ευκαιρίες στη διάθεσή του.
\end{answer}
\end{step}

\section{Γύρω-Γύρω Όλοι}

\begin{step}
\emph{Προσθέστε} τη γραμμή που ακολουθεί \emph{αμέσως πριν} από τις εντολές που προσθέσατε στο βήμα~\ref{step:number-input}, όπου ζητείται από το χρήστη να μαντέψει τον μυστικό αριθμό.

\begin{pynew}
while True:
\end{pynew}

\emph{Προσθέστε} τέσσερα κενά μπροστά από \emph{όλες τις εντολές που ακολουθούν} τη \pyinline{while}, σηματοδοτώντας έτσι ότι αυτές οι εντολές \emph{εμφωλεύονται} στη \pyinline{while}, δηλαδή περιέχονται σε αυτήν.

Εκτελέστε το πρόγραμμα. Ποια αλλαγή παρατηρείτε ότι επιφέρει η χρήση της \pyinline{while};

\begin{answer}
	Οι εντολές που βρίσκονται μέσα στη \pyinline{while} εκτελούνται ξανά και ξανά.
\end{answer}

Η εντολή του βήματος~\ref{step:secret-random}, που δίνει μια τυχαία τιμή στην μεταβλητή \pyinline{secret}, βρίσκεται \emph{πριν} από τη \pyinline{while}. Ποια πιστεύετε ότι θα ήταν η διαφορά αν βρισκόνταν \emph{μέσα} στη \pyinline{while};

\begin{answer}
Σε κάθε γύρο του παιχνιδιού ο μυστικός αριθμός θα ήταν διαφορετικός, αφού η εντολή \pyinline{secret = random.randint(1,32)} θα εκτελούνταν σε κάθε επανάληψη, αποδίδοντας κάθε φορά μια νέα τυχαία τιμή στο μυστικό αριθμό.
\end{answer}

\label{step:secret-print-remove}
Η εντολή του βήματος~\ref{step:secret-print} που εμφανίζει τον μυστικό αριθμό στο χρήστη τώρα δημιουργεί πρόβλημα. Γιατί;

\begin{answer}
Γιατί μετά την πρώτη αποτυχημένη προσπάθεια το πρόγραμμα εμφανίζει το μυστικό αριθμό στην οθόνη, επομένως στον επόμενο γύρο ο παίκτης θα γνωρίζει το μυστικό αριθμό και δεν θα χρειαστεί και πολλή προσπάθεια να τον μαντέψει!
\end{answer}

\emph{Διαγράψτε} την εντολή που εμφανίζει τον μυστικό αριθμό.

Παίξτε το παιχνίδι μέχρι να μαντέψετε τον μυστικό αριθμό. Υπάρχει κάτι που σας ενοχλεί; Κάτι που φαίνεται να μη δουλεύει σωστά;

\begin{answer}
	Όταν ο παίκτης μαντέψει το μυστικό αριθμό το παιχνίδι συνεχίζεται, ενώ θα έπρεπε να σταματά.
\end{answer}
\end{step}

\begin{step}
Η εντολή \pyinline{break} διακόπτει την επανάληψη μέσα στην οποία βρίσκεται \emph{αμέσως} μόλις εκτελεστεί.
\emph{Προσθέστε} την \pyinline{break} στο σημείο που θεωρείτε κατάλληλο, έτσι ώστε το παιχνίδι να τερματίζεται όταν ο παίκτης μαντέψει τον αριθμό.

Παίξτε και πάλι το παιχνίδι μέχρι να μαντέψετε τον μυστικό αριθμό, για να επιβεβαιώσετε ότι τοποθετήσατε την \pyinline{break} σε σωστό σημείο.

\begin{answer}
	Η εντολή \pyinline{break} πρέπει να προστεθεί μέσα στην \pyinline{if}, στην περίπτωση που ο παίκτης μαντέψει σωστά το μυστικό αριθμό, αφού τότε πρέπει να τερματιστεί η επανάληψη.

\begin{pyplain}
    if number == secret:
        print("Σωστά!")
\end{pyplain}
\begin{pynew}
        break
\end{pynew}
\begin{pyplain}
    else:	
        print("Λάθος...")
\end{pyplain}
\end{answer}
\end{step}

\begin{step}
Για δοκιμαστικούς λόγους, κάτω από την \pyinline{break} \emph{προσθέστε} την εντολή:

\begin{pynew}
print("Ζντονκ!")
\end{pynew}

Εκτελέστε πάλι το πρόγραμμα μέχρι να μαντέψετε τον αριθμό. Εμφανίζεται το μήνυμα \pyinline{"Ζντονκ!"}; Γιατί πιστεύετε ότι συμβαίνει αυτό;

\begin{answer}
	Το μήνυμα δεν εμφανίζεται, αφού η εκτέλεση της εντολής \pyinline{break} προκαλεί την άμεση έξοδο από την επανάληψη. Επομένως, οι εντολές που την ακολουθούν δεν θα εκτελεστούν ποτέ.
\end{answer}

\emph{Αφαιρέστε} τώρα την εντολή που προσθέσατε.
\end{step}

\begin{step}
Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\begin{answer}
	Προς το παρόν ο παίκτης μαντεύει στα τυφλά. Μια προσθήκη που θα τον βοηθούσε είναι να ενημερώνεται από το πρόγραμμα αν ο μυστικός αριθμός είναι μικρότερος ή μεγαλύτερος από αυτόν που έδωσε.
\end{answer}
\end{step}

\section{Επιλογές, Επιλογές}

Θα επεκτείνουμε το πρόγραμμα έτσι ώστε να δίνει στο χρήστη περισσότερη πληροφορία: αντί να τον ενημερώνει απλά αν βρήκε τον μυστικό αριθμό ή όχι, θα τον κατευθύνει αν πρέπει να τον αναζητήσει ψηλότερα ή χαμηλότερα.

Για την επέκταση αυτή δεν αρκεί πια η απλή \pyinline{if}--\pyinline{else}, η οποία μπορεί να διακρίνει μόνο ανάμεσα σε δύο περιπτώσεις. 

\begin{step}
\emph{Τροποποιήστε} την \pyinline{if} που ελέγχει αν ο χρήστης βρήκε τον μυστικό αριθμό. Συμπληρώσετε την συνθήκη που λείπει:

\begin{pyplain}
    if secret == number:
        print("Σωστά!")
        break
\end{pyplain}
\begin{pynew}
    elif |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
    else:
        print("Ο μυστικός αριθμός είναι μικρότερος.")
\end{pynew}

\begin{answer}[]
Η συνθήκη που θα συμπληρώσουμε είναι:

\begin{pyplain}
elif |\pyhighlight{secret > number}|:
\end{pyplain}

ώστε το πρόγραμμα να ελέγχει αν ο μυστικός αριθμός είναι μεγαλύτερος από τον αριθμό που έδωσε ο χρήστης.
\end{answer}

Εκτελέστε το πρόγραμμα και βεβαιωθείτε ότι λειτουργεί σωστά. 

Σε ποια περίπτωση εκτελούνται οι εντολές της \pyinline{else}; Γιατί πιστεύετε ότι δεν ελέγχουμε καμία συνθήκη σε αυτή την τρίτη περίπτωση;

\clearpage
\begin{answer}
	Οι εντολές της \pyinline{else} εκτελούνται όταν ο μυστικός αριθμός είναι μικρότερος από τον αριθμό που έδωσε ο παίκτης. Δεν ελέγχουμε κάποια συνθήκη, αφού αυτή είναι η μοναδική, εναλλακτική περίπτωση.
\end{answer}
\end{step}

\begin{step}
\emph{Αναδιατάξτε} τις περιπτώσεις της \pyinline{if} όπως φαίνεται παρακάτω. Και πάλι, θα πρέπει να συμπληρώσετε τις συνθήκες που ελέγχονται σε κάθε περίπτωση.

\begin{pynew}
    if |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
        print("Ο μυστικός αριθμός είναι μικρότερος.")
    elif |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
    else:
        print("Σωστά!")
        break
\end{pynew}

\begin{answer}[]
Η συνθήκη που θα συμπληρώσουμε στην \pyinline{if} είναι:

\begin{pyplain}
if |\pyhighlight{secret < number}|:
\end{pyplain}
		
Η συνθήκη που θα συμπληρώσουμε στην \pyinline{elif} είναι:	

\begin{pyplain}
elif |\pyhighlight{secret > number}|:
\end{pyplain}
\end{answer}
\end{step}

\begin{step}
Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\begin{answer}
Ο παίκτης έχει απεριόριστο αριθμό προσπαθειών, οπότε κάποια στιγμή θα μαντέψει το μυστικό αριθμό. Θα πρέπει να θέσουμε έναν μέγιστο αριθμό προσπαθειών προκειμένου να τα καταφέρει.
\end{answer}
\end{step}

\section{Μέτρημα}

Ο αριθμός των προσπαθειών που διαθέτει ο παίκτης δεν θα έπρεπε να είναι απεριόριστος. Θα επεκτείνουμε το παιχνίδι ώστε να τερματίζεται όταν εξαντληθούν οι προσπάθειες του παίκτη.

\begin{step}
\label{step:tries-print}
\emph{Προσθέστε} την εντολή που ακολουθεί αμέσως μετά τη \pyinline{while}, δηλαδή στην αρχή της επανάληψης.

\begin{pynew}
print("Απομένουν", tries, "προσπάθειες.")
\end{pynew}

Είναι εμφανές ότι η τιμή της μεταβλητής \pyinline{tries} θα αντιστοιχεί στο πλήθος των προσπαθειών που απομένουν στον παίκτη. 

\marginnote[16pt]{\iconcaution}
Αν εκτελέσετε το πρόγραμμα όπως έχει θα εμφανιστεί μήνυμα λάθους, αφού επιχειρούμε να εμφανίσουμε την τιμή της \pyinline{tries}, χωρίς πουθενά προηγουμένως να της έχουμε αποδώσει μια τιμή.

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
NameError: name 'tries' is not defined
\end{pyterm}
\end{step}

\begin{step}
\label{step:tries-init}
Δώστε στην \pyinline{tries} μια αρχική τιμή, ίση με το πλήθος των προσπαθειών που διαθέτει ο χρήστης όταν ξεκινά το παιχνίδι. Αποφασίστε εσείς μια τιμή που να σας φαίνεται ``δίκαιη''.

\begin{answer}
	Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:
	
	\begin{pynew}
tries = 4
	\end{pynew}
	
	δεδομένου ότι θα δώσουμε το πολύ τέσσερεις προσπάθειες στον παίκτη.
\end{answer}

Τοποθετήσατε τις νέες εντολές \emph{πριν} την επανάληψη ή \emph{μέσα} σε αυτή; Για ποιο λόγο κάνατε αυτή την επιλογή;

\begin{answer}
	Η εντολή πρέπει να προστεθεί πριν από τη \pyinline{while}, ώστε η εκτέλεσή της να γίνει μόνο μια φορά. Διαφορετικά, οι προσπάθειες του παίκτη θα παίρνουν σε κάθε επανάληψη και πάλι την τιμή \pyinline{4} αντί να μειώνονται.
\end{answer}

Ποιο είναι το αρχικό πλήθος προσπαθειών που δώσατε στον παίκτη και γιατί θεωρήσατε αυτή την τιμή ``δίκαιη''.

\begin{answer}
	Εφόσον ο παίκτης ακολουθήσει τη στρατηγική της διαίρεσης του εκάστοτε διαστήματος στη μέση, επιλέγοντας για παράδειγμα το \pyinline{16} αρχικά και στη συνέχεια το μισό του διαστήματος που απομένει και ούτω καθεξής, θα χρειαστεί το πολύ \pyinline{5} προσπάθειες για να μαντέψει τον μυστικό αριθμό. Δίνοντας του \pyinline{4} προσπάθειες προσθέτουμε στο παιχνίδι το στοιχείο της τυχαιότητας, κάνοντας το πιο δίκαιο.
\end{answer}

Εκτελέστε το πρόγραμμα. Τί παρατηρείτε;

\begin{answer}
	Ο αριθμός των προσπαθειών δεν μειώνεται σε κάθε επανάληψη.
\end{answer}
\end{step}

\begin{step}
Η μεταβλητή \pyinline{tries} θα πρέπει να μειώνεται σε κάθε γύρο του παιχνιδιού, δηλαδή \emph{εντός της επανάληψης}. Μετά την \pyinline{print} του βήματος~\ref{step:tries-print} που εμφανίζει την τιμή της \pyinline{tries}, \emph{προσθέστε} τη γραμμή:

\begin{pynew}
    tries = tries - 1
\end{pynew}

Εκτελέστε το πρόγραμμα. Μειώνεται το πλήθος των προσπαθειών που απομένουν στον παίκτη;

\begin{answer}
	Ναι. Στην οθόνη εμφανίζεται σε κάθε γύρο ο νέος, μειωμένος αριθμός προσπαθειών.
\end{answer}

%\marginnote[14pt]{\icondiscuss}
%\dottedline
\marginnote[14pt]{\iconcaution}
Αν το πλήθος των προσπαθειών δεν μειώνεται, βεβαιωθείτε ότι η εντολή που προσθέσατε στο βήμα~\ref{step:tries-init} και δίνει αρχική τιμή στην \pyinline{tries} βρίσκεται \emph{πριν} από την επανάληψη και όχι μέσα σε αυτή.

Περιγράψτε πως ακριβώς πιστεύετε ότι λειτουργεί η εντολή που προσθέσατε για να μειώνεται η \pyinline{tries}.

\begin{answer}
	Σε κάθε γύρο του παιχνιδιού ο αριθμός των προσπαθειών μειώνεται κατά \pyinline{1}. Αυτό επιτυγχάνεται ως εξής: υπολογίζεται η τιμή της παράστασης \pyinline{tries - 1} και το αποτέλεσμα ονομάζεται πάλι \pyinline{tries}. Η νέα τιμή της μεταβλητής \pyinline{tries} υπολογίζεται με βάση την τρέχουσα τιμή της, την οποία και αντικαθιστά. Επομένως, θα πάρει διαδοχικά τις τιμές \pyinline{3}, \pyinline{2}, \pyinline{1} και \pyinline{0}, δεδομένου ότι ο παίκτης δεν θα μαντέψει το μυστικό αριθμό.
\end{answer}

Υπάρχει κάτι που σας ενοχλεί και φαίνεται να μη δουλεύει σωστά;

\begin{answer}
	Το παιχνίδι δεν τερματίζει όταν οι προσπάθειες μηδενιστούν. Αντίθετα, συνεχίζει δίνοντας αρνητικές τιμές στη μεταβλητή \pyinline{tries}.
\end{answer}
\end{step}
 
\section{Τερματισμός}

Το παιχνίδι δεν πρέπει να τερματίζεται μόνο όταν ο παίκτης μαντέψει τον αριθμό, αλλά και όταν τελειώσουν οι προσπάθειές του.

\begin{step}
Η \pyinline{while} συνοδεύεται από μια \emph{συνθήκη}. Στην \emph{αρχή} κάθε κύκλου, η συνθήκη αυτή ελέγχεται εκ νέου. Αν η συνθήκη είναι αληθής τότε η επανάληψη συνεχίζεται για άλλον έναν κύκλο. 

Εμείς χρησιμοποιήσαμε μέχρι τώρα την τετριμμένη συνθήκη \pyinline{True}, η οποία είναι πάντα αληθής, γι' αυτό και η επανάληψη δεν διακόπτονταν λόγω της συνθήκης.

\emph{Αντικαταστήστε} τη συνθήκη \pyinline{True} με τη συνθήκη \pyinline{tries > 0}, που είναι αληθής μόνο όταν απομένουν κι άλλες προσπάθειες στον παίκτη. Σε περίπτωση που αυτό δεν ισχύει, η επανάληψη θα διακοπεί.

\begin{pyplain}
while |\pyhighlight{tries > 0}|:
\end{pyplain}

Εκτελέστε και πάλι το πρόγραμμα και διερευνήστε τη συμπεριφορά του. Λειτουργεί σωστά ή εντοπίζετε προβλήματα;

\begin{answer}
	Ναι, λειτουργεί σωστά. Παρατηρούμε ότι όταν ο παίκτης δεν μαντέψει τον αριθμό το πολύ σε τέσσερεις προσπάθειες, τότε το παιχνίδι σταματά.
\end{answer}
\end{step}

\begin{step}
Για δοκιμαστικούς λόγους, \emph{προσθέστε} αμέσως κάτω από την εντολή \pyinline{tries = tries - 1} τη γραμμή:

\begin{pynew}
print("Ζντονκ!", tries)
\end{pynew}

Εκτελέστε το πρόγραμμα μέχρι να εξαντληθούν οι προσπάθειες. Eμφανίζεται στο τέλος το μήνυμα \pyinline{"Ζντονκ! 0"};

\begin{answer}
	Ναι, εμφανίζεται.
\end{answer}

Ενώ η συνθήκη της \pyinline{while} είναι \pyinline{tries > 0}, από το μήνυμα φαίνεται ότι η εκτέλεση των εντολών της επανάληψης δεν διακόπτεται \emph{άμεσα} όταν μηδενιστεί η μεταβλητή \pyinline{tries} και η συνθήκη πάψει να ισχύει. Άρα η συνθήκη \pyinline{tries > 0} της \pyinline{while} δεν ελέγχεται συνεχώς αλλά μόνο στην αρχή κάθε νέου κύκλου της επανάληψης.

\emph{Αφαιρέστε} τώρα την εντολή που προσθέσατε.
\end{step}

\begin{step}
Αν ο παίκτης εξαντλήσει τις προσπάθειές του χωρίς να βρει τον αριθμό τότε χάνει και το παιχνίδι σταματά. \emph{Προσθέστε} τις κατάλληλες εντολές στο πρόγραμμα έτσι ώστε, στην περίπτωση αυτή, να εμφανίζει στον παίκτη τον αριθμό που αναζητούσε, για παράδειγμα:

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Ο μυστικός αριθμός ήταν ο 13.
\end{pyterm}

\begin{note}
Ουσιαστικά θα επανεισάγετε την εντολή που αφαιρέσατε στο βήμα~\ref{step:secret-print-remove}, η οποία εμφανίζει τον μυστικό αριθμό. Θα πρέπει να την τοποθετήσετε στο κατάλληλο σημείο του προγράμματος.
\end{note} 

Φροντίστε να εμφανίζεται το μήνυμα \emph{μόνο όταν είναι απαραίτητο}: αν ο παίκτης βρει τον μυστικό αριθμό, τότε το μήνυμα δε χρειάζεται.

\clearpage
\begin{answer}
Στο σημείο αυτό, όταν πλέον έχει τερματιστεί η επανάληψη, μπορούμε να σκεφτούμε δύο πιθανές εκδοχές για να ελέγξουμε αν ο παίκτης έχει χάσει. Η μια είναι να εξετάσουμε αν οι προσπάθειες έχουν μηδενιστεί. Η άλλη είναι να εξετάσουμε αν ο αριθμός που έδωσε ο παίκτης (στην τελευταία προσπάθεια) δεν είναι ίδιος με το μυστικό. 

Παρόλο που και οι δύο μοιάζουν σωστές, όπως θα διαπιστώσουμε λίγο παρακάτω, μόνο η δεύτερη λειτουργεί με τον τρόπο που θέλουμε. Επομένως, μετά το τέλος των εντολών της επανάληψης, προσθέτουμε: 
	
\begin{pynew}
if number != secret: 
    print("Ο μυστικός αριθμός ήταν ο", secret)
\end{pynew}
\end{answer}

Εκτελέστε το πρόγραμμα. Λειτουργεί σωστά στην περίπτωση που ο παίκτης μαντέψει τον αριθμό; Μήπως στο τέλος του παιχνιδιού του εμφανίζει τον μυστικό αριθμό, παρόλο που τον έχει βρει;

\begin{answer}
	Ναι, λειτουργεί σωστά. Ο μυστικός αριθμός εμφανίζεται μόνο στην περίπτωση που ο παίκτης αποτύχει.
\end{answer}

Σε αυτή την περίπτωση, \emph{διορθώστε} το πρόγραμμα.

Tο πρόγραμμα λειτουργεί σωστά στην περίπτωση που ο παίκτης μαντεύει τον αριθμό \emph{στην τελευταία του προσπάθεια}; Μήπως του εμφανίζει και πάλι τον μυστικό αριθμό, παρόλο που τον έχει βρει;

\begin{answer}
	Ναι, λειτουργεί, αφού οι εντολές της \pyinline{if} δεν μπορούν να εκτελεστούν όταν ο παίκτης έχει μαντέψει το μυστικό αριθμό.
\end{answer}

% [comment] "Αν η απάντηση ήταν καταφατική"...να αλλάξει και στο φύλλο εργασίας γιατί αντιστοιχεί και στο Ναι, λειτουργεί. [update] Το σημείωσα.

Αν η απάντηση ήταν καταφατική, μάλλον προσπαθείτε να διαπιστώσετε αν ο παίκτης έχασε ελέγχοντας την συνθήκη \pyinline{tries == 0}. Σκεφτείτε όμως: αν ο παίκτης μαντέψει τον αριθμό στην τελευταία του προσπάθεια τότε θα ισχύει ότι \pyinline{tries == 0} όμως ο παίκτης δεν θα έχει χάσει. Χρειάζεται να διορθώσετε το πρόγραμμα ελέγχοντας με \emph{διαφορετική συνθήκη} αν ο παίκτης απέτυχε να μαντέψει τον αριθμό.
\end{step}

\section{Περισσότερη Βοήθεια}

\begin{step}
Εκτελέστε το πρόγραμμα. Στην πρώτη σας προσπάθεια δοκιμάστε τον αριθμό \pyinline{13}. Ο μυστικός αριθμός είναι μικρότερος ή μεγαλύτερος;

\begin{note}
Αν o μυστικός αριθμός είναι το \pyinline{13}, απλά εκτελέστε και πάλι το πρόγραμμα.
\end{note}

\begin{answer}
	Δοκιμάζουμε τον αριθμό \pyinline{13} και το πρόγραμμα εμφανίζει μήνυμα ότι ο μυστικός αριθμός είναι μεγαλύτερος από \pyinline{13}.
\end{answer}

Σε ποιο διάστημα θ' αναζητήσετε τώρα τον μυστικό αριθμό, δηλαδή 
ποια είναι η ελάχιστη και ποια η μέγιστη δυνατή τιμή που γνωρίζετε τώρα ότι μπορεί να έχει ο μυστικός αριθμός;
%ποιός είναι ο μικρότερος αριθμός που έχει πλέον νόημα να δοκιμάσετε και ποιός ο μεγαλύτερος;

\begin{answer}
	Η μικρότερη δυνατή τιμή του μυστικού αριθμού είναι το \pyinline{14}, αφού ο μυστικός αριθμός είναι μεγαλύτερος του \pyinline{13}, σύμφωνα με το προηγούμενο, ενώ η μεγαλύτερη δυνατή τιμή \emph{παραμένει} το \pyinline{32}.
\end{answer}
\end{step}

\begin{step}
\label{step:table}
Στη δεύτερη προσπάθεια, δοκιμάστε έναν αριθμό που ανήκει στο διάστημα που απαντήσατε προηγουμένως. 

Συνεχίστε μέχρι να τελειώσει το παιχνίδι, συμπληρώνοντας τον πίνακα που ακολουθεί. Σημειώστε σε κάθε βήμα τον αριθμό που δοκιμάσατε, την απάντηση του προγράμματος και το διάστημα μέσα στο οποίο ``εγκλωβίσατε'' κάθε φορά τον μυστικό αριθμό. Το διάστημα αυτό ορίζεται από την ελάχιστη (\pyinline{low}) και τη μέγιστη (\pyinline{high}) δυνατή τιμή που έχει νόημα να δοκιμάσετε μετά από κάθε προσπάθεια. 

\begin{answer}[]
\marginnote[32pt]{\icondiscuss}
\begin{center}
\begin{tabular}{ccp{52pt}p{52pt}}
%\hline%
αριθμός & ο μυστικός είναι & \pcenter{ελάχιστη} & \pcenter{μέγιστη} \\
\pyinline{number} & \footnotesize{(μικρότερος / μεγαλύτερος)} & \hfill \pyinline{low}\hfill\mbox{} & \hfill \pyinline{high}\hfill\mbox{} \\\addlinespace[2\parskip]
\pyinline{13} & \pcenter{μεγαλύτερος} & \pcenter{\pyinline{14}} & \pcenter{\pyinline{32}}\\\addlinespace[\parskip]
\pyinline{23} & \pcenter{μικρότερος} & \pcenter{\pyinline{14}} & \pcenter{\pyinline{22}}\\\addlinespace[\parskip]
\pyinline{18} & \pcenter{μικρότερος} & \pcenter{\pyinline{14}} & \pcenter{\pyinline{17}}\\\addlinespace[\parskip]
\pyinline{15} & \pcenter{ίσος} & \dotfill & \dotfill\\%\hline
\end{tabular}
\end{center}
\end{answer}
\end{step}

\begin{step}
Τώρα θα επεκτείνουμε το πρόγραμμα έτσι ώστε να βοηθάει το χρήστη ακόμα περισσότερο. Θα χρησιμοποιήσουμε δύο μεταβλητές \pyinline{low} και \pyinline{high}, οι οποίες αντιστοιχούν στην ελάχιστη και τη μέγιστη δυνατή τιμή που γνωρίζουμε ότι μπορεί να έχει ο μυστικός αριθμός. 

Στην αρχή του προγράμματος, αποδώστε αρχικές τιμές σε αυτές τις μεταβλητές:

\begin{pynew}
low = 1
high = 32
\end{pynew}
\end{step}

\begin{step}
Αμέσως πριν από την \pyinline{input()} με την οποία το πρόγραμμα διαβάζει από το χρήστη έναν αριθμό, \emph{προσθέστε} μια εντολή που εμφανίζει στο χρήστη τα \pyinline{low} και \pyinline{high}, για να τον βοηθά στην επιλογή του. Για παράδειγμα, αν τα \pyinline{low} και \pyinline{high} είναι αντίστοιχα \pyinline{14} και \pyinline{23}, τότε να εμφανίζει:

\marginnote[24pt]{\iconcomputer}
\begin{pyterm}
Δοκίμασε ανάμεσα στο 14 και το 23.
\end{pyterm}

\begin{answer}
	Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:
	
	\begin{pynew}
print("Δοκίμασε ανάμεσα στο", low, "και το", high)
	\end{pynew}
\end{answer}

Εκτελέστε το πρόγραμμα. Υπάρχει κάτι που σας ενοχλεί και φαίνεται να μη δουλεύει σωστά;

\begin{answer}
	Ναι, το πρόγραμμα εμφανίζει σε κάθε επανάληψη το μήνυμα:
	
	\terminline{Δοκίμασε ανάμεσα στο 1 και στο 32}, 
	
	δηλαδή δεν μεταβάλλει κατάλληλα τις τιμές των \pyinline{low} και \pyinline{high}.
\end{answer}
\end{step}

\begin{step}

Στο πρόγραμμα \emph{υπάρχει ήδη} μια \pyinline{if} που ελέγχει αν ο μυστικός αριθμός είναι μικρότερος από τον αριθμό του χρήστη:

\begin{pyplain}
    if secret < number:
        print("Ο μυστικός αριθμός είναι μικρότερος.")
\end{pyplain}

Στην περίπτωση αυτή, όπως φαίνεται κι από τον πίνακα που συμπληρώσατε στο βήμα~\ref{step:table}, \emph{μόνο μία} από τις μεταβλητές \pyinline{low} και \pyinline{high} χρειάζεται ν' αλλάξει τιμή. Ποιά από τις δύο;

\begin{answer}
Στην περίπτωση που ο μυστικός αριθμός είναι μικρότερος πρέπει να αλλάξουμε την τιμή της μεταβλητής \pyinline{high}, όπως παρακάτω:

\begin{pyplain}
    if secret < number:
        print("Ο μυστικός αριθμός είναι μικρότερος.")
\end{pyplain}
\begin{pynew}
        high = number - 1
\end{pynew}

Αφού ο μυστικός αριθμός είναι μικρότερος από τον αριθμό που έδωσε ο παίκτης τότε η μεγαλύτερη δυνατή τιμή που μπορεί να έχει, δηλαδή η τιμή της \pyinline{high}, είναι τουλάχιστον μικρότερη κατά 1 από τον αριθμό αυτό. 
\end{answer}

Να \emph{προσθέσετε} σε αυτή την περίπτωση της \pyinline{if} μια εντολή που μεταβάλλει κατάλληλα την τιμή της \pyinline{low} ή της \pyinline{high}. Αν δυσκολευτείτε, ανατρέξτε στον πίνακα που συμπληρώσατε στο βήμα~\ref{step:table}.

Στο πρόγραμμα υπάρχει επίσης μια \pyinline{if} που ελέγχει αν ο μυστικός αριθμός είναι μεγαλύτερος από τον αριθμό του χρήστη:

\begin{pyplain}
    elif secret > number:
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
\end{pyplain}

Να \emph{προσθέσετε} και σε αυτή την περίπτωση την εντολή που μεταβάλλει κατάλληλα την τιμή της \pyinline{low} ή της \pyinline{high}. 

\begin{answer}
Στην περίπτωση που ο μυστικός αριθμός είναι μεγαλύτερος πρέπει να αλλάξουμε την τιμή της μεταβλητής \pyinline{low}, όπως παρακάτω:
	
\begin{pyplain}
    elif secret > number:
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
\end{pyplain}
\begin{pynew}
        low = number + 1
\end{pynew}

Αφού ο μυστικός αριθμός είναι μεγαλύτερος από τον αριθμό που έδωσε ο παίκτης τότε η μικρότερη δυνατή τιμή που μπορεί να έχει, δηλαδή η τιμή της \pyinline{low}, είναι τουλάχιστον μεγαλύτερη κατά 1 από τον αριθμό αυτό.
\end{answer}
\end{step}

\begin{step}
Εκτελέστε το πρόγραμμά σας αρκετές φορές και ελέγξτε το διεξοδικά, για να διαπιστώσετε αν οι τιμές των μεταβλητών \pyinline{low} και \pyinline{high} μεταβάλλονται σωστά.

Λειτουργεί σωστά το πρόγραμμα; Υπάρχει κάποια περίπτωση στην οποία η συμπεριφορά του είναι προβληματική; 

\begin{answer}
	Στην περίπτωση που ο παίκτης δώσει τιμές εκτός των ορίων \pyinline{low} και \pyinline{high}, το πρόγραμμα δε λειτουργεί σωστά.
\end{answer}
\end{step}

\clearpage
\begin{step}
\begin{note}
\textbf{Επέκταση}: Το βήμα αυτό είναι προαιρετικό. 
\end{note}

Εκτελέστε ακόμα μερικές φορές το πρόγραμμα. Δοκιμάστε, ως παίκτης, να δίνετε τιμές που είναι \emph{εκτός των ορίων} που προτείνει το πρόγραμμα. Τί παρατηρείτε; Δημιουργείται πρόβλημα;

\begin{answer}
	Ναι, δημιουργείται. Το πρόγραμμα αναπροσαρμόζει τις τιμές των ορίων με λάθος τρόπο. Για παράδειγμα, αν στην πρώτη προσπάθεια ο παίκτης δώσει τον αριθμό \pyinline{40} τότε η τιμή της \pyinline{high} θα γίνει \pyinline{39}.
\end{answer}

Αν υπάρχει πρόβλημα όταν ο χρήστης δίνει τιμές εκτός του διαστήματος που ορίζουν οι \pyinline{low} και \pyinline{high}, προσθέστε τους κατάλληλους ελέγχους στο πρόγραμμα ώστε να διορθωθούν τυχόν σφάλματα.

\begin{answer}
Τα όρια θα πρέπει να προσαρμόζονται μόνο όταν ο αριθμός \pyinline{number} που δίνει ο χρήστης είναι εντός αυτών των ορίων. Επομένως, οι έλεγχοι που θα προσθέσουμε στο πρόγραμμα είναι:
	
\begin{pyplain}	
if secret < number:
    print("Ο μυστικός αριθμός είναι μικρότερος.")	   
\end{pyplain}
\begin{pynew}
    if number <= high:
\end{pynew}
\begin{pyplain}
        high = number - 1    
elif secret > number:
    print("Ο μυστικός αριθμός είναι μεγαλύτερος.") 	    
\end{pyplain}
\begin{pynew}
    if number >= low:
\end{pynew}
\begin{pyplain}
        low = number + 1
\end{pyplain}
\end{answer}
\end{step}
\end{document}
