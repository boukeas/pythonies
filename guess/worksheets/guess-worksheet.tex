\documentclass[a4paper,11pt,oneside]{book}

\newcommand{\standalone}{}
\input{../../share/tuftelike}
\input{../../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{3}

\usepackage{booktabs}

%%% DOCUMENT START

\begin{document}

\worksheettrue
\chapterwabstract{Μάντεψε τον Αριθμό}{%
Ένα από τα πρώτα προγράμματα που συνηθίζεται να φτιάχνουν οι μαθητευόμενοι προγραμματιστές είναι ένα παιχνίδι στο οποίο ο παίκτης προσπαθεί να μαντέψει τον \emph{μυστικό αριθμό} που έχει ``σκεφτεί'' ο υπολογιστής (ή το αντίστροφο).

Υπάρχουν πολλοί καλοί λόγοι που αυτό το παιχνίδι είναι μια τόσο δημοφιλής επιλογή για τους αρχάριους: το πρόγραμμα δεν είναι ιδιαίτερα περίπλοκο, αν και συνδυάζει όλες τις βασικές αλγοριθμικές έννοιες, ενώ το παιχνίδι καθεαυτό είναι πολύ διασκεδαστικό.
}{δομή επιλογής, δομή επανάληψης, υποπρογράμματα, αναζήτηση.}{guessColor}{white}

%%%%%%%%

\marginnote[22pt]{%
Εισαγωγικό υλικό:\\
\href{http://pythonies.mysch.gr/chapters/answer.pdf}{\url{pythonies.mysch.gr/chapters/answer.pdf}}\\
\href{http://pythonies.mysch.gr/chapters/answer-worksheet.pdf}{\url{answer-worksheet.pdf}}\\
\href{http://pythonies.mysch.gr/chapters/craps.pdf}{\url{craps.pdf}}\\
\href{http://pythonies.mysch.gr/chapters/craps-worksheet.pdf}{\url{craps-worksheet.pdf}}\\
}
Για ν' ακολουθήσετε αυτό το φύλλο εργασίας, θα πρέπει \emph{ήδη} να μπορείτε να φτιάχνετε προγράμματα που εμφανίζουν μηνύματα, διαβάζουν τιμές και επιλέγουν τη συμπεριφορά τους ανάλογα με τις συνθήκες που επικρατούν κατά την εκτέλεσή τους. Διαφορετικά, θα πρέπει πρώτα ν' ανατρέξετε στο \emph{εισαγωγικό υλικό}.

\marginnote{%
Διαβάστε το αντίστοιχο κεφάλαιο:\\
\href{http://pythonies.mysch.gr/chapters/guess.pdf}{\url{pythonies.mysch.gr/chapters/guess.pdf}}
}
Σε αυτό το φύλλο θα δούμε πως μπορούμε να κάνουμε τα προγράμματά μας να εκτελούν \emph{επαναληπτικά} τις ίδιες εντολές. Θα δούμε
επίσης πως μπορούμε να φτιάχνουμε \emph{υποπρογράμματα}, δηλαδή ομάδες εντολών που υλοποιούν μια συγκεκριμένη λειτουργία και καλούνται στα σημεία όπου θέλουμε να εκτελεστούν. Πιθανώς να έχετε ήδη έρθει σε επαφή με αυτές τις έννοιες στο εισαγωγικό υλικό, οπότε αυτό το φύλλο θα είναι μια ευκαιρία να εξασκηθείτε και να εμβαθύνετε.

\section{Μάντεψε!}

\begin{step}
\label{step:secret-assign}
Το πρόγραμμα θα ξεκινά επιλέγοντας τον μυστικό αριθμό. 
Η τιμή %του μυστικού αριθμού 
που επιλέγει το πρόγραμμά μας θα αποθηκεύεται σε μια μεταβλητή με το όνομα \pyinline{secret}.

Έστω ότι το πρόγραμμα επιλέγει το τυχερό \pyinline{13}.
\emph{Προσθέστε} στο πρόγραμμα μια εντολή η οποία ορίζει ότι η τιμή της \pyinline{secret} είναι \pyinline{13}.

Τώρα μπορούμε ν' αναφερόμαστε στο μυστικό αριθμό με το όνομα \pyinline{secret}, χωρίς να έχει σημασία ποια είναι η τιμή του.
\end{step}

\clearpage
\begin{step}
\label{step:number-input}
\emph{Συμπληρώστε} το πρόγραμμα έτσι ώστε να ζητά από το χρήστη να μαντέψει τον μυστικό αριθμό, εμφανίζοντας κατάλληλη προτροπή.
Για παράδειγμα:

\marginnote[24pt]{\iconcomputer\hspace{1ex}\iconkeyboard}
\begin{pyterm}
Μάντεψε τον αριθμό:
|\textbf{24}|
\end{pyterm}

Αποθηκεύστε την τιμή που πληκτρολογεί ο χρήστης σε μια μεταβλητή \pyinline{number}.

Εκτελέστε το πρόγραμμα. Τα καταφέρατε;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
Συμπληρώστε το πρόγραμμα, ώστε να εμφανίζει στον παίκτη τον αριθμό που πληκτρολόγησε, για παράδειγμα:

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Έδωσες τον αριθμό 24
\end{pyterm}

%Αν δυσκολευτείτε, ανατρέξτε στο βήμα~\ref{step:print-variable}.
%, όπου γίνεται κάτι ανάλογο.
\end{step}

\begin{step}
\marginnote[18pt]{Με το \pyinline{==} ελέγχεται αν δύο τιμές είναι ίσες. Μην το συγχέετε με το \pyinline{=} που χρησιμοποιείται για να δώσουμε τιμή σε μια μεταβλητή.}
\marginnote{Με το \pyinline{!=} ελέγχεται αν δύο τιμές είναι διαφορετικές.}
\emph{Συμπληρώστε} το πρόγραμμά σας με μια \pyinline{if}--\pyinline{else}, έτσι ώστε να ελέγχει αν ο παίκτης βρήκε τον μυστικό αριθμό ή όχι και να του εμφανίζει ανάλογο μήνυμα. Για παράδειγμα, τώρα που ο μυστικός αριθμός είναι ο~\pyinline{13}, υπάρχουν δύο πιθανές περιπτώσεις:

\marginnote[24pt]{\iconcomputer\hspace{1ex}\iconkeyboard}
\begin{pyterm}
Μάντεψε τον αριθμό:
|\textbf{13}|
Σωστά!
\end{pyterm}

\begin{pyterm}
Μάντεψε τον αριθμό:
|\textbf{24}|
Λάθος...
\end{pyterm}

Στη συνθήκη της \pyinline{if} χρησιμοποιήσατε την μεταβλητή \pyinline{secret} ή συγκρίνατε την τιμή της \pyinline{number} απευθείας με το \pyinline{13};

\marginnote[14pt]{\icondiscuss}
\dottedline

Στη δεύτερη περίπτωση, \emph{τροποποιήστε} τη συνθήκη της \pyinline{if}, έτσι ώστε η μεταβλητή \pyinline{number} να συγκρίνεται με την \pyinline{secret} και όχι με το \pyinline{13}.

Ποιο πλεονέκτημα πιστεύετε ότι έχει η χρήση της μεταβλητής \pyinline{secret}, αντί της σταθεράς \pyinline{13};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\begin{step}
Εκτελέστε το πρόγραμμα δύο φορές και παίξτε το ρόλο του χρήστη. Την πρώτη φορά δώστε σωστά τον μυστικό αριθμό, ενώ την επόμενη δώστε έναν διαφορετικό. 

Μήπως το πρόγραμμά σας εμφανίζει το μήνυμα \pyinline{"Λάθος..."}, ακόμα κι όταν ο χρήστης μαντέψει σωστά τον μυστικό αριθμό; Σε αυτή την περίπτωση, δοκιμάστε να κάνετε την παρακάτω τροποποίηση:

\marginnote[14pt]{\iconcaution}
\begin{pyplain}
number = |\pyhighlight{int(}|input()|\pyhighlight{)}|
\end{pyplain}

Γιατί είναι απαραίτητη η χρήση της \pyinline{int}; Τί πιστεύετε ότι συμβαίνει όταν δεν χρησιμοποιείται η \pyinline{int} και το πρόγραμμα δεν λειτουργεί;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\begin{step}
\label{step:secret-print}

\emph{Προσθέστε} στο πρόγραμμα μια εντολή που θα εμφανίζει τον μυστικό αριθμό στην περίπτωση που ο παίκτης απαντήσει λάθος, όπως παρακάτω:

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Ο μυστικός αριθμός ήταν ο 13.
\end{pyterm}

\begin{note}
Βεβαιωθείτε κι εδώ ότι αποκαλύπτετε στο χρήστη την τιμή της \pyinline{secret}, και όχι την σταθερά \pyinline{13}.
\end{note}

Εκτελέστε το πρόγραμμα δύο φορές. Στην πρώτη δώστε σωστά τον μυστικό αριθμό, ενώ στην επόμενη δώστε έναν διαφορετικό. Εμφανίζει το μυστικό αριθμό \emph{μόνο} στην περίπτωση που ο παίκτης δεν τον μαντέψει; Αν όχι, γιατί πιστεύετε ότι συμβαίνει αυτό;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\marginnote[16pt]{\iconcaution}
Αν ο μυστικός αριθμός εμφανίζεται είτε ο χρήστης τον μαντέψει, είτε όχι, τότε πιθανότατα δεν τοποθετήσατε τη νέα εντολή \emph{μέσα} στην \pyinline{else}, αλλά μετά από αυτή. Προσθέστε 4 κενά πριν την εντολή, για να υποδηλώσετε ότι κι αυτή ανήκει στην \pyinline{else}.

Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

% [comment] Αν βάλουμε την τυχαιότητα μετά, θα είναι ευκολότερο να ελέγχει ο μαθητής τις απαντήσεις του προγράμματος. Όμως, δεν θα μπορούμε να ρωτήσουμε τι γίνεται αν η τυχαία τιμή της secret αποδίδεται μέσα στην επανάληψη. 

\section{Τυχαιότητα}

Το παιχνίδι μας δεν αξίζει να το παίξεις πάνω από μία-δύο φορές, αν ο μυστικός αριθμός είναι πάντα το \pyinline{13}. Αυτό που χρειαζόμαστε είναι να επιλέγεται κάθε φορά ένας διαφορετικός αριθμός.
Για τον σκοπό αυτό, θα χρειαστούμε τη βιβλιοθήκη \pyinline{random}.
%, όπως προηγουμένως είχαμε χρησιμοποιήσει τη βιβλιοθήκη \pyinline{time}. 

\begin{step}
\label{step:secret-random}
Στην αρχή του προγράμματος \emph{προσθέστε} την εντολή εισαγωγής της βιβλιοθήκης \pyinline{random}.

\begin{pynew}
import random
\end{pynew}

\emph{Τροποποιήστε} την εντολή του βήματος~\ref{step:secret-assign}, όπου ορίζεται η τιμή της μεταβλητής \pyinline{secret}, ως εξής:

\begin{pyplain}
secret = |\pyhighlight{random.randint(1,32)}|
\end{pyplain}

Εκτελέστε το πρόγραμμα αρκετές φορές. Τί είδους τιμές παρατηρείτε ότι παίρνει η μεταβλητή \pyinline{secret};

%Ποια διαφορά παρατηρείτε στη λειτουργία του;
%\marginnote[14pt]{\icondiscuss}
%\dottedline

\marginnote[14pt]{\icondiscuss}
\dottedline

Ποιος πιστεύετε ότι είναι ο ρόλος των παραμέτρων \pyinline{1} και \pyinline{32}; Τί συμβαίνει αν δοκιμάσετε άλλες τιμές στη θέση τους, για παράδειγμα \pyinline{33} και \pyinline{64}; Αν χρειαστεί εκτελέστε πάλι το πρόγραμμα αρκετές φορές προκειμένου να απαντήσετε στην ερώτηση.

\marginnote[14pt]{\icondiscuss}
\dottedline

Πως θα χρησιμοποιούσατε τη \pyinline{randint} για να προσομοιώσετε τη ρίψη ενός ζαριού, τη ρίψη ενός κέρματος ή την επιλογή ενός τυχαίου χαρτιού από μια τράπουλα;

\marginnote[14pt]{\icondiscuss}
%\begin{center}
%\vspace{-\parskip}
\begin{tabular}{llp{18pt}cp{18pt}l}
%\hline%
{\small ρίψη ζαριού:} & \pyinline{dice = random.randint(} & \dotfill & , & \dotfill & \pyinline{)} \\\addlinespace[\parskip]
{\small ρίψη κέρματος:} & \pyinline{coin = random.randint(} & \dotfill & , & \dotfill & \pyinline{)} \\\addlinespace[\parskip]
{\small επιλογή χαρτιού:} & \pyinline{card = random.randint(} & \dotfill & , & \dotfill & \pyinline{)} \\\addlinespace[\parskip]
\end{tabular}
%\end{center}

Μπορείτε να σκεφτείτε άλλες περιπτώσεις στις οποίες θα χρειαζόσασταν τη \pyinline{randint};

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\section{Γύρω-Γύρω Όλοι}

% [comment] Προστέθηκε η ακόλουθη εισαγωγή, ώστε να είναι σαφέστερο ότι οδηγούμαστε σε ένα παιχνίδι με πολλούς γύρους, όπου σε κάθε γύρο ο παίκτης προσπαθεί να μαντέψει τον ίδιο αριθμό. [discuss]

% [comment] Όταν μπαίνει η while, ο κύκλος εκτελείται πολλές φορές. Αυτό είναι σαφές στους μαθητές. Αυτό που δεν είναι σαφές την ώρα που εκτελούν για πρώτη φορά το πρόγραμμα με τη while είναι αν εμείς θέλουμε να έχουμε ένα παιχνίδι με πολλές προσπάθειες ή αν θέλουμε να έχουμε πολλά παιχνίδια με μια προσπάθεια. Όταν βάζουν τη while για πρώτη φορά, πιο πολύ αισθάνεται κανείς ότι συμβαίνει το δεύτερο (κυρίως επειδή αποκαλύπτεται ο μυστικός αριθμός, παρόλο που είναι πάντα ο ίδιος). Νομίζω ότι πρέπει να καταστήσουμε με κάποιον τρόπο σαφέστερο που θέλουμε να οδηγηθούμε. [discuss] (~/guess-p1.py)[Βασιλης] Στο προηγούμενο βήμα που εισάγουν τη while δεν υπάρχει ένας πρόλογος που να εξηγεί πώς θα κάνουμε το παιχνίδι πιο ενδιαφέρον (δες προηγούμενη ερώτηση). Θα μπορούσαμε στο σημείο αυτό να περιγράψουμε το τι παμε να κάνουμε δίνοντας έμφαση στο τι σημαίνει νέος γύρος και στο τι σημαίνει νέο παιχνίδι.

%Είναι αλήθεια πως ο παίκτης πρέπει να είναι πολύ τυχερός για να μαντέψει τον μυστικό αριθμό. 
Θα θέλαμε να επεκτείνουμε το παιχνίδι έτσι ώστε ο παίκτης να έχει \emph{επαναλαμβανόμενες} ευκαιρίες να βρει τον μυστικό αριθμό, ενώ ο μυστικός αριθμός \emph{παραμένει ο ίδιος}.

\begin{step}
\emph{Προσθέστε} τη γραμμή που ακολουθεί \emph{αμέσως μετά} από την εντολή του βήματος~\ref{step:secret-random}, που δίνει μια τυχαία τιμή στη μεταβλητή \pyinline{secret}.

% [comment] Προτιμήθηκε η εκδοχή του αρχικού φύλλου εργασίας, έναντι της παρακάτω, που προέρχεται από το αυτοτελές φύλλο.

%\emph{Προσθέστε} τη γραμμή που ακολουθεί \emph{αμέσως πριν} από τις εντολές που προσθέσατε στο βήμα~\ref{step:number-input}, όπου ζητείται από το χρήστη να μαντέψει τον μυστικό αριθμό.

\begin{pynew}
while True:
\end{pynew}

\emph{Προσθέστε} τέσσερα κενά μπροστά από \emph{όλες τις εντολές που ακολουθούν} τη \pyinline{while}, σηματοδοτώντας έτσι ότι αυτές οι εντολές \emph{εμφωλεύονται} στη \pyinline{while}, δηλαδή περιέχονται σε αυτήν.

Εκτελέστε το πρόγραμμα. 
\marginnote[4pt]{Mπορείτε να διακόψετε την εκτέλεση του προγράμματός σας με τον συνδυασμό πλήκτρων \terminline{Ctrl + C}.}
Ποια αλλαγή παρατηρείτε ότι επιφέρει η χρήση της \pyinline{while};

%\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

%\clearpage
Η εντολή του βήματος~\ref{step:secret-random}, που δίνει μια τυχαία τιμή στην μεταβλητή \pyinline{secret}, βρίσκεται \emph{πριν} από τη \pyinline{while}. Ποια πιστεύετε ότι θα ήταν η διαφορά αν βρισκόνταν \emph{μέσα} στη \pyinline{while};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\label{step:secret-print-remove}
Η εντολή του βήματος~\ref{step:secret-print} εμφανίζει τον μυστικό αριθμό, στην περίπτωση που ο χρήστης δεν τον μαντέψει. Τώρα, αυτή η εντολή βρίσκεται μέσα στη \pyinline{while} κι εκτελείται σε κάθε αποτυχημένη προσπάθεια του χρήστη. Γιατί αυτό είναι πρόβλημα;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\emph{Διαγράψτε} την εντολή που εμφανίζει τον μυστικό αριθμό.

Παίξτε το παιχνίδι μέχρι να μαντέψετε τον μυστικό αριθμό. Υπάρχει κάτι που σας ενοχλεί; Κάτι που φαίνεται να μη δουλεύει σωστά;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\begin{step}
Η εντολή \pyinline{break} διακόπτει την επανάληψη μέσα στην οποία βρίσκεται \emph{αμέσως} μόλις εκτελεστεί.
\emph{Προσθέστε} την \pyinline{break} στο σημείο του προγράμματος που θεωρείτε κατάλληλο, έτσι ώστε το παιχνίδι να τερματίζεται \emph{όταν ο παίκτης μαντέψει τον αριθμό}.

Πρέπει να ελέγξετε αν τοποθετήσατε την \pyinline{break} στο σωστό σημείο. Εκτελέστε το πρόγραμμα και παίξτε το παιχνίδι δοκιμάζοντας αριθμούς. Διακόπτεται η επανάληψη όταν μαντέψετε τον μυστικό αριθμό;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
Για δοκιμαστικούς λόγους, κάτω από την \pyinline{break} \emph{προσθέστε} την εντολή:

\begin{pynew}
print("Ζντονκ!")
\end{pynew}

Εκτελέστε πάλι το πρόγραμμα μέχρι να μαντέψετε τον αριθμό. Εμφανίζεται το μήνυμα \pyinline{"Ζντονκ!"}; Γιατί πιστεύετε ότι συμβαίνει αυτό;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\emph{Αφαιρέστε} τώρα την εντολή που προσθέσατε.
\end{step}

\begin{step}
Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\marginnote[14pt]{\icondiscuss}
\dottedline

%\dottedline
\end{step}

\section{Επιλογές, Επιλογές}

Θα επεκτείνουμε το πρόγραμμα έτσι ώστε να δίνει στο χρήστη περισσότερη πληροφορία: αντί να τον ενημερώνει απλά αν βρήκε τον μυστικό αριθμό ή όχι, θα τον κατευθύνει αν πρέπει να τον αναζητήσει ψηλότερα ή χαμηλότερα.

Για την επέκταση αυτή δεν αρκεί πια η απλή \pyinline{if}--\pyinline{else}, η οποία μπορεί να διακρίνει μόνο ανάμεσα σε δύο περιπτώσεις. 

\begin{step}
\emph{Τροποποιήστε} την \pyinline{if} που ελέγχει αν ο χρήστης βρήκε τον μυστικό αριθμό. Συμπληρώσετε την συνθήκη που λείπει:

\begin{pyplain}
    if secret == number:
        print("Σωστά!")
        break
\end{pyplain}
\begin{pynew}
    elif |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
    else:
        print("Ο μυστικός αριθμός είναι μικρότερος.")
\end{pynew}

Εκτελέστε το πρόγραμμα και βεβαιωθείτε ότι λειτουργεί σωστά. 

Σε ποια περίπτωση εκτελούνται οι εντολές της \pyinline{else}; Γιατί πιστεύετε ότι δεν ελέγχουμε καμία συνθήκη σε αυτή την τρίτη περίπτωση;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\dottedline
\end{step}

\begin{step}
\emph{Αναδιατάξτε} τις περιπτώσεις της \pyinline{if} όπως φαίνεται παρακάτω. Και πάλι, θα πρέπει να συμπληρώσετε μια από τις συνθήκες που ελέγχονται. Είναι καλή εξάσκηση και θα σας κάνει να σκεφτείτε για την σειρά με την οποία ελέγχονται οι συνθήκες.

\begin{pynew}
    if |\textrm{\textit{συνθήκη}}|: # συμπληρώστε την συνθήκη
        print("Ο μυστικός αριθμός είναι μικρότερος.")
    elif secret > number:
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
    else:
        print("Σωστά!")
        break
\end{pynew}

Εκτελέστε το πρόγραμμα και βεβαιωθείτε ότι λειτουργεί σωστά. 

Τί θα αλλάζατε στο πρόγραμμα όπως έχει μέχρι στιγμής; Πώς πιστεύετε ότι πρέπει να επεκταθεί για να γίνει πιο ενδιαφέρον;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\section{Μέτρημα}

Ο αριθμός των προσπαθειών που διαθέτει ο παίκτης δεν θα έπρεπε να είναι απεριόριστος. Θα επεκτείνουμε το παιχνίδι ώστε να τερματίζεται όταν εξαντληθούν οι προσπάθειες του παίκτη.

\begin{step}
\label{step:tries-print}
Αμέσως μετά τη \pyinline{while}, δηλαδή στην αρχή της επανάληψης, \emph{προσθέστε} την εντολή που ακολουθεί:

\begin{pynew}
print("Απομένουν", tries, "προσπάθειες.")
\end{pynew}

Είναι εμφανές ότι η τιμή της μεταβλητής \pyinline{tries} θα αντιστοιχεί στο πλήθος των προσπαθειών που απομένουν στον παίκτη. 

\marginnote[16pt]{\iconcaution}
Αν εκτελέσετε το πρόγραμμα όπως έχει θα εμφανιστεί μήνυμα λάθους, αφού επιχειρούμε να εμφανίσουμε την τιμή της \pyinline{tries}, χωρίς πουθενά προηγουμένως να της έχουμε αποδώσει μια τιμή.

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
NameError: name 'tries' is not defined
\end{pyterm}
\end{step}

\begin{step}
\label{step:tries-init}
Δώστε στην \pyinline{tries} την αρχική τιμή \pyinline{4}. Αυτό θα είναι το πλήθος των προσπαθειών που διαθέτει ο χρήστης όταν ξεκινά το παιχνίδι. % Αποφασίστε εσείς μια τιμή που να σας φαίνεται ``δίκαιη''.

% [comment] Αρχική διατύπωση, που άφηνε ελεύθερη την επιλογή της αρχικής προσπάθειας: Δώστε στην \pyinline{tries} μια αρχική τιμή, ίση με το πλήθος των προσπαθειών που διαθέτει ο χρήστης όταν ξεκινά το παιχνίδι. Αποφασίστε εσείς μια τιμή που να σας φαίνεται ``δίκαιη''.

Τοποθετήσατε τις νέες εντολές \emph{πριν} την επανάληψη ή \emph{μέσα} σε αυτή; Για ποιο λόγο κάνατε αυτή την επιλογή;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

% [comment] Η ερώτηση που ακολουθεί τοποθετήθηκε λίγο παρακάτω, μετά το πινακάκι. Θα μπορούσε να παραμείνει κι εδώ, που ήταν και η αρχική της θέση. [discuss]
% Θεωρείτε ``δίκαιο'' να δίνονται στον παίκτη τέσσερις προσπάθειες και γιατί; 
%\marginnote[14pt]{\icondiscuss}
%\dottedline
%\dottedline

Εκτελέστε το πρόγραμμα. Τί παρατηρείτε;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
Η μεταβλητή \pyinline{tries} θα πρέπει να μειώνεται σε κάθε γύρο του παιχνιδιού, δηλαδή \emph{εντός της επανάληψης}. Μετά την \pyinline{print} του βήματος~\ref{step:tries-print} που εμφανίζει το πλήθος των προσπαθειών, \emph{προσθέστε} τη γραμμή:

\begin{pynew}
    tries = tries - 1
\end{pynew}

Εκτελέστε το πρόγραμμα. Μειώνεται το πλήθος των προσπαθειών που απομένουν στον παίκτη;
%\marginnote[14pt]{\icondiscuss}
%\dottedline
\marginnote[14pt]{\iconcaution}
Αν το πλήθος των προσπαθειών δεν μειώνεται, βεβαιωθείτε ότι η εντολή που προσθέσατε στο βήμα~\ref{step:tries-init} και δίνει αρχική τιμή στην \pyinline{tries}, βρίσκεται \emph{πριν} από την επανάληψη και όχι μέσα σε αυτή.

Περιγράψτε πως ακριβώς πιστεύετε ότι λειτουργεί η εντολή που προσθέσατε για να μειώνεται η \pyinline{tries}.

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

%\dottedline

%Αυτή η εντολή μπορεί να σας μπερδέψει αν την ερμηνεύσετε σαν μαθηματική ισότητα (ενώ δεν είναι). Για να γίνει κατανοητή, πρέπει να διαβαστεί ως εξής: υπολόγισε την τιμή της παράστασης \pyinline{tries - 1} κι ονόμασε το αποτέλεσμα \pyinline{tries}. Η νέα τιμή της \pyinline{tries} υπολογίζεται με βάση την τρέχουσα τιμή της, την οποία και αντικαθιστά.

Υπάρχει κάτι που σας ενοχλεί και φαίνεται να μη δουλεύει σωστά;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}
 
\section{Τερματισμός}

Το παιχνίδι δεν πρέπει να τερματίζεται μόνο όταν ο παίκτης μαντέψει τον αριθμό, αλλά και όταν τελειώσουν οι προσπάθειές του.

\begin{step}
Προς το παρόν, \emph{προσθέστε} τις εντολές που ακολουθούν στο σημείο που κρίνετε κατάλληλο ώστε η επανάληψη να τερματίζεται όταν εξαντληθούν οι προσπάθειες του παίκτη.

\begin{pynew}
    if tries == 0:
        break
\end{pynew}

Εκτελέστε το πρόγραμμά σας. Φροντίστε, ως παίκτες, να εξαντλήσετε τις προσπάθειές σας χωρίς να μαντέψετε τον αριθμό. 

Ποιες τιμές επιλέξατε να δοκιμάσετε, για να είστε βέβαιοι ότι δεν θα πετύχετε τον μυστικό αριθμό και θα εξαντλήσετε τις προσπάθειες;

\marginnote[14pt]{\icondiscuss}
\dottedline

Τερματίζεται το πρόγραμμα όταν εξαντληθούν οι προσπάθειες του παίκτη;

\marginnote[14pt]{\icondiscuss}
\dottedline

\marginnote[10pt]{\iconcaution}
Είστε βέβαιοι ότι το πρόγραμμα επιτρέπει στον παίκτη να χρησιμοποιήσει \emph{όλες} του τις προσπάθειες; Αν προσθέσατε τις εντολές αμέσως μετά την εντολή \pyinline{tries = tries - 1}, τότε το πρόγραμμά σας θα στερεί από τον παίκτη μια προσπάθεια!
%Αν προσθέσετε τις εντολές σε λάθος σημείο τότε πιθανώς το πρόγραμμά σας να στερεί από τον παίκτη μια προσπάθεια!
\end{step}

\begin{step}
\emph{Διαγράψτε} τις εντολές που προσθέσατε στο προηγούμενο βήμα. Αντί για την \pyinline{break}, θα διερευνήσουμε έναν εναλλακτικό (και συχνά προτιμότερο) τρόπο για να τερματίζουμε την επανάληψη όταν εξαντληθούν οι προσπάθειες.

%%% μέχρι εδώ δεν υπάρχει στο standalone

Η \pyinline{while} συνοδεύεται από μια \emph{συνθήκη}. Στην \emph{αρχή} κάθε κύκλου, η συνθήκη αυτή ελέγχεται εκ νέου. Αν η συνθήκη είναι αληθής τότε η επανάληψη συνεχίζεται για άλλον έναν κύκλο. 

Εμείς χρησιμοποιήσαμε μέχρι τώρα την τετριμμένη συνθήκη \pyinline{True}, η οποία είναι πάντα αληθής, γι' αυτό και η επανάληψη δεν διακόπτονταν λόγω της συνθήκης.

\emph{Αντικαταστήστε} την συνθήκη \pyinline{True} με την συνθήκη \pyinline{tries > 0}, που είναι αληθής μόνο όταν απομένουν κι άλλες προσπάθειες στον παίκτη. Σε περίπτωση που αυτό δεν ισχύει, η επανάληψη θα διακοπεί.

\begin{pyplain}
while |\pyhighlight{tries > 0}|:
\end{pyplain}

%\clearpage
Εκτελέστε και πάλι το πρόγραμμα και διερευνήστε την συμπεριφορά του. Λειτουργεί σωστά ή εντοπίζετε προβλήματα;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
Για δοκιμαστικούς λόγους, \emph{προσθέστε} αμέσως κάτω από την εντολή \pyinline{tries = tries - 1} τη γραμμή:

\begin{pynew}
print("Ζντονκ!", tries)
\end{pynew}

Εκτελέστε το πρόγραμμα μέχρι να εξαντληθούν οι προσπάθειες. Eμφανίζεται στο τέλος το μήνυμα \pyinline{"Ζντονκ! 0"};

\marginnote[14pt]{\icondiscuss}
\dottedline

Ενώ η συνθήκη της \pyinline{while} είναι \pyinline{tries > 0}, από το μήνυμα φαίνεται ότι η εκτέλεση των εντολών της επανάληψης δεν διακόπτεται \emph{άμεσα} όταν μηδενιστεί η μεταβλητή \pyinline{tries} και η συνθήκη πάψει να ισχύει. Άρα η συνθήκη \pyinline{tries > 0} της \pyinline{while} δεν ελέγχεται συνεχώς αλλά μόνο στην αρχή κάθε νέου κύκλου της επανάληψης.

\emph{Αφαιρέστε} τώρα την εντολή που προσθέσατε.
\end{step}

%\begin{step}
%\begin{question}
%Από ποια σημεία, με ποιους τρόπους και σε ποιες περιπτώσεις γίνεται η έξοδος από την επανάληψη;
%\end{question}
%\end{step}

\begin{step}
Αν ο παίκτης εξαντλήσει τις προσπάθειές του και δεν καταφέρει να βρει τον αριθμό τότε χάνει και το παιχνίδι σταματά. \emph{Προσθέστε} τις κατάλληλες εντολές στο πρόγραμμα έτσι ώστε, στην περίπτωση αυτή, να εμφανίζει στον παίκτη τον αριθμό που αναζητούσε.

\begin{note}
Θα χρειαστεί, μεταξύ άλλων, να επανεισάγετε την εντολή που αφαιρέσατε στο βήμα~\ref{step:secret-print-remove}, η οποία εμφάνιζε τον μυστικό αριθμό.
% Εκείνη η εντολή αφαιρέθηκε επειδή βρισκόνταν μέσα στην επανάληψη, ενώ τώρα θα χρειαστεί να την εισάγετε μετά από αυτή, στο τέλος του παιχνιδιού.
\end{note} 

\marginnote[14pt]{\iconcomputer}
\begin{pyterm}
Ο μυστικός αριθμός ήταν ο 13.
\end{pyterm}

Φροντίστε να εμφανίζεται το μήνυμα \emph{μόνο όταν είναι απαραίτητο}. Αν ο παίκτης βρει τον μυστικό αριθμό, τότε το μήνυμα δε χρειάζεται.

Τοποθετήσατε τις νέες εντολές \emph{μέσα} στην επανάληψη ή \emph{μετά} από αυτή; Για ποιο λόγο κάνατε αυτή την επιλογή;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Τι διαφορά θα υπήρχε αν είχατε κάνει την αντίθετη επιλογή;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Εκτελέστε το πρόγραμμα. Λειτουργεί σωστά στην περίπτωση που ο παίκτης μαντέψει τον αριθμό; Μήπως στο τέλος του παιχνιδιού του εμφανίζει τον μυστικό αριθμό, παρόλο που τον έχει βρει;

\marginnote[14pt]{\icondiscuss}
\dottedline

Σε αυτή την περίπτωση, \emph{διορθώστε} το πρόγραμμα.

Tο πρόγραμμα λειτουργεί σωστά στην περίπτωση που ο παίκτης μαντεύει τον αριθμό \emph{στην τελευταία του προσπάθεια}; Μήπως του εμφανίζει και πάλι τον μυστικό αριθμό, παρόλο που τον έχει βρει;

\marginnote[14pt]{\icondiscuss}
\dottedline

\clearpage
Αν η απάντηση ήταν καταφατική, μάλλον προσπαθείτε να διαπιστώσετε αν ο παίκτης έχασε ελέγχοντας την συνθήκη \pyinline{tries == 0}. Σκεφτείτε όμως: αν ο παίκτης μαντέψει τον αριθμό στην τελευταία του προσπάθεια τότε θα ισχύει ότι \pyinline{tries == 0} όμως ο παίκτης δεν θα έχει χάσει. Χρειάζεται να διορθώσετε το πρόγραμμα ελέγχοντας με \emph{διαφορετική συνθήκη} αν ο παίκτης απέτυχε να μαντέψει τον αριθμό.
\end{step}

\section{Περισσότερη Βοήθεια}

\begin{step}
Εκτελέστε το πρόγραμμα. Στην πρώτη σας προσπάθεια δοκιμάστε τον αριθμό \pyinline{13}. Ο μυστικός αριθμός είναι μικρότερος ή μεγαλύτερος;

\begin{note}
Αν o μυστικός αριθμός είναι το \pyinline{13}, απλά εκτελέστε και πάλι το πρόγραμμα.
\end{note}

\marginnote[14pt]{\icondiscuss}
\dottedline

Σε ποιο διάστημα θ' αναζητήσετε τώρα τον μυστικό αριθμό, δηλαδή 
ποια είναι η ελάχιστη και ποια η μέγιστη δυνατή τιμή που γνωρίζετε τώρα ότι μπορεί να έχει ο μυστικός αριθμός;
%ποιός είναι ο μικρότερος αριθμός που έχει πλέον νόημα να δοκιμάσετε και ποιός ο μεγαλύτερος;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
\label{step:table}
Στη δεύτερη προσπάθεια, δοκιμάστε έναν αριθμό που ανήκει στο διάστημα που απαντήσατε προηγουμένως. 
%Ποιος ήταν ο αριθμός που δοκιμάσατε και τί απάντηση πήρατε; 
%Ο μυστικός αριθμός είναι μικρότερος ή μεγαλύτερος;
%Σε ποιο διάστημα θ' αναζητήσετε τον αριθμό μετά τη δεύτερη προσπάθεια; 
%\marginnote[14pt]{\icondiscuss}
%\dottedline
Συνεχίστε μέχρι να τελειώσει το παιχνίδι, συμπληρώνοντας τον πίνακα που ακολουθεί. Σημειώστε σε κάθε βήμα τον αριθμό που δοκιμάσατε, την απάντηση του προγράμματος και το διάστημα μέσα στο οποίο ``εγκλωβίσατε'' κάθε φορά τον μυστικό αριθμό. Το διάστημα αυτό ορίζεται από την ελάχιστη (\pyinline{low}) και τη μέγιστη (\pyinline{high}) δυνατή τιμή που έχει νόημα να δοκιμάσετε μετά από κάθε προσπάθεια. %Να δοκιμάζετε κάθε φορά έναν αριθμό που ανήκει στο διάστημα ανάμεσα στα \pyinline{low} και \pyinline{high}.

\marginnote[32pt]{\icondiscuss}
\begin{center}
\begin{tabular}{ccp{52pt}p{52pt}}
%\hline%
αριθμός & ο μυστικός είναι & \hfill ελάχιστη\hfill\mbox{} & \hfill μέγιστη\hfill\mbox{} \\
\pyinline{number} & \footnotesize{(μικρότερος / μεγαλύτερος)} & \hfill \pyinline{low}\hfill\mbox{} & \hfill \pyinline{high}\hfill\mbox{} \\\addlinespace[2\parskip]
\pyinline{13} & \dotfill & \dotfill & \dotfill\\\addlinespace[\parskip]
\dotfill & \dotfill & \dotfill & \dotfill\\\addlinespace[\parskip]
\dotfill & \dotfill & \dotfill & \dotfill\\\addlinespace[\parskip]
\dotfill & \dotfill & \dotfill & \dotfill\\%\hline
\end{tabular}
\end{center}

Θεωρείτε ``δίκαιο'' να δίνονται στον παίκτη τέσσερις προσπάθειες και γιατί;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\begin{step}
Τώρα θα επεκτείνουμε το πρόγραμμα έτσι ώστε να βοηθάει το χρήστη ακόμα περισσότερο. Θα χρησιμοποιήσουμε δύο μεταβλητές \pyinline{low} και \pyinline{high}, οι οποίες αντιστοιχούν στην ελάχιστη και τη μέγιστη δυνατή τιμή που γνωρίζουμε ότι μπορεί να έχει ο μυστικός αριθμός. 

Στην αρχή του προγράμματος, αποδώστε αρχικές τιμές σε αυτές τις μεταβλητές:

\begin{pynew}
low = 1
high = 32
\end{pynew}

%Τώρα \emph{τροποποιήστε} την εντολή που επιλέγει τον μυστικό αριθμό:
%\begin{pyplain}
%secret = random.randint(|\pyhighlight{low}|,|\pyhighlight{high}|)
%\end{pyplain}
\end{step}

\begin{step}
Αμέσως πριν από την \pyinline{input()} με την οποία το πρόγραμμα διαβάζει από το χρήστη έναν αριθμό, \emph{προσθέστε} μια εντολή που εμφανίζει στο χρήστη τα \pyinline{low} και \pyinline{high}, για να τον βοηθά στην επιλογή του. Για παράδειγμα, αν τα \pyinline{low} και \pyinline{high} είναι αντίστοιχα \pyinline{14} και \pyinline{23}, τότε να εμφανίζει:

\marginnote[24pt]{\iconcomputer}
\begin{pyterm}
Δοκίμασε ανάμεσα στο 14 και το 23.
\end{pyterm}

Εκτελέστε το πρόγραμμα και παρατηρήστε τις τιμές των \pyinline{low} και \pyinline{high}, καθώς προσπαθείτε να μαντέψετε τον μυστικό αριθμό. Υπάρχει κάτι που σας ενοχλεί και φαίνεται να μη δουλεύει σωστά;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
% Όπως φαίνεται κι από τον πίνακα που συμπληρώσατε στο βήμα~\ref{step:table}, ανάλογα με την απάντηση του προγράμματος (μικρότερος ή μεγαλύτερος) μεταβάλλεται \emph{μόνο ένα} από τα δύο άκρα του διαστήματος στο οποίο εγκλωβίζουμε τον μυστικό αριθμό, δηλαδή μόνο μια από τις \pyinline{low} ή \pyinline{high}.

Στο πρόγραμμα \emph{υπάρχει ήδη} μια \pyinline{if} που ελέγχει αν ο μυστικός αριθμός είναι μικρότερος από τον αριθμό του χρήστη:

\begin{pyplain}
    if secret < number:
        print("Ο μυστικός αριθμός είναι μικρότερος.")
\end{pyplain}

Στην περίπτωση αυτή, όπως φαίνεται κι από τον πίνακα που συμπληρώσατε στο βήμα~\ref{step:table}, \emph{μόνο μία} από τις μεταβλητές \pyinline{low} και \pyinline{high} χρειάζεται ν' αλλάξει τιμή. Ποιά από τις δύο;

\marginnote[14pt]{\icondiscuss}
\dottedline

Να \emph{προσθέσετε} σε αυτή την περίπτωση της \pyinline{if} μια εντολή που μεταβάλλει κατάλληλα την τιμή της \pyinline{low} ή της \pyinline{high}. Αν δυσκολευτείτε, ανατρέξτε στον πίνακα που συμπληρώσατε στο βήμα~\ref{step:table}.

Στο πρόγραμμα υπάρχει επίσης μια \pyinline{if} που ελέγχει αν ο μυστικός αριθμός είναι μεγαλύτερος από τον αριθμό του χρήστη:

\begin{pyplain}
    elif secret > number:
        print("Ο μυστικός αριθμός είναι μεγαλύτερος.")
\end{pyplain}

Να \emph{προσθέσετε} και σε αυτή την περίπτωση την εντολή που μεταβάλλει κατάλληλα την τιμή της \pyinline{low} ή της \pyinline{high}. 

%Σε ποια από τις δύο περιπτώσεις μεταβάλλεται η τιμή της \pyinline{low}; Όταν ο μυστικός αριθμός είναι μικρότερος ή μεγαλύτερος από τον αριθμό που δοκιμάζει ο χρήστης;

%\marginnote[14pt]{\icondiscuss}
%\dottedline

%Να \emph{προσθέσετε} στην αντίθετη περίπτωση την εντολή που μεταβάλλει κατάλληλα την τιμή της \pyinline{high}. 

%\begin{note}
%Προσέξτε, θα χρειαστεί να προσθέσετε \emph{μόνο} μια εντολή.
%\end{note}

%Να \emph{προσθέσετε} μια εντολή που να μεταβάλλει κατάλληλα την τιμή της \pyinline{high}, \emph{όταν αυτό είναι απαραίτητο}. 

%\begin{note}
%Κι εδώ θα χρειαστεί να προσθέσετε \emph{μόνο} μια εντολή.
%\end{note}
\end{step}

\begin{step}
Εκτελέστε το πρόγραμμά σας αρκετές φορές και ελέγξτε το διεξοδικά, για να διαπιστώσετε αν οι τιμές των μεταβλητών \pyinline{low} και \pyinline{high} μεταβάλλονται σωστά.

Λειτουργεί σωστά το πρόγραμμα; Υπάρχει κάποια περίπτωση στην οποία η συμπεριφορά του είναι προβληματική; 

\marginnote[14pt]{\icondiscuss}
\dottedline

%\dottedline
\end{step}

\begin{step}

%\begin{note}
%\textbf{Επέκταση}: Το βήμα αυτό είναι προαιρετικό. 
%%Προχωρήστε στην υλοποίησή του μόνο εφόσον ο χρόνος επαρκεί.
%\end{note}

Εκτελέστε ακόμα μερικές φορές το πρόγραμμα. Δοκιμάστε, ως παίκτης, να δίνετε τιμές που είναι \emph{εκτός των ορίων} που προτείνει το πρόγραμμα. Τί παρατηρείτε; Δημιουργείται πρόβλημα;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Αν υπάρχει πρόβλημα όταν ο χρήστης δίνει τιμές εκτός του διαστήματος που ορίζουν οι \pyinline{low} και \pyinline{high}, προσθέστε τους κατάλληλους ελέγχους στο πρόγραμμα ώστε να διορθωθούν τυχόν σφάλματα.
\end{step}

\section{Gimme a Break}

% [comment] Η "λογική" σειρά είναι να μπει πρώτα η ενότητα αυτή. Όμως ουσιαστικά η ενότητα θα μπορούσε ακόμα και να λείπει, ενώ η επόμενη είναι πολύ σημαντική. Ίσως θα έπρεπε να είναι τα υποπρογράμματα πρώτα.

Η χρήση της \pyinline{break} είναι μια πρακτική που δεν ακολουθείται από όλους. Ορισμένοι θεωρούν ότι ο κώδικας είναι πιο κατανοητός όταν υπάρχει ένα μοναδικό σημείο εξόδου από την επανάληψη: η συνθήκη συνέχειας.

\begin{step}
Μπορούμε να χρησιμοποιήσουμε μια \emph{λογική μεταβλητή}, την οποία θα ονομάσουμε \pyinline{found}, για να ``θυμάται'' το πρόγραμμά μας αν ο χρήστης βρήκε τον μυστικό αριθμό.

\emph{Προσθέστε} στην αρχή του προγράμματός σας την εντολή:

\marginnote[18pt]{Υπάρχουν μόνο δύο \emph{λογικές} τιμές: \pyinline{True} και \pyinline{False}.}
\begin{pynew}
found = False    # η Found είναι ψευδής
\end{pynew}

Για διαγνωστικούς λόγους, \emph{προσθέστε προσωρινά} στο τέλος της επανάληψης (\emph{μέσα} σε αυτή, όχι μετά) την εντολή:

\begin{pynew}
print("Ζντονκ!", found)
\end{pynew}

Εκτελέστε το πρόγραμμά σας. Θα πρέπει \emph{σε κάθε επανάληψη} να βλέπετε το μήνυμα \pyinline{"Ζντονκ! False"}
\end{step}

\begin{step}
\emph{Προσθέστε} την εντολή που ακολουθεί στο τμήμα του προγράμματος που εκτελείται \emph{μόνο} όταν ο χρήστης εντοπίσει τον μυστικό αριθμό.

\begin{pynew}
found = True    # η Found γίνεται αληθής
\end{pynew}

Εκτελέστε το πρόγραμμα. Πότε εμφανίζεται το \pyinline{"Ζντονκ! True"} και γιατί;

\marginnote[14pt]{\icondiscuss}
\dottedline

\end{step}

\begin{step}
\emph{Αφαιρέστε} την \pyinline{break} από το πρόγραμμα. Ποιο αποτέλεσμα \emph{πιστεύετε} ότι θα έχει αυτό;
 
\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\emph{Προσθέστε} στη συνθήκη της \pyinline{while} μια επιπλέον συνθήκη που θα ελέγχει την τιμή της \pyinline{found} για να διαπιστώνει αν η επανάληψη θα πρέπει να συνεχιστεί.

Για να συνδυάσετε αυτή την συνθήκη με την ήδη υπάρχουσα συνθήκη \pyinline{tries > 0} χρησιμοποιήστε ανάμεσά τους το \pyinline{and} που έχει σαν αποτέλεσμα την \emph{σύζευξη} των συνθηκών.

Εκτελέστε το πρόγραμμα και διερευνήστε την συμπεριφορά του. Λειτουργεί σωστά ή εντοπίζετε προβλήματα;

\marginnote[14pt]{\icondiscuss}
\dottedline

Πότε εμφανίζεται το \pyinline{"Ζντονκ! True"} και γιατί;

\marginnote[14pt]{\icondiscuss}
\dottedline

\emph{Αφαιρέστε} το διαγνωστικό μήνυμα από την επανάληψη.
\end{step}

\begin{step}
\emph{Αντικαταστήστε} την συνθήκη \pyinline{number != secret} στο τέλος του παιχνιδιού με μια συνθήκη που ελέγχει την τιμή της \pyinline{found}.
\end{step}

\begin{step}
Προηγουμένως, το παιχνίδι έληγε όταν ο παίκτης έβρισκε τον αριθμό με τη χρήση της \pyinline{break}. Τώρα η \pyinline{break} αφαιρέθηκε και ο τερματισμός της επανάληψης γίνεται αποκλειστικά όταν η συνθήκη συνέχειας της \pyinline{while} είναι ψευδής. Ποια πιστεύετε ότι είναι η διαφορά ανάμεσα στις δύο περιπτώσεις;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\dottedline

\end{step}

\section{Εξαρτήματα}

\begin{step}
Και τώρα, ας \emph{ξεχάσουμε} για λίγο το πρόγραμμα που έχουμε αναπτύξει. Διαβάστε προσεκτικά τον κώδικα που ακολουθεί. Μην τον πληκτρολογήσετε, απλά εξετάστε τον.

% def readNumber(a, b):
\begin{pyplain}
print("Μάντεψε τον αριθμό.")
print("Δοκίμασε ανάμεσα στο", a, "και το", b)
c = int(input())    
print("Έδωσες τον αριθμό", c)
\end{pyplain}

Ποιες μεταβλητές χρειάζεται να έχουν \emph{ήδη} τιμή για να λειτουργήσει αυτό το τμήμα κώδικα;

\marginnote[14pt]{\icondiscuss}
\dottedline

Σε ποιες μεταβλητές αποδίδεται τιμή σε αυτό το τμήμα κώδικα; 

\marginnote[14pt]{\icondiscuss}
\dottedline

Περιγράψτε, όσο καλύτερα μπορείτε, τη λειτουργία αυτού του μικρού τμήματος κώδικα. Τί θα λέγατε ότι κάνει;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\dottedline

Υπάρχει κάποιο τμήμα κώδικα στο πρόγραμμά σας που να εκτελεί αυτή τη συγκεκριμένη λειτουργία; 

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
Θα διαπιστώσατε ότι το πρόγραμμα περιλαμβάνει ένα τέτοιο τμήμα κώδικα, το οποίο χρησιμοποιείται για να εισαχθεί από το χρήστη μια πιθανή τιμή για τον μυστικό αριθμό.

Θα περικλείσουμε αυτόν τον κώδικα σε μια \emph{συνάρτηση}, ένα \emph{υποπρόγραμμα} που επιτελεί μια συγκεκριμένη λειτουργία.

\emph{Προσθέστε} στην αρχή του προγράμματος τα εξής:

\marginnote[16pt]{% 
\begin{center}
\includegraphics[scale=0.9]{../illustrations/function-readNumber.pdf}
\end{center}
Εικόνα: Η συνάρτηση \pyinline{readNumber} είναι ένα ανεξάρτητο τμήμα κώδικα, ένα αυτόνομο ``εξάρτημα'' που επιτελεί μια συγκεκριμένη λειτουργία.}
\begin{pynew}
def readNumber(a,b):
    print("Μάντεψε τον αριθμό.")
    print("Δοκίμασε ανάμεσα στο", a, "και το", b)
    c = int(input())    
    print("Έδωσες τον αριθμό", c)
    return c
\end{pynew}

Με τον τρόπο αυτό \emph{ορίζεται} η συνάρτηση \pyinline{readNumber}, η οποία λειτουργεί ως εξής: Δέχεται δύο παραμέτρους, δύο τιμές που τις ονομάζει \pyinline{a} και \pyinline{b} για να μπορεί να αναφέρεται σε αυτές. Προτρέπει το χρήστη να πληκτρολογήσει έναν αριθμό μεταξύ των \pyinline{a} και \pyinline{b} και \emph{επιστρέφει} με την εντολή \pyinline{return} την ακέραια τιμή που πληκτρολογεί ο χρήστης.

\begin{note}
Οι μεταβλητές \pyinline{a}, \pyinline{b} και \pyinline{c} έχουν \emph{τοπική εμβέλεια}, δηλαδή δεν είναι ``ορατές'' από το υπόλοιπο πρόγραμμα. Δημιουργούνται εκ νέου κάθε φορά που εκτελείται η συνάρτηση \pyinline{readNumber} και μετά παύουν να υφίστανται.
\end{note}

Γιατί φτιάξαμε αυτό το μικρό ``εξάρτημα''; Πρώτον, για να το χρησιμοποιήσουμε στο πρόγραμμά μας. Δεύτερον, για να μπορέσουμε αργότερα να το αντικαταστήσουμε με παρόμοια εξαρτήματα που κάνουν την ίδια δουλειά (επιστρέφουν μια πιθανή τιμή για τον μυστικό αριθμό) με διαφορετικό τρόπο.
\end{step}

%\clearpage
\begin{step}
Κατασκευάσαμε ένα ``εξάρτημα'' που ονομάζεται \pyinline{readNumber} και επιτελεί μια συγκεκριμένη λειτουργία, ωστόσο δεν το έχουμε ακόμα \emph{χρησιμοποιήσει}.

\emph{Εντοπίστε} στο πρόγραμμά σας τις παρακάτω εντολές:

\begin{pyplain}
    print("Μάντεψε τον αριθμό.")
    print("Δοκίμασε ανάμεσα στο", low, "και το", high)
    number = int(input())    
    print("Έδωσες τον αριθμό", number)
\end{pyplain}

\emph{Διαγράψτε} τις και \emph{αντικαταστήστε} με την παρακάτω γραμμή:

\begin{pynew}
    number = readNumber(low, high)
\end{pynew}

Κατά την εκτέλεση του προγράμματος, αυτή η γραμμή θα \emph{καλέσει} την \pyinline{readNumber}, θα ενεργοποιήσει την εκτέλεση των εντολών της, παρέχοντας ως παραμέτρους τις τιμές των \pyinline{low} και \pyinline{high}. Την τιμή που επιστρέφεται από την συνάρτηση την ονομάζουμε \pyinline{number}.

Εκτελέστε το πρόγραμμα. Παρατηρείτε κάποια διαφορά στον τρόπο που λειτουργεί;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
\label{step:readNumber-call}
\emph{Προσθέστε} στην αρχή του προγράμματός σας τον κώδικα που ακολουθεί. \emph{Συμπληρώστε} κατάλληλα τις γραμμές που συνοδεύονται από σχόλιο, έτσι ώστε η συνάρτηση \pyinline{randNumber} που ορίζεται εδώ \emph{να επιστρέφει έναν τυχαίο αριθμό} ανάμεσα στα \pyinline{a} και \pyinline{b}.

\begin{pynew}
import time
def randNumber(a,b):
    print("Μάντεψε τον αριθμό.")
    print("Δοκίμασε ανάμεσα στο", a, "και το", b)
    c = |\textrm{\textit{επιλογή τυχαίου αριθμού}}|             # συμπληρώστε
    print("Το πρόγραμμα επιλέγει", c)
    time.sleep(3)
    return |\textrm{\textit{επιστροφή τιμής}}|                # συμπληρώστε
\end{pynew}

Στο κύριο πρόγραμμα, εντοπίστε την εντολή με την οποία η μεταβλητή \pyinline{number} παίρνει τιμή από την συνάρτηση \pyinline{readNumber} και \emph{προσθέστε} μπροστά από την εντολή το σύμβολο \#. Αυτό έχει σαν αποτέλεσμα η εντολή αυτή να θεωρείται \emph{σχόλιο} και να αγνοείται κατά την εκτέλεση του προγράμματος.

\begin{note}
Είναι συνηθισμένο να ``σχολιάζουμε'' μια εντολή όταν θέλουμε να παρακαμφθεί, χωρίς όμως να την αφαιρέσουμε πλήρως από το πρόγραμμα. Έτσι μπορούμε να την επαναφέρουμε αργότερα, αν αυτό είναι απαραίτητο.
\end{note}

Στο ίδιο σημείο, \emph{προσθέστε} μια εντολή με την οποία η μεταβλητή \pyinline{number} θα παίρνει τιμή από την συνάρτηση \pyinline{randNumber}, με παραμέτρους τις τιμές των \pyinline{low} και \pyinline{high}. Αν δυσκολευτείτε, ανατρέξτε στο βήμα~\ref{step:readNumber-call}, όπου γίνεται κάτι ανάλογο.

%\clearpage
Ουσιαστικά, εκεί που το πρόγραμμα χρησιμοποιούσε τη \pyinline{readNumber} για να αποκτηθεί μια πιθανή τιμή για τον μυστικό αριθμό, τώρα αυτή αντικαταστάθηκε από την \pyinline{randNumber}.

Χρησιμοποιείται πουθενά στο πρόγραμμα η \pyinline{input}, για να παρέχει οποιαδήποτε είσοδο ο χρήστης; Αν όχι, ποιος θα επιλέγει τώρα αριθμούς, προσπαθώντας να μαντέψει τον τυχαίο αριθμό;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Εκτελέστε το πρόγραμμα. Τι αλλαγή επιφέρει η χρήση της συνάρτησης \pyinline{randNumber}, αντί για τη \pyinline{readNumber};

\clearpage
\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

\begin{step}
Όταν ξεκινά το πρόγραμμα και γνωρίζετε ότι ο μυστικός αριθμός βρίσκεται κάπου ανάμεσα στο \pyinline{1} και το \pyinline{32}, ποια τιμή σας φαίνεται προτιμότερο να επιλέξετε;

\marginnote[14pt]{\icondiscuss}

\dottedline

Αν γνωρίζετε ότι ο μυστικός αριθμός βρίσκεται κάπου ανάμεσα στο \pyinline{13} και το \pyinline{23}, ποια τιμή σας φαίνεται προτιμότερο να επιλέξετε;

\marginnote[14pt]{\icondiscuss}
\dottedline

Αν γνωρίζετε ότι ο μυστικός αριθμός βρίσκεται κάπου ανάμεσα στο \pyinline{low} και το \pyinline{high}, ποια τιμή σας φαίνεται προτιμότερο να επιλέξετε και γιατί;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

%\dottedline
\end{step}

\begin{step}
Κατασκευάστε μια συνάρτηση \pyinline{midNumber}. Η συνάρτηση θα δέχεται σαν παραμέτρους δύο τιμές, που θ' αντιστοιχούν στα όρια του διαστήματος μέσα στο οποίο γνωρίζουμε ότι βρίσκεται ο μυστικός αριθμός, και θα επιστρέφει την τιμή που βρίσκεται%
\marginnote[3pt]{Ο μυστικός αριθμός είναι ακέραιος, άρα η τιμή που επιλέγει η \pyinline{midNumber} πρέπει να είναι επίσης ακέραια. Φροντίστε να χρησιμοποιήσετε τον τελεστή \pyinline{//} της \emph{ακέραιας} διαίρεσης για τον υπολογισμό του μέσου του διαστήματος.}
\emph{στο μέσο αυτού του διαστήματος}.

\begin{note}
Χρησιμοποιήστε ως πρότυπα τις \pyinline{readNumber} και \pyinline{randNumber}.
\end{note}

Στο κύριο πρόγραμμα, εντοπίστε την εντολή με την οποία η μεταβλητή \pyinline{number} παίρνει τιμή από την συνάρτηση \pyinline{randNumber} και \emph{προσθέστε} μπροστά από την εντολή το σύμβολο \#.

Στο ίδιο σημείο, \emph{προσθέστε} μια εντολή με την οποία η μεταβλητή \pyinline{number} θα παίρνει τιμή από την συνάρτηση \pyinline{midNumber}, με παραμέτρους τις τιμές των \pyinline{low} και \pyinline{high}.
\end{step}

Εκτελέστε το πρόγραμμα μερικές φορές. Καταφέρνει να εντοπίσει τον μυστικό αριθμό;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

% [comment] Μου φαίνεται ότι τελειώνει πολύ απότομα. Δεν θέλουμε να τους ρωτήσουμε τίποτα περισσότερο εδώ; [discuss]

\section{Δραστηριότητες για Εξάσκηση}

\marginnote[16pt]{\href{http://pythonies.mysch.gr/complete/}{\url{pythonies.mysch.gr/complete}}}%
Για περισσότερη εξάσκηση στις έννοιες που γνωρίσατε σ' αυτό το φύλλο εργασίας, μπορείτε ν' ανατρέξετε στις ασκήσεις των %
Κεφαλαίων \href{http://pythonies.mysch.gr/chapters/craps.pdf}{``Μπαρμπούτι''} και \href{http://pythonies.mysch.gr/chapters/guess.pdf}{``Μάντεψε τον Αριθμό''}.

\end{document}

