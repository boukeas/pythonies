\documentclass[a4paper,11pt,oneside]{book}

\input{../share/tuftelike}
\input{../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{3}

%%% DOCUMENT START

\begin{document}

\chapterwabstract{Μάντεψε τον Αριθμό}{Ένα από τα πρώτα προγράμματα που συνηθίζεται να φτιάχνουν οι μαθητευόμενοι προγραμματιστές είναι ένα παιχνίδι στο οποίο ο παίκτης προσπαθεί να μαντέψει τον \emph{μυστικό αριθμό} που έχει ``σκεφτεί'' ο υπολογιστής ή το αντίστροφο. Υπάρχουν πολλοί καλοί λόγοι που αυτό το παιχνίδι είναι μια τόσο δημοφιλής επιλογή για τους αρχάριους: το πρόγραμμα που προκύπτει δεν είναι ιδιαίτερα περίπλοκο, αν και συνδυάζει όλες τις βασικές αλγοριθμικές έννοιες, ενώ το παιχνίδι καθεαυτό είναι πολύ διασκεδαστικό.}{δομή επιλογής, δομή επανάληψης, αναζήτηση.}{guessColor}{white}

%%%%%%%%

\section{Έχω Ένα Μυστικό}

Ας ξεκινήσουμε ονομάζοντας τον μυστικό αριθμό \pyinline{secret} και δίνοντάς του μια τυχαία τιμή από το \pyinline{1} μέχρι και το \pyinline{32}.
\marginnote[18pt]{Εισάγουμε τη βιβλιοθήκη \pyinline{random} για να χρησιμοποιήσουμε την συνάρτηση \pyinline{randint()}, που παράγει τυχαίους ακέραιους εντός καθορισμένων ορίων.}%

\pyfile[firstline=1,lastline=3]{src/guess.1.py}

Τώρα θα ζητήσουμε από το χρήστη να μαντέψει τον μυστικό αριθμό.
%, αφού πρώτα του εμφανίσουμε στην οθόνη ένα κατάλληλο μήνυμα, μια \emph{προτροπή}. Στην τιμή που εισάγει ο χρήστης από το πληκτρολόγιο δίνουμε το όνομα \pyinline{number}.

\marginnote[18pt]{Κάθε τιμή έχει συγκεκριμένο \emph{τύπο}. Η τιμή που επιστρέφει η \pyinline{input()} είναι \emph{αλφαριθμητική}, είναι το κείμενο που πληκτρολόγησε ο χρήστης. Χρειάζεται να μετατρέψουμε την τιμή αυτή σε ακέραιο αριθμό, να της αλλάξουμε τον τύπο, και για την μετατροπή αυτή χρησιμοποιούμε την \pyinline{int()}.}
\marginnote{Στην Python, οι ακέραιες τιμές είναι τύπου \pyinline{int}, ενώ οι αλφαριθμητικές είναι τύπου \pyinline{str}. Κάθε αλφαριθμητική τιμή περικλείεται σε εισαγωγικά (μονά ή διπλά). Τα μηνύματα που εμφανίζουμε είναι αλφαριθμητικές τιμές, γι' αυτό περικλείονται σε εισαγωγικά.}
\pyfile[firstline=4,lastline=6]{src/guess.1.py}

%%%%%%%%

\section{Το Βρήκα;}

\begin{question}
%Τώρα υπάρχουν τιμές για τον μυστικό αριθμό και τον αριθμό του χρήστη.
Πώς μπορώ να ελέγξω αν ο χρήστης μάντεψε τον μυστικό αριθμό;
\end{question}

Με μια δομή επιλογής θα συγκρίνουμε τον αριθμό \pyinline{number} που έδωσε ο χρήστης με τον μυστικό αριθμό \pyinline{secret} και θα εκτελέσουμε διαφορετικές εντολές ανάλογα με το αποτέλεσμα της σύγκρισης. 
%Υπάρχουν δύο περιπτώσεις (να έχει βρεθεί ο αριθμός ή όχι) και σε κάθε μια από αυτές θα χρειαστεί να εκτελέσουμε διαφορετικές εντολές.

\marginnote{Με το \pyinline{!=} ελέγχεται αν δύο τιμές είναι διαφορετικές.}
% Άλλοι συγκριτικοί τελεστές είναι οι \pyinline{<}, \pyinline{<=} (μικρότερο ή ίσο), \pyinline{>} και \pyinline{>=} (μεγαλύτερο ή ίσο).}
\pyfilesrc[firstline=7,lastline=11]{src/guess.1.py}

%Η σύγκριση ανάμεσα στον \pyinline{number} και στον \pyinline{secret} μπορεί να γίνει και \emph{αντίστροφα}.
%\clearpage
%\marginnote[18pt]{Με το \pyinline{==} ελέγχεται αν δύο τιμές είναι ίσες. Διαφέρει από το \pyinline{=} που χρησιμοποιείται για να δώσουμε τιμή σε μια μεταβλητή.}%
%\begin{pycode}
%# έλεγχος αριθμού και εμφάνιση μηνύματος
%if number == secret:
%    print("Σωστά!")
%else:
%    print("Λάθος.")
%\end{pycode}

%είναι απολύτως αναγκαίο να ελέγχετε αν τα προγράμματά σας λειτουργούν σωστά, εκτελώντας τα και παίζοντας το ρόλο του χρήστη. Όταν ένα πρόγραμμα περιέχει μια δομή επιλογής με δύο περιπτώσεις τότε θα πρέπει να το εκτελέσετε (τουλάχιστον) δύο φορές, δίνοντας κάθε φορά ως χρήστης τις κατάλληλες τιμές που θα οδηγήσουν το πρόγραμμά σας να πάρει τους διαφορετικούς ``δρόμους'' που αντιστοιχουν στις διαφορετικές περιπτώσεις. 

\clearpage
Αν εκτελέσετε το πρόγραμμά σας και πληκτρολογήσετε έναν αριθμό τότε αυτό θα σας απαντήσει \pyinline{"Σωστά!"} ή \pyinline{"Λάθος."} Για να επαληθεύσετε ότι αυτή η απάντηση είναι ορθή, θα πρέπει να γνωρίζετε τον μυστικό αριθμό, πράγμα δύσκολο όταν αυτός καθορίζεται τυχαία. 

Για να ελέγξετε λοιπόν ότι το πρόγραμμά σας λειτουργεί σωστά, θα μπορούσατε \emph{προσωρινά} να εμφανίζετε τον μυστικό αριθμό.

\begin{pycode}
# ΓΙΑ ΕΛΕΓΧΟ: εμφάνιση του μυστικού αριθμού
print(secret)
\end{pycode}

Εναλλακτικά, θα μπορούσατε να ορίσετε έναν συγκεκριμένο μυστικό αριθμό της επιλογής σας, αντί να παράγετε έναν τυχαίο:

\begin{pycode}
# ΓΙΑ ΕΛΕΓΧΟ: ορισμός μυστικού αριθμού
secret = 13
\end{pycode}

Έτσι θα μπορέσετε να επιβεβαιώσετε αν το πρόγραμμά σας λειτουργεί σωστά όταν του δίνετε έναν αριθμό. Στην τελική εκδοχή του προγράμματος, όταν οι έλεγχοι έχουν ολοκληρωθεί, θα πρέπει να αφαιρέσετε αυτές τις εντολές.

%Θυμηθείτε πως όταν γράφουμε το πρόγραμμα δεν μπορούμε να ξέρουμε εκ των προτέρων ούτε τον μυστικό αριθμό, ούτε τον αριθμό που θα πληκτρολογήσει ο χρήστης. Επομένως, δεν υπάρχει τρόπος να ξέρουμε αν ο χρήστης θα μαντέψει τον μυστικό αριθμό ή όχι και είμαστε αναγκασμένοι να καθορίσουμε τις εντολές που πρέπει να εκτελεστούν και στη μία αλλά και στην άλλη περίπτωση. Ωστόσο, κατά την εκτέλεση του προγράμματος, η συνθήκη θα ελεγχθεί, θα διαπιστωθεί κατά πόσο ισχύει ή όχι και θα εκτελεστούν \emph{μόνο} οι εντολές που αντιστοιχούν στη μία από τις δύο περιπτώσεις. 

%%%%%%%%

\section{Γύρω-Γύρω Όλοι}

\marginnote[18pt]{Η επαναληπτική δομή \pyinline{while} συνοδεύεται από μια \emph{συνθήκη συνέχειας}. Η συνθήκη ελέγχεται στην αρχή κάθε κύκλου της επανάληψης και μπορεί να είναι αληθής (\pyinline{True}) ή ψευδής (\pyinline{False}). Όσο η συνθήκη είναι αληθής, η επανάληψη συνεχίζεται για άλλον έναν κύκλο.}% Μην παραλείπετε το σύμβολο \pyinline{:} μετά την συνθήκη.}%
\marginnote{Μην παραλείπετε το σύμβολο \pyinline{:} μετά την συνθήκη.}%
\marginnote{Η τετριμμένη συνθήκη \pyinline{True} είναι πάντα αληθής κι έτσι η συγκεκριμένη επανάληψη δεν πρόκειται να διακοπεί λόγω της συνθήκης.} %(θα διακοπεί όμως λόγω της \pyinline{break}).}
\marginnote{Οι εντολές που ακολουθούν τη \pyinline{while} είναι στοιχισμένες δεξιότερα. Η στοίχιση αυτή υποδηλώνει ότι αυτές οι εντολές θα επαναλαμβάνονται. Η πρώτη εντολή μετά τη \pyinline{while} που δεν θα είναι στοιχισμένη δεξιότερα δεν θα επαναλαμβάνεται, αλλά θα εκτελεστεί μόνο μια φορά, όταν η επανάληψη τερματιστεί.}% 

\begin{question}
Πως γίνεται η διαδικασία να επαναλαμβάνεται, έτσι ώστε ο χρήστης να έχει περισσότερες προσπάθειες για να μαντέψει τον αριθμό;
\end{question}

%Κάθε γλώσσα προγραμματισμού προσφέρει \emph{επαναληπτικές δομές}\marginnote{Στην Python, η βασική επαναληπτική δομή είναι η \pyinline{while}, η οποία μπορεί να χρησιμοποιηθεί σε κάθε περίπτωση, ενώ για συγκεκριμένου είδους επαναλήψεις υπάρχει και η δομή \pyinline{for}.}, δηλαδή τρόπους να εκφράσει κανείς ότι ένα σύνολο εντολών θα πρέπει να επαναλαμβάνεται.%
%Ο προγραμματιστής προσδιορίζει τις εντολές που είναι \emph{εμφωλευμένες} στη δομή και εκτελούνται επαναληπτικά.%, αλλά και μια \emph{συνθήκη} που ελέγχεται σε κάθε κύκλο της επανάληψης και καθορίζει αν η επανάληψη πρέπει να συνεχιστεί ή όχι.

Οι εντολές που διαβάζουν έναν αριθμό από το χρήστη και τον συγκρίνουν με τον μυστικό αριθμό θα πρέπει να τοποθετηθούν μέσα σε μια \emph{επαναληπτική δομή}.

\pyfilesrc[firstline=4,lastline=14]{src/guess.2.py}

%%%%%%%%

\section{Σταματήστε Να Κατέβω}

\begin{question}
Δεν θα πρέπει να σταματά η επανάληψη όταν βρεθεί ο αριθμός;
\end{question}

Οι εντολές που τοποθετήθηκαν στην επαναληπτική δομή εκτελούνται \emph{συνεχώς} και δεν διακόπτονται ούτε καν όταν ο χρήστης μαντέψει τον μυστικό αριθμό. Ένας απλός τρόπος να τερματιστεί η επανάληψη είναι με την προσθήκη της εντολής \pyinline{break} όταν ο παίκτης εντοπίσει τον μυστικό αριθμό.

\clearpage
\marginnote[18pt]{Η \pyinline{break} διακόπτει και τερματίζει \emph{άμεσα} τον κύκλο της επανάληψης, χωρίς να ελεγχθεί η συνθήκη συνέχειας.} 
\pyfilenl[firstline=4,lastline=18]{src/guess.3.break.py}

Ωστόσο εμείς θα συνεχίσουμε με μια εκδοχή στην οποία η επανάληψη δεν διακόπτεται άμεσα με την \pyinline{break} αλλά μόνο όταν η συνθήκη συνέχειας ελεγχθεί και διαπιστωθεί ότι είναι ψευδής.

\marginnote[18pt]{Υπάρχουν δύο \emph{λογικές} τιμές: \pyinline{True} και \pyinline{False}, οι οποίες είναι τύπου \pyinline{bool}.}
\marginnote{Το \pyinline{not} χρησιμοποιείται πριν από μια συνθήκη και \emph{αντιστρέφει} την τιμή της: όταν μια συνθήκη είναι ψευδής τότε η αντίστροφή της είναι αληθής και το ανάποδο.}
\pyfilesrc[firstline=4,lastline=18]{src/guess.3.py}

H μεταβλητή \pyinline{found} λειτουργεί ως \emph{σημαία} και χρησιμοποιείται για να ``θυμάται'' το πρόγραμμά μας αν ο παίκτης έχει βρει τον μυστικό αριθμό. Αρχικά ορίζεται ως ψευδής και όσο εξακολουθεί να είναι ψευδής η επανάληψη συνεχίζεται. Όταν ο παίκτης βρει τον αριθμό, η τιμή της \pyinline{found} αλλάζει σε αληθής.
% -- εκεί που στην προηγούμενη εκδοχή συναντούσαμε την \pyinline{break}.

%Η συνθήκη συνέχειας της επανάληψης θα μπορούσε εναλλακτικά να γραφτεί και με τους δύο ακόλουθους τρόπους:
%\begin{pycode}
%# επανάληψη:
%#   τερματίζεται όταν βρεθεί ο αριθμός
%while found == False:
%\end{pycode}

%\begin{pycode}
%# επανάληψη:
%#   τερματίζεται όταν βρεθεί ο αριθμός
%while found != True:
%\end{pycode}

Εφόσον το παιχνίδι θα πρέπει να συνεχίζεται όσο ο χρήστης δεν έχει μαντέψει τον μυστικό αριθμό, ίσως αναρωτιέστε γιατί η συνθήκη συνέχειας δεν έχει απλά την εξής μορφή:

\begin{pycode}
while number != secret:
\end{pycode}

Αυτή είναι μια εξαιρετική παρατήρηση και η απάντηση είναι πολύ απλή: γιατί την πρώτη φορά που θα ελεγχθεί η συνθήκη, την πρώτη φορά που η εκτέλεση του προγράμματος φτάσει στη \pyinline{while}, η μεταβλητή \pyinline{number} δεν θα έχει πάρει ακόμα τιμή. Θα μπορούσαμε να της δώσουμε προηγουμένως μια \emph{πλασματική} τιμή, μόνο και μόνο για να ξεκινήσει η επανάληψη. Θα μπορούσαμε επίσης να ανακατατάξουμε τις εντολές μας έτσι ώστε η \pyinline{number} να παίρνει τιμή από τον χρήστη \emph{πριν} γίνει ο έλεγχος της συνθήκης. Όμως η πρώτη λύση είναι λίγο άκομψη, ενώ η δεύτερη καταλήγει κάπως δυσνόητη για κάποιον που κάνει μόλις τα πρώτα του βήματα στη δομή επανάληψης.

%%%%%%%%

\section{Το Μέτρημα}

\begin{question}
Το παιχνίδι δεν έχει ιδιαίτερο ενδιαφέρον αν ο χρήστης διαθέτει απεριόριστες ευκαιρίες
να μαντέψει τον αριθμό. Πως γίνεται να του δώσουμε μόνο ένα μικρό πλήθος προσπαθειών;
\end{question}

Σε κάθε κύκλο του παιχνιδιού, θα πρέπει το πρόγραμμά μας να ``γνωρίζει'' πόσες προσπάθειες απομένουν στο χρήστη. Αυτό είναι απαραίτητο γιατί ο χρήστης θα πρέπει να ενημερώνεται σχετικά, αλλά κυρίως επειδή το ίδιο το πρόγραμμα χρειάζεται αυτή την πληροφορία για να γνωρίζει πότε θα τερματιστεί το παιχνίδι. Για τον σκοπό αυτό θα χρησιμοποιήσουμε την μεταβλητή \pyinline{tries}, με τη βοήθεια της οποίας θα καταμετρούμε τις προσπάθειες που απομένουν.

Αρχικά, ας δώσουμε στο χρήστη τέσσερις προσπάθειες, προσθέτοντας την ακόλουθη εντολή πριν την έναρξη της επανάληψης.

\pyfile[firstline=6,lastline=7]{src/guess.4.py}

Η απόδοση αρχικής τιμής σε μια μεταβλητή, όπως έγινε εδώ για την μεταβλητή \pyinline{tries}, ονομάζεται \emph{αρχικοποίηση}. Κατά τη διάρκεια του παιχνιδιού, καθώς ο παίκτης προσπαθεί να μαντέψει τον αριθμό, η τιμή της \pyinline{tries} θα τροποποιηθεί, όμως η αρχική τιμή καθορίζει το σημείο εκκίνησης.

%Αναρωτηθείτε αν αυτό το πλήθος προσπαθειών είναι επαρκές, θεωρώντας ότι ο χρήστης εκμεταλλεύεται στο έπακρο όλες τις πληροφορίες που του δίνονται από το πρόγραμμα.

Ο τερματισμός του παιχνιδιού εξαρτάται τώρα και από το πλήθος των προσπαθειών που απομένουν. Στην αρχή κάθε κύκλου της επανάληψης θα ελέγχεται αν ο μυστικός αριθμός έχει βρεθεί, αλλά και αν η μεταβλητή \pyinline{tries} είναι θετική, δηλαδή αν απομένουν ακόμα προσπάθειες. Αν κάποια από αυτές τις συνθήκες δεν ισχύει, η επαναληπτική διαδικασία διακόπτεται. 

\marginnote[18pt]{Το \pyinline{and} χρησιμοποιείται για τη σύζευξη δύο συνθηκών. Η σύζευξη είναι αληθής μόνο όταν \emph{και οι δύο} συζευγμένες συνθήκες είναι αληθείς.}
\pyfile[firstline=8,lastline=10]{src/guess.4.py}

Σε κάθε γύρο του παιχνιδιού, ο χρήστης ενημερώνεται με ένα μήνυμα για το πλήθος των προσπαθειών που απομένουν, ενώ στη συνέχεια η ποσότητα αυτή (η μεταβλητή \pyinline{tries}) μειώνεται κατά μία μονάδα.

\pyfile[firstline=11,lastline=13]{src/guess.4.py}

\clearpage
H τελευταία εντολή μπερδεύει πολλούς αρχάριους γιατί την ερμηνεύουν σαν μαθηματική ισότητα, ενώ δεν είναι. Για να γίνει κατανοητή, πρέπει να διαβαστεί ως εξής: υπολόγισε την τιμή της παράστασης \pyinline{tries - 1} κι ονόμασε το αποτέλεσμα \pyinline{tries}. Η νέα τιμή της μεταβλητής \pyinline{tries} υπολογίζεται με βάση την τρέχουσα τιμή της, την οποία και αντικαθιστά. 

Προσέξτε πως όταν η \pyinline{tries} γίνει μηδέν, η επανάληψη \emph{δεν} θα τερματιστεί άμεσα, αφού η συνθήκη συνέχειας δεν ελέγχεται συνεχώς, αλλά μόνο στην αρχή κάθε νέου κύκλου. Επομένως, ο κύκλος των εντολών θα ολοκληρωθεί και μόνο τότε θα διαπιστωθεί ότι η \pyinline{tries} μηδενίστηκε, με αποτέλεσμα τη διακοπή της επανάληψης.

Όταν η επανάληψη διακοπεί, το παιχνίδι θα έχει τελειώσει. Δεν θα γνωρίζουμε όμως \emph{για ποιο λόγο} τελείωσε. Μάντεψε ο παίκτης τον μυστικό αριθμό ή απλά εξαντλήθηκαν οι προσπάθειές του; Στη δεύτερη περίπτωση ο παίκτης θα έχει χάσει και είναι απαραίτητο να εμφανίζουμε ένα μήνυμα που θα τον ενημερώνει ποιος ήταν ο μυστικός αριθμός (για να μην πιστεύει ότι τον κλέβουμε).

\marginnote[18pt]{Οι εντολές αυτές είναι στοιχισμένες πιο αριστερά από τις προηγούμενες. Αυτό υποδηλώνει ότι δεν ανήκουν στην επανάληψη, αντίθετα είναι οι πρώτες εντολές που θα εκτελεστούν όταν η επανάληψη διακοπεί.}
\pyfilesrc[firstline=24]{src/guess.4.py}

%%%%%%%%

\section{Περισσότερη Πληροφορία}

\begin{question}
Θα ήθελα η απάντηση που δίνεται στο χρήστη να τον βοηθάει λίγο περισσότερο να βρει τον αριθμό.
Αντί να ενημερώνεται αν τον μάντεψε ή όχι, θα μπορούσε να κατευθύνεται να ψάξει προς τα πάνω 
ή προς τα κάτω.
\end{question}

Μέχρι στιγμής, σε κάθε προσπάθεια το πρόγραμμα ελέγχει αν ο αριθμός που έδωσε ο χρήστης ταυτίζεται με τον μυστικό αριθμό. Τώρα θα επεκτείνουμε αυτόν τον έλεγχο, έτσι ώστε να ελέγχεται αν ο αριθμός του χρήστη είναι μεγαλύτερος ή μικρότερος από τον μυστικό αριθμό. Σε κάθε περίπτωση θα εμφανίζεται διαφορετικό μήνυμα, έτσι ώστε ο χρήστης να \emph{κατευθύνεται} προς τον μυστικό αριθμό.

\marginnote[18pt]{Το \pyinline{elif} σημαίνει \pyinline{else if}. Χρησιμοποιείται στη δομή \emph{πολλαπλής επιλογής}, δηλαδή όταν χρειάζεται να διακρίνουμε ανάμεσα σε περισσότερες από δύο περιπτώσεις.}
\marginnote{Κάθε \pyinline{elif}, όπως και η \pyinline{if}, συνοδεύεται από μια \emph{συνθήκη}. Μετά από μια \pyinline{if} μπορούμε να χρησιμοποιήσουμε όσες διαδοχικές \pyinline{elif} είναι απαραίτητες. Οι συνθήκες ελέγχονται διαδοχικά, η μία μετά την άλλη, μέχρι να βρεθεί μία που να είναι αληθής, οπότε και εκτελούνται οι αντίστοιχες εντολές.}
%Η συνθήκη μιας \pyinline{elif} ελέγχεται μόνο αν η συνθήκη που προηγείται αυτής της \pyinline{elif} είναι ψευδής.}%
\pyfilesrc[firstline=17,lastline=25]{src/guess.5.py}

Σκεφτείτε πόση περισσότερη \emph{πληροφορία} παρέχεται στο χρήστη με αυτή την μικρή αλλαγή. Προηγουμένως, κάθε αποτυχημένη προσπάθεια απέκλειε έναν από τους υποψήφιους αριθμούς. Τώρα μια αποτυχημένη προσπάθεια αποκλείει και \emph{όλους} τους αριθμούς που είναι μικρότεροι ή μεγαλύτεροι από αυτόν που επέλεξε ο χρήστης. 

%Αναλογιστείτε ποιον αριθμό πρέπει να επιλέγει σε κάθε προσπάθεια ο χρήστης, έτσι ώστε οι αριθμοί που αποκλείονται να είναι όσο το δυνατόν περισσότεροι.

%Θα λέγαμε ότι ο έλεγχος μιας συνθήκης ανοίγει δύο πιθανούς δρόμους εκτέλεσης. % σχήμα;
%Το πρόγραμμά μας τελικά θα ακολουθήσει μόνο έναν από τους δύο, ανάλογα με το αποτέλεσμα του ελέγχου. Επειδή είναι αδύνατο να προδικάσουμε το αποτέλεσμα όταν γράφουμε το πρόγραμμα, είμαστε υποχρεωμένοι να καθορίσουμε τι πρέπει να συμβεί και στις δύο περιπτώσεις. Αν οι πιθανοί δρόμοι εκτέλεσης είναι περισσότεροι από δύο, τότε ο έλεγχος μιας συνθήκης δεν επαρκεί για να προσδιορίσουμε ποιες εντολές πρέπει να εκτελεστούν και θα πρέπει να ελέγξουμε κι άλλες συνθήκες. Σε λίγο θα εξετάσουμε πως ακριβώς γίνεται αυτό.

%%%%%%%%

\section{Ακόμα Περισσότερη Πληροφορία}

\begin{question}
Μετά από μερικές προσπάθειες γίνεται δύσκολο για το χρήστη να θυμάται που ακριβώς έχει περιορίσει
τον μυστικό αριθμό, δηλαδή από ποιον αριθμό είναι μεγαλύτερος και από ποιον μικρότερος.
Πως γίνεται αυτή την πληροφορία να τη ``θυμάται'' το πρόγραμμα (αντί για τον χρήστη) και να τον
ενημερώνει κατάλληλα για να τον βοηθά στις επιλογές του;
\end{question}

\marginnote[18pt]{\begin{center}\includegraphics[scale=0.9]{illustrations/binary-lowhigh.pdf}\end{center}
Ο μυστικός αριθμός βρίσκεται κάπου ανάμεσα στα όρια \pyinline{low} και \pyinline{high}.}
Ο,τιδήποτε είναι ανάγκη να ``θυμάται'' το πρόγραμμα αποθηκεύεται σε μεταβλητές. Θα χρησιμοποιήσουμε λοιπόν την μεταβλητή \pyinline{low} για την ελάχιστη τιμή που θα μπορούσε να λάβει ο μυστικός αριθμός και την μεταβλητή \pyinline{high} για την αντίστοιχη μέγιστη τιμή.

Στην αρχή του προγράμματος θα πρέπει να αποδώσουμε στις μεταβλητές αυτές μια αρχική τιμή -- θα τις \emph{αρχικοποιήσουμε}. 

\pyfile[firstline=2,lastline=7]{src/guess.6.py}

%\marginnote{Εδώ θα βάλουμε ένα ωραίο σχήμα.}
%Μέσα στην επανάληψη, στην αρχή κάθε προσπάθειας, εμφανίζουμε τις τιμές αυτών των ορίων για να βοηθήσουμε το χρήστη στην επιλογή αριθμού. 
Μέσα στην επανάληψη εμφανίζουμε τις τιμές αυτών των ορίων, για να βοηθήσουμε το χρήστη στην επιλογή αριθμού. 

\marginnote[18pt]{\begin{center}\includegraphics[scale=0.9]{illustrations/binary-number.pdf}\end{center}
Επιλέγεται ένας αριθμός \pyinline{number} μεταξύ \pyinline{low} και \pyinline{high}.}
\pyfile[firstline=18,lastline=20]{src/guess.6.py}

Θα φροντίσουμε όμως οι μεταβλητές \pyinline{low} και \pyinline{high} να τροποποιούνται κατάλληλα μετά από κάθε λανθασμένη επιλογή του χρήστη. 

\marginnote[18pt]{\begin{center}\includegraphics[scale=0.9]{illustrations/binary-lower.pdf}\end{center}
Αν ο μυστικός αριθμός είναι μικρότερος από το \pyinline{number} τότε και το άνω όριο \pyinline{high} πρέπει να γίνει μικρότερο από το \pyinline{number}.}
Συγκεκριμένα, όταν ο χρήστης επιλέξει έναν αριθμό \pyinline{number} που είναι μεγαλύτερος από τον μυστικό, τότε η μεταβλητή \pyinline{high} πρέπει να τροποποιηθεί κατάλληλα: ο μυστικός αριθμός δεν μπορεί να είναι μεγαλύτερος από το \pyinline{number-1}. 

\pyfile[firstline=21,lastline=24]{src/guess.6.py}

\marginnote[18pt]{\begin{center}\includegraphics[scale=0.9]{illustrations/binary-higher.pdf}\end{center}
Αν ο μυστικός αριθμός είναι μεγαλύτερος από το \pyinline{number} τότε και το κάτω όριο \pyinline{low} πρέπει να γίνει μεγαλύτερο από το \pyinline{number}.}
Όταν ο χρήστης επιλέξει έναν αριθμό \pyinline{number} που είναι μικρότερος από τον μυστικό, τότε η μεταβλητή \pyinline{low} πρέπει να τροποποιηθεί: ο μυστικός αριθμός δεν μπορεί να είναι μικρότερος από το \pyinline{number+1}.

\pyfilesrc[firstline=25,lastline=27]{src/guess.6.py}

%%%%%%%%

\section{Εξαρτήματα κι Αυτοματισμοί}

\begin{question}
Το καημένο το πρόγραμμά μου κάνει όλη τη βαρετή δουλειά. Δε γίνεται να το αφήσω να παίξει κι αυτό λιγάκι; 
%Όταν δοκιμάζω το πρόγραμμα, παίζοντας το ρόλο του χρήστη, παρατηρώ ότι μου έρχεται φυσικά να διαλέγω τον αριθμό που βρίσκεται ``στα μισά'' του διαστήματος που μου προτείνεται. Θα ήθελα το πρόγραμμα να κάνει μόνο του αυτή την επιλογή, αναζητώντας αυτόματα τον μυστικό αριθμό.
\end{question}

Το σημείο στο οποίο ο παίκτης αλληλεπιδρά με το παιχνίδι είναι το σημείο στο οποίο του ζητείται να μαντέψει τον μυστικό αριθμό. Ο παίκτης ενημερώνεται για τα όρια ανάμεσα στα οποία βρίσκεται ο μυστικός αριθμός και, με βάση αυτές τις τιμές, επιλέγει έναν αριθμό. 

\pyfilenl[firstline=18,lastline=20]{src/guess.6.py}

Ας κατασκευάσουμε λοιπόν ένα υποπρόγραμμα το οποίο θα κάνει αυτή ακριβώς τη δουλειά: θα δέχεται σαν \emph{παραμέτρους} τα όρια ανάμεσα στα οποία βρίσκεται ο μυστικός αριθμός και θα ζητάει από το χρήστη να επιλέξει έναν αριθμό μέσα σε αυτά τα όρια.

\marginnote[18pt]{Εικόνα: Μια αναπαράσταση της συνάρτησης \pyinline{readNumber()}. 
\begin{center}\includegraphics[scale=0.9]{illustrations/function-readNumber.pdf}\end{center}}
\marginnote{Ο ορισμός μιας συνάρτησης ξεκινά με τη δεσμευμένη λέξη \pyinline{def} κι ακολουθείται από το όνομα της συνάρτησης και τις παραμέτρους της, σε παρενθέσεις.}
\marginnote{Οι εντολές που ακολουθούν την πρώτη γραμμή είναι στοιχισμένες δεξιότερα. Η στοίχιση αυτή υποδηλώνει ότι οι εντολές αυτές θα εκτελεστούν όταν \emph{κληθεί} η συνάρτηση.}%
\pyfile[firstline=2,lastline=11]{src/guess.7.py}

Οι μεταβλητές \pyinline{a}, \pyinline{b} και \pyinline{num} είναι τοπικές και υφίστανται μόνο καθόσο εκτελείται το υποπρόγραμμα. 

\marginnote{Εικόνα: Η κλήση της \pyinline{readNumber()} από το κύριο πρόγραμμα.
\begin{center}\includegraphics[scale=0.9]{illustrations/function-readNumber-call.pdf}\end{center}}
%Η κλήση της συνάρτησης \pyinline{readNumber()}.}%
Στο σημείο του κύριου προγράμματος όπου ζητείται η είσοδος αριθμού από το χρήστη μπορούμε τώρα να καλέσουμε το υποπρόγραμμα, παρέχοντας τις κατάλληλες παραμέτρους.

\pyfilesrc[firstline=28,lastline=29]{src/guess.7.py}

Κατά την κλήση αυτή, οι μεταβλητές του κύριου προγράμματος \pyinline{low} και \pyinline{high} περνούν τις τιμές τους στις αντίστοιχες τοπικές μεταβλητές \pyinline{a} και \pyinline{b}. Ακόμα κι αν μετονομάζαμε τις \pyinline{a} και \pyinline{b} σε \pyinline{low} και \pyinline{high}, θα επρόκειτο για διαφορετικές μεταβλητές.
%Θα μπορούσαμε να καλέσουμε την ίδια συνάρτηση από διαφορετικό σημείο, με διαφορετικές παραμέτρους. 

Ας αντικαταστήσουμε τώρα την συνάρτηση \pyinline{readNumber()} με μια άλλη που θα επιλέγει μόνη της έναν αριθμό, παίζοντας το ρόλο του χρήστη. Όμως, ποιον αριθμό θα πρέπει να επιλέγει;

Εσείς, όταν δοκιμάζετε το πρόγραμμά σας, αναλαμβάνοντας το ρόλο του χρήστη, επιλέγετε τυχαία αριθμούς ή μήπως χρησιμοποιείτε συγκεκριμένη τακτική; %Μπορείτε να διατυπώσετε αυτή την τακτική με λόγια;
Μπορείτε να περιγράψετε με σαφήνεια πως σκέφτεστε για να επιλέξετε τον επόμενο αριθμό που θα δοκιμάσετε; 
%Μπορείτε να φτιάξετε ένα υποπρόγραμμα που να κάνει αυτό που κάνετε κι εσείς, ως χρήστης, για να επιλέξετε τον επόμενο αριθμό;

%Καθώς κάνετε τα πρώτα σας βήματα στον προγραμματισμό, συχνά θα διαπιστώσετε ότι γνωρίζετε εμπειρικά ή διαισθητικά πως \emph{περίπου} μπορείτε να λύσετε το πρόβλημα που σας τίθεται. Όμως η βασική δυσκολία είναι να μπορέσετε να διατυπώσετε τις απαραίτητες ενέργειες για την επίλυση του προβλήματος \emph{με ακρίβεια}. Αν μπορέσετε να το κάνετε αυτό, τότε η λύση του προβλήματος θα έχει \emph{αυτοματοποιηθεί} και ο υπολογιστής θα κάνει τις απαραίτητες ενέργειες για λογαριασμό σας, ακολουθώντας τις οδηγίες σας.

Το υποπρόγραμμα που ακολουθεί δέχεται σαν παραμέτρους τα όρια ανάμεσα στα οποία βρίσκεται ο μυστικός αριθμός κι επιλέγει τον αριθμό που βρίσκεται \emph{στο μέσο του διαστήματος} ανάμεσα στα όρια. 

\marginnote[18pt]{Το σύμβολο \pyinline{//} χρησιμοποιείται για να υπολογιστεί το πηλίκο της \emph{ακέραιας διαίρεσης} (χωρίς δεκαδικά ψηφία). Χρειαζόμαστε αυτή την πράξη, αντί για την συνηθισμένη διαίρεση, επειδή θέλουμε ο αριθμός \pyinline{number} να είναι πάντα ακέραιος.}
%\marginnote{Το σύμβολο \% χρησιμοποιείται για να υπολογιστεί το \emph{υπόλοιπο} της ακέραιας διαίρεσης.}
\pyfile[firstline=2,lastline=13]{src/guess.8.py}

Τώρα η είσοδος αριθμού από το χρήστη αντικαθίσταται με μια κλήση προς την \pyinline{midNumber()}. 

\pyfilesrc[firstline=30,lastline=31]{src/guess.8.py}

Στη φάση αυτή δεν υπάρχει πλέον είσοδος από τον χρήστη. Ο μυστικός αριθμός καθορίζεται με τυχαίο τρόπο και στη συνέχεια το ίδιο το πρόγραμμα (αναλαμβάνοντας και το ρόλο του δεύτερου παίκτη) προσπαθεί \emph{με συστηματικό τρόπο} να τον μαντέψει.

%Θα μπορούσε να προστεθεί και μια εντολή καθυστέρησης, για να μοιάζει ότι το πρόγραμμα ``σκέφτεται'' αλλά και για να προλαβαίνει ο χρήστης να παρακολουθεί την εξέλιξη του παιχνιδιού.

%%%%%%%%

\section{Πλήρες Τελικό Πρόγραμμα}

\pyfile[firstline=1,lastline=12]{src/guess.final.py}
\tobecontinued

\pyfilesrc[firstline=14,firstnumber=12]{src/guess.final.py}

%%%%%%%%

\section{Τροποποιήσεις -- Επεκτάσεις}

\begin{exercise}
Το τελικό πρόγραμμα ενημερώνει σε κάθε προσπάθεια για τα όρια ανάμεσα στα οποία βρίσκεται ο μυστικός αριθμός. Ωστόσο, ο χρήστης δεν είναι \emph{υποχρεωμένος} να εισάγει έναν αριθμό που να βρίσκεται ανάμεσα σε αυτά τα όρια. Αν ο χρήστης δώσει έναν αριθμό εκτός ορίων τότε απλά θα χαραμίσει μια προσπάθεια. Παράλληλα όμως, θα φανεί κι ένα πρόβλημα: ένα από τα όρια θα τροποποιηθεί λανθασμένα. Επιβεβαιώστε το πρόβλημα και διορθώστε το, προσθέτοντας τις κατάλληλες εντολές.
\end{exercise}

\begin{exercise}
Διατυπώστε μια εναλλακτική εκδοχή του προγράμματος, στην οποία η \pyinline{while} θα χρησιμοποιεί την συνθήκη \pyinline{number != secret}, αντί για τον έλεγχο της λογικής μεταβλητής \pyinline{found} ή την χρήση της \pyinline{break}.
\end{exercise}

\section{Ασκήσεις}

\begin{exercise}
Να κατασκευάσετε ένα πρόγραμμα το οποίο θα ζητά από το χρήστη έναν αλφαριθμητικό κωδικό. Ο χρήστης θα έχει το πολύ τρεις προσπάθειες για να εισάγει τον κωδικό του. Αν εισάγει έναν σωστό κωδικό, το πρόγραμμα θα τον καλωσορίζει, ενώ αν εξαντλήσει ανεπιτυχώς τις προσπάθειές του, θα εμφανίζεται ένα σχετικό μήνυμα. 
\end{exercise}

\begin{exercise}
Να κατασκευάσετε ένα πρόγραμμα στο οποίο \emph{ο χρήστης} θα σκέφτεται έναν μυστικό αριθμό από το 1 μέχρι και το 32 και \emph{το πρόγραμμα} θα προσπαθεί να τον μαντέψει μέσα σε 4 προσπάθειες το πολύ. Σε κάθε προσπάθεια, το πρόγραμμα θα επιλέγει έναν αριθμό και θα ρωτάει το χρήστη αν αυτός είναι ίσος, μικρότερος ή μεγαλύτερος από τον μυστικό αριθμό του.
\end{exercise}

\begin{exercise}
Να κατασκευάσετε ένα πρόγραμμα το οποίο θα επιλέγει έναν μυστικό αριθμό από το 1 μέχρι και το 32 και ο χρήστης θα προσπαθεί να τον μαντέψει μέσα σε 4 προσπάθειες το πολύ. Σε κάθε προσπάθεια, ο χρήστης θα επιλέγει \emph{δύο} αριθμούς που θ' αποτελούν την «παγίδα» του και το πρόγραμμα θα τον ενημερώνει αν ο μυστικός αριθμός βρίσκεται ανάμεσα στους αριθμούς της παγίδας, αν είναι μικρότερος ή μεγαλύτερος από αυτούς. Για να βρίσκεται ένας αριθμός μέσα στην παγίδα θα πρέπει να είναι τουλάχιστον ίσος με τον μικρότερο αριθμό της παγίδας και το πολύ ίσος με τον μεγαλύτερο.
Όταν η παγίδα αποτελείται από δύο αριθμούς που είναι ίσοι μεταξύ τους και ταυτίζονται με τον μυστικό αριθμό τότε ο χρήστης έχει μαντέψει τον μυστικό αριθμό. 

Όπως και στο «Μάντεψε τον Αριθμό», μπορείτε τελικά να αυτοματοποιήσετε την αναζήτηση του αριθμού, γράφοντας μια συνάρτηση αντίστοιχη της \pyinline{midNumber()}, η οποία επιλέγει σε κάθε γύρο την κατάλληλη παγίδα.
\end{exercise}

%%%%%%%%

\section*{}
%\vspace{4\parskip}
\hrulefill

%\begin{theory}{Τύποι Και Αναπαραστάσεις}
%\end{theory}

\begin{theory}{Αναζήτηση}
Όταν ψάχνουμε κάτι, όπως για παράδειγμα έναν μυστικό αριθμό, μιλάμε για \emph{αναζήτηση}. Η αναζήτηση είναι κάτι που κάνουμε πολύ συχνά, είτε μόνοι μας, είτε με τη βοήθεια υπολογιστών. Ψάχνουμε για ένα όνομα στον τηλεφωνικό κατάλογο ή για την επόμενη κίνηση σ' ένα επιτραπέζιο παιχνίδι. Συχνά η αναζήτηση δεν είναι καθόλου απλή υπόθεση. Μπορεί ο χώρος στον οποίο ψάχνουμε να είναι αχανής. Μπορεί να μην ξέρουμε τι ακριβώς ψάχνουμε ή πως πρέπει να το περιγράψουμε. Για παράδειγμα, η μηχανή αναζήτησης της Google προσπαθεί μέσα σε μερικά δέκατα του δευτερολέπτου να συγκεντρώσει και να ταξινομήσει τις διευθύνσεις των ιστοσελίδων που πιθανώς μας ενδιαφέρουν, βασισμένη κάθε φορά σε μερικές λέξεις-κλειδιά που της παρέχουμε. Οι βιολόγοι αναζητούν ακολουθίες αμινοξέων μέσα στον γενετικό μας κώδικα, παρέχοντας μόνο ένα γενικό πρότυπο γιατί μπορεί να υπάρχουν αποδεκτές παραλλαγές και μεταλλάξεις. Με δεδομένο πάντως το πόσο σημαντικό πρόβλημα είναι η αναζήτηση, είναι ευτυχές ότι πρόκειται για ένα πρόβλημα που λύνεται συνήθως πολύ αποδοτικά.
\end{theory}

\begin{theory}{Δυαδική Αναζήτηση}
Όταν αναζητούμε ένα αντικείμενο μέσα σε ένα σύνολο από \emph{ταξινομημένα} στοιχεία τότε το καλύτερο που μπορούμε να κάνουμε είναι να ψάξουμε ακριβώς στη μέση. Αν το μεσαίο στοιχείο δεν είναι αυτό που ψάχνουμε τότε (επειδή τα στοιχεία είναι ταξινομημένα) γνωρίζουμε προς τα που πρέπει να συνεχίσουμε την αναζήτηση, αποκλείουμε μεμιάς τα άλλα μισά στοιχεία που βρίσκονται προς την αντίθετη κατεύθυνση και εφαρμόζουμε την ίδια διαδικασία στα στοιχεία που απομένουν. Με τον τρόπο αυτό, είτε θα εντοπίσουμε κάποια στιγμή το στοιχείο που αναζητούμε, είτε θα εξαντληθούν τα στοιχεία και θα φτάσουμε στο συμπέρασμα ότι αυτό που ψάχνουμε δεν υπάρχει ανάμεσά τους. Αυτή η μέθοδος ονομάζεται δυαδική αναζήτηση και είναι ουσιαστικά η διαδικασία που ακολουθήσαμε στο τελευταίο βήμα του παραδείγματος για να εντοπίσουμε τον μυστικό αριθμό. 
%Θυμηθείτε ότι προϋπόθεση για την εφαρμογή της δυαδικής αναζήτησης είναι τα στοιχεία να είναι ταξινομημένα. Αν αυτό δεν ισχύει, το καλύτερο που μπορούμε να κάνουμε είναι να ελέγξουμε τα στοιχεία με την σειρά.
\end{theory}


\begin{theory}{Διαίρει και Βασίλευε}
Πρόκειται για μια στρατηγική επίλυσης προβλημάτων που στηρίζεται στον κατακερματισμό ενός προβλήματος σε μικρότερα υποπροβλήματα. Αυτά είναι συνήθως του ίδιου ή συναφούς τύπου με το αρχικό πρόβλημα και, στην καλύτερη περίπτωση, ίδιου μεγέθους μεταξύ τους. Τα υποπροβλήματα επιλύονται ξεχωριστά και, αν αυτό είναι απαραίτητο, οι λύσεις τους συνδυάζονται για να επιλυθεί το αρχικό πρόβλημα. Ουσιαστικά μια παρόμοια στρατηγική ακολουθούμε όταν το πρόβλημα που μας τίθεται είναι ο εντοπισμός του μυστικού αριθμού. Σε κάθε βήμα βρισκόμαστε αντιμέτωποι με το ίδιο πρόβλημα, αλλά τα όρια ανάμεσα στα οποία αναζητούμε τον αριθμό ολοένα και στενεύουν. Πολλοί σημαντικοί αλγόριθμοι στην Πληροφορική βασίζονται στη στρατηγική του διαίρει και βασίλευε.
%(Ο ορισμός ακολουθεί το βιβλίο \emph{Algorithmic Puzzles} του Levitin.)
\end{theory}


\hrulefill

\end{document}
