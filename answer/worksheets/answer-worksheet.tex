\documentclass[a4paper,11pt,oneside]{book}

\newcommand{\standalone}{}
\input{../../share/tuftelike}
\input{../../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{1}

\usepackage{booktabs}

%%% DOCUMENT START

\begin{document}

\chapterwabstract{Η Απάντηση}{
Στο βιβλίο \emph{The Hitchhiker's Guide to the Galaxy}, περιγράφεται μια υπερευφυής φυλή η οποία αποφασίζει να φτιάξει έναν υπολογιστή που θα δώσει οριστικά την απάντηση για το νόημα της ζωής. Ο υπολογιστής χρειάστηκε 7.5 εκατομμύρια χρόνια για να υπολογίσει και να ελέγξει την Απάντηση \emph{για τη Ζωή, το Σύμπαν και τα Πάντα}. Η Απάντηση ήταν... σαράντα δύο.

Ο υπολογιστής λέγονταν Deep Thought και μπορούμε να φτιάξουμε κι εμείς ένα πρόγραμμα σαν το δικό του. Επειδή γνωρίζουμε ήδη την Απάντηση, θα κλέψουμε λίγο: το πρόγραμμά μας δεν θα υπολογίζει την Απάντηση, αλλά μόνο θα την ανακοινώνει στο χρήστη.
}{είσοδος, έξοδος, μεταβλητές, δομή επιλογής.}{answerColor}{white}

\marginnote[22pt]{%
Διαβάστε το αντίστοιχο κεφάλαιο:\\
\href{http://pythonies.mysch.gr/chapters/answer.pdf}{\url{pythonies.mysch.gr/chapters/answer.pdf}}
}%
\marginnote{%
Στη διεύθυνση \href{http://pythonies.mysch.gr/}{\url{pythonies.mysch.gr}} μπορείτε να βρείτε κι άλλα φύλλα εργασίας σαν αυτό, καθώς και το συνοδευτικό τους υλικό.}%
Με αυτό το φύλλο εργασίας θα γνωρίσουμε τα βασικά είδη εντολών που θα επιτρέπουν στα προγράμματά μας να \emph{αλληλεπιδρούν} με το χρήστη, δηλαδή να του εμφανίζουν μηνύματα στην οθόνη και να του ζητούν να εισάγει τιμές από το πληκτρολόγιο. Θα εξετάσουμε επίσης πως μπορούμε να κάνουμε τα προγράμματά μας να \emph{επιλέγουν} τον τρόπο που θα συμπεριφερθούν, εξετάζοντας τις \emph{συνθήκες} που επικρατούν κατά την εκτέλεσή τους.

%%%%%%%%

\section{Μηνύματα}

\begin{step}
\label{step:print-hello}
Πληκτρολογήστε την εντολή:

% \marginnote[-64pt]{Ο,τιδήποτε ακολουθεί το σύμβολο \# είναι ένα \emph{σχόλιο}. Δεν αφορά τον υπολογιστή και αγνοείται κατά την εκτέλεση του προγράμματος. Απευθύνεται σε εκείνους που διαβάζουν τον κώδικα και (πρέπει να) χρησιμεύει στην καλύτερη κατανόησή του.}

\begin{pynew}
print("Καλημέρα.")
\end{pynew}

Αυτό είναι το πρώτο σας πρόγραμμα. Εκτελέστε το για να δείτε τι θα συμβεί.
\end{step}

\begin{step}
\label{step:print-42}
Βασιστείτε στην εντολή του προηγούμενου βήματος και \emph{προσθέστε} στο πρόγραμμά σας μια ακόμα εντολή, έτσι ώστε να εμφανίζεται στην οθόνη η Απάντηση.

\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
Η Απάντηση είναι... 42
\end{pyterm}

Εκτελέστε ξανά το πρόγραμμα. Τα καταφέρατε;

\marginnote[14pt]{\icondiscuss}
\dottedline

\end{step}

\clearpage
\begin{step}
\label{step:answer-assign}
%\emph{Αφαιρέστε} τώρα την εντολή που γράψατε στο βήμα~\ref{step:print-42}. \emph{Αντικαταστήστε} την με τις εντολές που ακολουθούν.

%\begin{pynew}
%answer = 42
%print("Η Απάντηση είναι...", answer)
%\end{pynew}

\emph{Προσθέστε} πριν την \pyinline{print} του προηγούμενου βήματος την εντολή:

\begin{pynew}
answer = 42
\end{pynew}

Η \pyinline{answer} είναι μια \emph{μεταβλητή} στην οποία δίνουμε την τιμή \pyinline{42}. Tώρα μπορούμε να αναφερόμαστε στην Απάντηση, χωρίς να έχει σημασία ποια είναι αυτή.

\emph{Τροποποιήστε} την \pyinline{print} του βήματος~\ref{step:print-42} ως εξής:

\begin{pyplain}
print("Η Απάντηση είναι..."|\pyhighlight{, answer}|)
\end{pyplain}

Εκτελέστε το πρόγραμμα. Παρατηρείτε κάποια διαφορά στα μηνύματα που εμφανίζονται μετά από τις τροποποιήσεις που κάνατε;

\marginnote[14pt]{\icondiscuss}
\dottedline

Σε τι πιστεύετε ότι διαφέρει το πρόγραμμα μετά από αυτές τις τροποποιήσεις;

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Πιστεύετε ότι θα λειτουργούσε το πρόγραμμα αν είχατε τοποθετήσει την εντολή \pyinline{answer = 42} \emph{μετά} τις \pyinline{print}; Δικαιολογήστε την απάντησή σας.

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

\end{step}

%Τώρα το πρόγραμμά σας θα πρέπει να έχει ως εξής:
%\begin{pyplain}
%print("Καλημέρα.")
%answer = 42
%print("Η Απάντηση είναι...", answer)
%\end{pyplain}

\begin{step}
\label{step:answer-compute}
\emph{Τροποποιήστε} την εντολή που δίνει τιμή στην \pyinline{answer}:

\marginnote[18pt]{Το σύμβολο \pyinline{*} αντιστοιχεί στην πράξη του πολλαπλασιασμού. Mπορείτε επίσης να χρησιμοποιήσετε τα κλασικά \pyinline{+} και \pyinline{-}, καθώς επίσης και το \pyinline{/} για τη διαίρεση, το \pyinline{//} για το πηλίκο της ακέραιας διαίρεσης και το \% για το υπόλοιπο της ακέραιας διαίρεσης.}
\begin{pyplain}
answer = |\pyhighlight{3 + 13 * 3}|
\end{pyplain}

Ποιά \emph{πιστεύετε} ότι θα είναι τώρα η τιμή της \pyinline{answer};

%\marginnote[14pt]{\icondiscuss}
\dottedline

Εκτελέστε το πρόγραμμα. Ποιά είναι η τιμή της \pyinline{answer}; 

%\marginnote[14pt]{\icondiscuss}
\dottedline

Η τιμή της \pyinline{answer} προέκυψε τώρα από τον \emph{υπολογισμό} της τιμής μιας \emph{έκφρασης}. Προσπαθήστε να γράψετε άλλες δύο παρόμοιες αριθμητικές εκφράσεις που χρησιμοποιούν διαφορετικά νούμερα και διαφορετικές πράξεις αλλά δίνουν την ίδια τιμή στην \pyinline{answer}.

\begin{note}
Προσπαθήστε να χρησιμοποιήσετε και τους τελεστές \pyinline{//} και \% για το πηλίκο και το υπόλοιπο της ακέραιας διαίρεσης.
\end{note}

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

% \begin{step}
% Η εντολή \pyinline{answer = 42} δεν είναι δήλωση, δεν διατυπώνει κάτι που πρέπει να ισχύει για πάντα. Με μια αντίστοιχη εντολή μπορούμε στη συνέχεια να αλλάξουμε την τιμή της μεταβλητής \pyinline{answer}, να δώσουμε αυτό το όνομα σε άλλη τιμή (αν και αυτό δε θα χρειαστεί στο πρόγραμμά μας, γιατί η Απάντηση είναι μία).
% \end{step}

\section{Ερωταποκρίσεις}

Θα προγραμματίσουμε τον Deep Thought έτσι ώστε να ζητάει το όνομα του χρήστη και να τον καλημερίζει κατάλληλα. Έτσι θα υπάρχει ένας στοιχειώδης διάλογος, πριν ανακοινωθεί η Απάντηση.

\begin{step}
\label{step:input}
%Πριν το σημείο όπου το πρόγραμμά σας καλημερίζει το χρήστη, 
Στην αρχή του προγράμματος \emph{προσθέστε} τις παρακάτω εντολές:

\begin{pynew}
print("Πώς σε λένε;")
name = input()
\end{pynew}

Η \pyinline{input()} επιστρέφει το κείμενο που πληκτρολόγησε ο χρήστης,
επιστρέφει δηλαδή μια \emph{αλφαριθμητική} τιμή. Εδώ χρησιμοποιούμε την
\pyinline{input()} για να διαβάσουμε την απάντηση του χρήστη, η οποία αποθηκεύεται στη μεταβλητή \pyinline{name}.

% Εκτελέστε το πρόγραμμά σας.
% Με τις εντολές αυτές, ζητείται από τον χρήστη να πληκτρολογήσει το όνομά του. 
%Η μεταβλητή \pyinline{name} παίρνει την τιμή που πληκτρολογεί ο χρήστης.
\end{step}

\begin{step}
\emph{Συμπληρώστε} την εντολή \pyinline{print("Καλημέρα.")} έτσι ώστε το πρόγραμμα να χαιρετά τον χρήστη χρησιμοποιώντας το όνομά του, το οποίο είναι αποθηκευμένο στη μεταβλητή \pyinline{name}. Για παράδειγμα:

%\clearpage
\marginnote[16pt]{\iconcomputer\hspace{1ex}}%\iconkeyboard}
%Πώς σε λένε; 
%|\textbf{Μαρία}|
\begin{pyterm}
Καλημέρα Μαρία
\end{pyterm}

Αν δυσκολευτείτε, ανατρέξτε στο βήμα~\ref{step:answer-assign}, όπου γίνεται κάτι ανάλογο με τη μεταβλητή~\pyinline{answer}.

Εκτελέστε το πρόγραμμα σας 2--3 φορές και, \emph{παίζοντας το ρόλο του χρήστη}, πληκτρολογήστε κάθε φορά ένα διαφορετικό όνομα. Λειτουργεί το πρόγραμμα όπως θα περιμένατε;

\marginnote[14pt]{\icondiscuss}
\dottedline

Ποιά θα ήταν η διαφορά αν επιχειρούσατε να καλημερίσετε τον χρήστη με την εντολή \pyinline{print("Καλημέρα name")};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Ποιά θα ήταν η διαφορά αν, στο βήμα~\ref{step:input}, χρησιμοποιούσαμε την εντολή \pyinline{name = "Μαρία"}, αντί για την εντολή \pyinline{name = input()};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline

Ποιά θα ήταν η διαφορά αν, στο βήμα~\ref{step:answer-assign}, χρησιμοποιούσαμε την εντολή \pyinline{answer = input()} αντί για την εντολή \pyinline{answer = 42};

\marginnote[14pt]{\icondiscuss}
\dottedline

\dottedline
\end{step}

% [comment][removed] Το ερώτημα που ακολουθεί (για την παράμετρο end της print) δημιούργησε πολλά προβλήματα και αφαιρείται.

%\begin{step}
%Δοκιμάστε να συμπληρώσετε την \pyinline{print} του βήματος~\ref{step:input} ως εξής:

%\begin{pyplain}
%print("Πώς σε λένε;", end=" ")
%\end{pyplain}

%Τί διαφορά παρατηρείτε; 

%\dottedline

%Δοκιμάστε να δώσετε κι άλλες τιμές στην παράμετρο \pyinline{end}, αν θέλετε να καταλάβετε πως επηρεάζει την συμπεριφορά της \pyinline{print}. 
%\end{step}

% [comment] Η import time πρέπει να μπει εδώ, το πολύ, και όχι στο τέλος, επειδή στην επόμενη ενότητα χρησιμοποιούμε (και πάλι) τη βιβλιοθήκη time για να πάρουμε την ώρα και τη χρονιά.

\section{Βιβλιοθήκες}

Για να προσθέσουμε λίγο σασπένς, θα θέλαμε να υπάρχει μια \emph{καθυστέρηση} πριν από την ανακοίνωση της Απάντησης. 

Επειδή στις βασικές εντολές της Python δεν συγκαταλέγεται κάποια εντολή καθυστέρησης, θα χρησιμοποιήσουμε τη \marginnote[4pt]{Οι βιβλιοθήκες είναι συλλογές από έτοιμα μικρά προγράμματα που μπορούμε να χρησιμοποιήσουμε στα προγράμματά μας.}\emph{βιβλιοθήκη} \pyinline{time}, η οποία παρέχει τη λειτουργικότητα που μας χρειάζεται. 

\begin{step}
\emph{Προσθέστε} στην αρχή του προγράμματος την εντολή που ακολουθεί, για να \emph{εισάγετε} στο πρόγραμμα τη βιβλιοθήκη \pyinline{time}:

\begin{pynew}
import time
\end{pynew}

%Καλό είναι να διατηρήσετε αυτή τη γραμμή στην αρχή του προγράμματος, όπου είναι προτιμότερο να εισάγονται οι βιβλιοθήκες.
%\end{step}

%\begin{step}
% [comment] Σημαντική αλλαγή, για να συντομευθεί λίγο το κομμάτι με την sleep.
% [removed]
Αμέσως πριν από την \pyinline{print} που ανακοινώνει την Απάντηση στο χρήστη, \emph{προσθέστε} τη γραμμή που ακολουθεί:

\begin{pynew}
time.sleep(3)
\end{pynew}

%Αμέσως πριν από την \pyinline{print} που ανακοινώνει την Απάντηση στο χρήστη, \emph{προσθέστε} τις γραμμές:
%\begin{pynew}
%wait = 3
%time.sleep(wait)
%\end{pynew}

% [comment] Έχουμε ήδη περιγράψει για ποιο λόγο χρησιμοποιούμε την sleep, αλλά και πάλι δεν πιστεύω ότι αυτή η ερώτηση πρέπει να φύγει.

Εδώ χρησιμοποιείται η \emph{συνάρτηση} \pyinline{sleep}, από τη βιβλιοθήκη \pyinline{time}. Εκτελέστε το πρόγραμμα. Τί αποτέλεσμα έχει η προσθήκη αυτής της εντολής;

\marginnote[14pt]{\icondiscuss}
\dottedline

Διερευνήστε τί θα συμβεί αν χρησιμοποιήσουμε άλλη τιμή, διαφορετική από το \pyinline{3}, ως \emph{παράμετρο} της \pyinline{sleep}. Tί ρόλο πιστεύετε ότι παίζει η παράμετρος της \pyinline{sleep};

%Τί θα συμβεί αν χρησιμοποιήσουμε άλλη τιμή για την μεταβλητή \pyinline{wait}, διαφορετική από την \pyinline{3}; Tί ρόλο πιστεύετε ότι παίζει η \emph{παράμετρος} της \pyinline{sleep} (δηλ. η τιμή που δίνεται ανάμεσα στις παρενθέσεις); 

\marginnote[14pt]{\icondiscuss}
\dottedline

Μπορείτε να αναφέρετε ακόμα ένα ή δύο παραδείγματα εφαρμογών όπου θα χρησιμοποιούσατε την \pyinline{sleep};

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
\label{step:wait-assign}
Πριν από το σημείο καθυστέρησης του προηγούμενου βήματος, \emph{προσθέστε} μια εντολή η οποία υπολογίζει πόσα δευτερόλεπτα αντιστοιχούν σε 7.5 εκατομμύρια χρόνια αναμονής και αποδίδει αυτή την τιμή σε μια νέα μεταβλητή \pyinline{wait}.

Αν δυσκολευτείτε, μπορείτε να ανατρέξετε στο βήμα~\ref{step:answer-compute}, όπου υπολογίζεται με ανάλογο τρόπο η τιμή της μεταβλητής \pyinline{answer}. 

%\begin{note}
%Η τιμή που θα δώσετε στη \pyinline{wait} θα χρησιμοποιηθεί παρακάτω για να ορίσετε το χρονικό διάστημα της καθυστέρησης.
%\end{note}
\end{step}

\begin{step}
\label{step:delay-75}
\marginnote[18pt]{Αν δεν θέλετε να περιμένετε, μπορείτε να διακόψετε την εκτέλεση του προγράμματός σας με τον συνδυασμό πλήκτρων \pyinline{Ctrl + C}.}
\emph{Τροποποιήστε προσωρινά} τη γραμμή όπου χρησιμοποιείται η \pyinline{sleep} έτσι ώστε, αντί για \pyinline{3} δευτερόλεπτα, η καθυστέρηση να διαρκεί \pyinline{wait} δευτερόλεπτα.

\marginnote[2pt]{\iconcaution}
\begin{note}
Σε ορισμένα περιβάλλοντα προκαλείται \emph{σφάλμα} με μια τόσο μεγάλη τιμή καθυστέρησης. Στην περίπτωση αυτή, δώστε τιμή στη μεταβλητή \pyinline{wait} που αντιστοιχεί σε μικρότερη καθυστέρηση, π.χ. έναν χρόνο.
\end{note}

%\begin{pyplain}
%time.sleep(|\pyhighlight{wait}|)
%\end{pyplain}

%\marginnote[18pt]{\iconcaution}
%Εκτελέστε το πρόγραμμα. Αν παρουσιαστεί κάποιο πρόβλημα, ίσως χρειαστεί να \emph{μετακινήσετε} την εντολή του βήματος~\ref{step:wait-assign}, με την οποία παίρνει τιμή η μεταβλητή \pyinline{wait}. Για να χρησιμοποιηθεί μια μεταβλητή θα πρέπει \emph{πρώτα} να έχει πάρει τιμή.

%\emph{Τροποποιήστε} προσωρινά την εντολή που δίνει τιμή στη \pyinline{wait}, έτσι ώστε η τιμή της να αντιστοιχεί σε 7.5 εκατομύρια χρόνια αναμονής.

%\begin{note}
%Θυμηθείτε ότι το χρονικό διάστημα που δέχεται σαν παράμετρο η \pyinline{sleep} αντιστοιχεί σε \emph{δευτερόλεπτα}.
%\end{note}
\end{step}

\clearpage
\section{Επιλογές: Τί Ώρα Είναι;}

Ο Deep Thought, που γνωρίζει την Απάντηση για τη Ζωή, το Σύμπαν και τα Πάντα, δεν θα έπρεπε να καλημερίζει τον χρήστη ακόμα κι όταν είναι βράδι... Θα θέλαμε το πρόγραμμα να είναι περισσότερο ευέλικτο και να προσαρμόζει τον χαιρετισμό του ανάλογα με την ώρα της ημέρας.

\begin{step}
\label{step:hour-assign}
Πριν από το σημείο όπου το πρόγραμμά σας καλημερίζει το χρήστη, \emph{προσθέστε} την εντολή:

\begin{pynew}
hour = time.localtime().tm_hour
\end{pynew}

%Η συνάρτηση \pyinline{localtime()} της βιβλιοθήκης \pyinline{time} επιστρέφει πληροφορίες για την ημερομηνία και την ώρα του συστήματος. 
Εδώ χρησιμοποιήσαμε και πάλι τη βιβλιοθήκη \pyinline{time}. 
Οι συντακτικές λεπτομέρειες δεν έχουν σημασία, αυτό που μας νοιάζει είναι πως η τιμή της μεταβλητής \pyinline{hour} είναι η τρέχουσα ώρα του συστήματος: ένας ακέραιος από το \pyinline{0} μέχρι και το \pyinline{23}. Αν θέλετε να το επιβεβαιώσετε, μπορείτε να προσθέσετε προσωρινά μια \pyinline{print} που εμφανίζει την τιμή της \pyinline{hour} στην οθόνη.
\end{step}

\begin{step}
Αμέσως μετά την \pyinline{print("Καλημέρα", name)} με την οποία
το πρόγραμμα καλημερίζει το χρήστη, \emph{προσθέστε} την εντολή:%, χωρίς να τροποποιήσετε την υπάρχουσα \pyinline{print}:

%\begin{pyplain}
%print("Καλημέρα", name)
%\end{pyplain}
\begin{pynew}
print("Καλησπέρα", name)
\end{pynew}

Εκτελέστε το πρόγραμμα. Εμφανίζονται και τα δύο μηνύματα;  

\marginnote[14pt]{\icondiscuss}
\dottedline

Εμείς θέλουμε να εκτελείται μόνο η μία από τις δύο εντολές, \emph{ανάλογα με την ώρα της ημέρας}, δηλαδή την τιμή της μεταβλητής \pyinline{hour}. Θα πρέπει λοιπόν να προγραμματίσουμε τον Deep Thought έτσι ώστε να \emph{ελέγχει} την \pyinline{hour} και να εμφανίζει διαφορετικό μήνυμα ανάλογα με το αποτέλεσμα του ελέγχου. 
\end{step}

\begin{step}
\emph{Τροποποιήστε} το σημείο όπου το πρόγραμμα καλημερίζει το χρήστη:

\marginnote[18pt]{Για να συγκριθούν τιμές μεταξύ τους χρησιμοποιούμε τα \pyinline{<} (μικρότερο), \pyinline{<=} (μικρότερο ή ίσο), \pyinline{>} (μεγαλύτερο) και \pyinline{>=} (μεγαλύτερο ή ίσο). Επίσης, με τα \pyinline{==} (ίσο) και το \pyinline{!=} (διάφορο) ελέγχεται αν δύο τιμές είναι ίσες ή διαφορετικές.}
\begin{pynew}
if hour < 16:
\end{pynew}
\begin{pyplain}
print("Καλημέρα", name)
\end{pyplain}
\begin{pynew}
else:
\end{pynew}
\begin{pyplain}
print("Καλησπέρα", name)
\end{pyplain}

\marginnote[28pt]{\iconcaution}
Δοκιμάστε να εκτελέσετε το πρόγραμμά σας. Δεν πρόκειται να λειτουργήσει, θα εμφανιστεί ένα μήνυμα σφάλματος.

\begin{pyterm}
IndentationError: expected an indented block
\end{pyterm}

Στις περισσότερες γλώσσες προγραμματισμού δεν θα αντιμετωπίζατε κάποιο πρόβλημα, όμως η Python έχει μια ``ευαισθησία'': Οι εντολές που εκτελούνται στη μία ή στην άλλη περίπτωση πρέπει να \emph{ξεχωρίζουν}, πρέπει με κάποιον τρόπο να επισημανθεί ότι οι εντολές αυτές \emph{ανήκουν} αντίστοιχα στην \pyinline{if} και την \pyinline{else}. 

Στην Python, αυτό επιτυγχάνεται με τις \emph{εσοχές}.
\end{step}

%\clearpage
\begin{step}
\emph{Προσθέστε} 4 κενά πριν τις δύο \pyinline{print} κι εκτελέστε το πρόγραμμα.

\begin{pyplain}
if hour < 16:
|\pyhighlight{\vphantom{λρ}    }|print("Καλημέρα", name)
else:
|\pyhighlight{\vphantom{λρ}    }|print("Καλησπέρα", name)
\end{pyplain}

%\clearpage
Θυμηθείτε ότι η \pyinline{hour} αντιστοιχεί στην ώρα της ημέρας και η τιμή της κυμαίνεται από το \pyinline{0} μέχρι και το \pyinline{23}. Για ποιο διάστημα τιμών της \pyinline{hour} θα εμφανιστεί το \pyinline{"Καλημέρα"} και για ποιες το \pyinline{"Καλησπέρα"};

%\clearpage
\marginnote[32pt]{\icondiscuss}
\begin{center}
\begin{tabular}{p{120pt}p{120pt}}
%\hline%
\pcenter{\pyinline{hour}} & \pcenter{μήνυμα} \\\addlinespace[2\parskip]
%\hfill\footnotesize{\pyinline{0} -- \pyinline{23}} \hfill\mbox{} & \\
\dotfill & \pcenter{\pyinline{"Καλημέρα"}}\\\addlinespace[\parskip]
\dotfill & \pcenter{\pyinline{"Καλησπέρα"}}\\\addlinespace[\parskip]
\end{tabular}
\end{center}

%\marginnote[14pt]{\icondiscuss}
%\dottedline

Εκτελέστε το πρόγραμμα. Συμπληρώστε παρακάτω την ώρα που το εκτελέσατε και ποιο από τα δύο μηνύματα εμφανίστηκε στην οθόνη.

\marginnote[32pt]{\icondiscuss}
\begin{center}
\begin{tabular}{p{120pt}p{120pt}}
%\hline%
\pcenter{ώρα εκτέλεσης} & \pcenter{μήνυμα} \\
\pcenter{\footnotesize{\pyinline{0} -- \pyinline{23}}} & \pcenter{\footnotesize{\pyinline{"Καλημέρα"} / \pyinline{"Καλησπέρα"}}}\\\addlinespace[2\parskip]
\dotfill & \dotfill \\%\addlinespace[\parskip]
\end{tabular}
\end{center}
%\end{step}

%\begin{step}
%Δοκιμάστε ν' αλλάξετε την ώρα του συστήματος, ώστε να δείτε και το άλλο μήνυμα να εμφανίζεται. Συμπληρώστε την ώρα που χρησιμοποιήσατε και το μήνυμα που εμφανίστηκε.
Τί ώρα θα έπρεπε να εκτελέσετε το πρόγραμμα για να εμφανιστεί το \emph{αντίθετο} μήνυμα; Υπάρχουν πολλές εναλλακτικές, συμπληρώστε μία από αυτές.

\marginnote[32pt]{\icondiscuss}
\begin{center}
\begin{tabular}{p{120pt}p{120pt}}
%\hline%
\pcenter{ώρα εκτέλεσης} & \pcenter{μήνυμα} \\
\pcenter{\footnotesize{\pyinline{0} -- \pyinline{23}}} & \pcenter{\footnotesize{\pyinline{"Καλημέρα"} / \pyinline{"Καλησπέρα"}}}\\\addlinespace[2\parskip]
\dotfill & \dotfill \\%\addlinespace[\parskip]
\end{tabular}
\end{center}

Για να δείτε το άλλο μήνυμα να εμφανίζεται και να διαπιστώσετε ότι το πρόγραμμα πράγματι ``προσαρμόζεται'' ανάλογα με την ώρα, θα πρέπει να αλλάξετε την ώρα! \emph{Tροποποιήστε} λοιπόν προσωρινά την εντολή του βήματος~\ref{step:hour-assign} που δίνει τιμή στη μεταβλητή \pyinline{hour}. Ορίστε την τιμή της \pyinline{hour} να είναι ίση με την ώρα εκτέλεσης που συμπληρώσατε στην προηγούμενη ερώτηση.

Εμφανίστηκε το σωστό μήνυμα και σ' αυτή την περίπτωση;

\marginnote[14pt]{\icondiscuss}
\dottedline

% Αν θέλετε πράγματι να δείτε το άλλο μήνυμα να εμφανίζεται, μπορείτε να αλλάξετε την ώρα του συστήματος ή να τροποποιήσετε κατάλληλα την εντολή του βήματος~\ref{step:hour-assign} που ορίζει την τιμή της \pyinline{hour}.
\end{step}

% comment][removed] \emph{Τροποποιήστε} τη \emph{συνθήκη} που ελέγχει η \pyinline{if}, έτσι ώστε το μήνυμα \pyinline{"Καλησπέρα"} να εμφανίζεται μετά τις 4 το απόγευμα.

\section{Κι Άλλες Επιλογές: Η Ηλικία Μετράει}

\begin{step}
Πριν την ανακοίνωση της Απάντησης, \emph{προσθέστε} τις κατάλληλες εντολές στο πρόγραμμα έτσι ώστε να ζητά από το χρήστη να πληκτρολογήσει το έτος γέννησής του και να το αποθηκεύει σε μια μεταβλητή με όνομα \pyinline{birth}. Για παράδειγμα:

\clearpage
\marginnote[24pt]{\iconcomputer\hspace{1ex}\iconkeyboard}
\begin{pyterm}
Ποιό έτος γεννήθηκες;
|\textbf{2001}|
\end{pyterm}

Αν δυσκολευτείτε, μπορείτε να ανατρέξετε στο βήμα~\ref{step:input}, όπου γίνεται κάτι ανάλογο για το όνομα του χρήστη.
\end{step}

\begin{step}
\emph{Προσθέστε} στο πρόγραμμά σας την παρακάτω εντολή, με την οποία η τιμή της μεταβλητής \pyinline{year} γίνεται ίση με το τρέχον έτος.

\begin{pynew}
year = time.localtime().tm_year
\end{pynew}
\end{step}

\begin{step}
Γνωρίζοντας το τρέχον έτος \pyinline{year} και το έτος γέννησης του χρήστη \pyinline{birth}, προσπαθήστε να υπολογίσετε την ηλικία του χρήστη και να αποθηκεύσετε την τιμή σε μια μεταβλητή \pyinline{age}. Aνατρέξτε στα βήματα~\ref{step:answer-compute} και~\ref{step:wait-assign} για παραδείγματα όπου γίνεται κάτι ανάλογο. 

\marginnote[18pt]{\iconcaution}
Αν επιχειρήσετε να εκτελέσετε το πρόγραμμα θα διαπιστώσετε ότι δεν λειτουργεί, ακόμα κι αν ο υπολογισμός σας είναι σωστός. Θα δείτε να εμφανίζεται ένα (μάλλον ακατάληπτο) μήνυμα λάθους.
 
%\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
TypeError: unsupported operand type(s) for -:
  'int' and 'str'
\end{pyterm}

Το μήνυμα εξηγεί ότι δεν είναι δυνατές οι πράξεις ανάμεσα σε αριθμούς και \emph{αλφαριθμητικές τιμες} (κείμενα). Ίσως αναρωτιέστε που βρέθηκε η αλφαριθμητική τιμή. Η \pyinline{input()}, που χρησιμοποιήσατε για να διαβάσετε το έτος γέννησης που πληκτρολογεί ο χρήστης, επιστρέφει την απάντηση του χρήστη σε μορφή κειμένου, κι έτσι η τιμή της \pyinline{birth} θα έχει τη μορφή \pyinline{"2001"} και όχι \pyinline{2001}.
\end{step}

\begin{step}
Επιστρέψτε στη γραμμή όπου διαβάζεται το έτος γέννησης του χρήστη και \emph{τροποποιήστε} την ως εξής:

\begin{pyplain}
birth = |\pyhighlight{int(}|input()|\pyhighlight{)}|
\end{pyplain}

H \pyinline{int} μετατρέπει το κείμενο που πληκτρολογεί ο χρήστης σε ακέραιο αριθμό. Εκτελέστε και πάλι το πρόγραμμά σας και επιβεβαιώστε ότι δεν εμφανίζεται πια μήνυμα λάθους.
\end{step}

\begin{step}
\emph{Συμπληρώστε} το πρόγραμμά σας, έτσι ώστε να εμφανίζει στο χρήστη την ηλικία του. Για παράδειγμα:

\marginnote[24pt]{\iconcomputer\hspace{1ex}\iconkeyboard}
\begin{pyterm}
Ποιό έτος γεννήθηκες;
|\textbf{2001}|
Είσαι 15 χρονών.
\end{pyterm}
\end{step}

\begin{step}
%Επειδή ο χρήστης πιθανότατα γνωρίζει ήδη την ηλικία του, 
\emph{Τροποποιήστε} το πρόγραμμα και χρησιμοποιήστε την \pyinline{if}, έτσι ώστε το μήνυμα που εμφανίζεται να εξαρτάται από το αν ο χρήστης έχει ξεπεράσει τα 18 έτη. Για παράδειγμα:

\marginnote[24pt]{\iconcomputer\hspace{1ex}\iconkeyboard}
\begin{pyterm}
Ποιό έτος γεννήθηκες;
|\textbf{2001}|
15 χρονών, η κατάλληλη ηλικία να μάθεις την Απάντηση.
\end{pyterm}

\begin{pyterm}
Ποιό έτος γεννήθηκες;
|\textbf{1976}|
Πάτησες τα 40, είναι λίγο αργά να μάθεις την Απάντηση.
\end{pyterm}

Εκτελέστε το πρόγραμμα σας δύο φορές. Την πρώτη, \emph{παίζοντας το ρόλο του χρήστη}, δώστε ένα έτος γέννησης που αντιστοιχεί σε ηλικία μικρότερη των 18 ετών, ενώ τη δεύτερη το αντίθετο. Εμφανίζεται το κατάλληλο μήνυμα σε κάθε περίπτωση;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

\begin{step}
\emph{Τροποποιήστε} το πρόγραμμα έτσι ώστε η Απάντηση να εμφανίζεται \emph{μόνο} στην περίπτωση που ο χρήστης δεν έχει ξεπεράσει τα 18 έτη. Δεν χρειάζεται να γράψετε καμία νέα εντολή, μόνο να μετακινήσετε κάποια/κάποιες από τις ήδη υπάρχουσες \emph{μέσα} στην \pyinline{if} του προηγούμενου βήματος.

\marginnote[18pt]{\iconcaution}
\begin{note}
Αν παρουσιαστεί κάποιο πρόβλημα, τότε θα πρέπει να βεβαιωθείτε ότι έχετε χρησιμοποιήσει σωστά τις \emph{εσοχές}, μπροστά από τις εντολές που βρίσκονται μέσα στην \pyinline{if}.
\end{note}

Εκτελέστε το πρόγραμμα σας δύο φορές. Την πρώτη, \emph{παίζοντας το ρόλο του χρήστη}, δώστε ένα έτος γέννησης που αντιστοιχεί σε ηλικία μικρότερη των 18 ετών, ενώ τη δεύτερη το αντίθετο. Εμφανίζεται η Απάντηση \emph{μόνο} στην πρώτη περίπτωση;

\marginnote[14pt]{\icondiscuss}
\dottedline
\end{step}

% [comment][removed] Το βήμα που ακολουθεί αφαιρείται για να μην είναι το σημείο αυτό κουραστικό.
%\begin{step}
%\emph{Τροποποιήστε} το πρόγραμμα έτσι ώστε η Απάντηση να εμφανίζεται \emph{μόνο} στην περίπτωση που ο χρήστης είναι περισσότερο από 18 ετών. Δεν χρειάζεται να γράψετε καμία νέα εντολή, μόνο να τροποποιήσετε κατάλληλα τα μηνύματα και να ανακατατάξετε κάποια/κάποιες από τις ήδη υπάρχουσες.

%Εκτελέστε το πρόγραμμα σας δύο φορές. Την πρώτη, παίζοντας το ρόλο του χρήστη, δώστε ένα έτος γέννησης που αντιστοιχεί σε ηλικία μικρότερη των 18 ετών, ενώ τη δεύτερη το αντίθετο. Εμφανίζεται η Απάντηση \emph{μόνο} στη δεύτερη περίπτωση;

%\marginnote[14pt]{\icondiscuss}
%\dottedline
%\end{step}

\section{Δραστηριότητες για Εξάσκηση}

\marginnote[16pt]{\href{http://pythonies.mysch.gr/complete/}{\url{pythonies.mysch.gr/complete}}}%
Για περισσότερη εξάσκηση στις έννοιες που γνωρίσατε σ' αυτό το φύλλο εργασίας, μπορείτε ν' ανατρέξετε στις ασκήσεις του %
Κεφαλαίου \href{http://pythonies.mysch.gr/chapters/answer.pdf}{``Η Απάντηση''}.
\end{document}

