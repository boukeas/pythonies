\documentclass[a4paper,11pt,oneside]{book}

\input{../../share/tuftelike}
\input{../../share/colors}
\setcounter{part}{1}
\setcounter{chapter}{1}

\usepackage{booktabs}

%%% DOCUMENT START

\begin{document}

\worksheettrue
\solutionstrue
\chapterwabstract{Η Απάντηση}{}{}{answerColor}{white}

\section{Μηνύματα}

\begin{step}
\label{step:print-hello}
Πληκτρολογήστε την εντολή:

\begin{pynew}
print("Καλημέρα.")
\end{pynew}

Αυτό είναι το πρώτο σας πρόγραμμα. Εκτελέστε το για να δείτε τι θα συμβεί.

\begin{answer}
Θα εμφανιστεί στην οθόνη το μήνυμα \terminline{Καλημέρα}.
\end{answer}
\end{step}

\begin{step}
\label{step:print-42}
Βασιστείτε στην εντολή του προηγούμενου βήματος και \emph{προσθέστε} στο πρόγραμμά σας μια ακόμα εντολή, έτσι ώστε να εμφανίζεται στην οθόνη η Απάντηση.

\begin{pyterm}
Η Απάντηση είναι... 42
\end{pyterm}

\begin{answer}
Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:

\begin{pynew}
print("Η Απάντηση είναι... 42")
\end{pynew}
\end{answer}

%Εκτελέστε ξανά το πρόγραμμα. Τα καταφέρατε;
\end{step}

\begin{step}
\label{step:answer-assign}

\emph{Προσθέστε} πριν την \pyinline{print} του προηγούμενου βήματος την εντολή:

\begin{pynew}
answer = 42
\end{pynew}

Η \pyinline{answer} είναι μια \emph{μεταβλητή} στην οποία δίνουμε την τιμή \pyinline{42}. Tώρα μπορούμε να αναφερόμαστε στην Απάντηση, χωρίς να έχει σημασία ποια είναι αυτή.

\emph{Τροποποιήστε} την \pyinline{print} του βήματος~\ref{step:print-42} ως εξής:

\begin{pyplain}
print("Η Απάντηση είναι..."|\pyhighlight{, answer}|)
\end{pyplain}

Εκτελέστε το πρόγραμμα. Παρατηρείτε κάποια διαφορά στα μηνύματα που εμφανίζονται μετά από τις τροποποιήσεις που κάνατε;

\begin{answer}[]
Δεν υπάρχει διαφορά στα αποτελέσματα του προγράμματος.%
\marginnote[-4pt]{\begin{center}\includegraphics[scale=\scaling]{../illustrations/variable.pdf}\end{center}
Η μεταβλητή \pyinline{answer} έχει την τιμή \pyinline{42}. Εναλλακτικά, θα λέγαμε ότι στην τιμή \pyinline{42} έχει δοθεί το όνομα \pyinline{answer}.}
 Το \pyinline{answer} είναι το όνομα μιας τιμής. 
Κατά την εκτέλεση της \pyinline{print}, στη θέση του ονόματος \pyinline{answer} εμφανίζεται η τιμή του που του έχουμε αναθέσει, δηλαδή το \pyinline{42}.
% Κατά την εκτέλεση της \pyinline{print}, εμφανίζεται η τιμή \pyinline{42}, γιατί αυτή είναι η τιμή που έχουμε αναθέσει στο όνομα \pyinline{answer}.
\end{answer}

Σε τι πιστεύετε ότι διαφέρει το πρόγραμμα μετά από αυτές τις τροποποιήσεις;

\clearpage
\begin{answer}
Η πρώτη \pyinline{print} εμφανίζει πάντα ακριβώς το ίδιο, σταθερό μήνυμα. Η δεύτερη \pyinline{print} εμφανίζει την τιμή της \pyinline{answer}, η οποία εδώ είναι \pyinline{42}, αλλά θα μπορούσε να είναι διαφορετική.
\end{answer}

Πιστεύετε ότι θα λειτουργούσε το πρόγραμμα αν είχατε τοποθετήσει την εντολή \pyinline{answer = 42} \emph{μετά} τις \pyinline{print}; Δικαιολογήστε την απάντησή σας.

\begin{answer}
Όχι, δεν θα λειτουργούσε αφού κατά την εκτέλεση της \pyinline{print} το όνομα \pyinline{answer} δεν θα είχε ηδη αντιστοιχισθεί σε κάποια τιμή, επομένως θα εμφανίζονταν μήνυμα σφάλματος αν το χρησιμοποιούσαμε.
\end{answer}
\end{step}

\begin{step}
\label{step:answer-compute}
\emph{Τροποποιήστε} την εντολή που δίνει τιμή στην \pyinline{answer}:

\marginnote[18pt]{Το σύμβολο \pyinline{*} αντιστοιχεί στην πράξη του πολλαπλασιασμού. Mπορείτε επίσης να χρησιμοποιήσετε τα κλασικά \pyinline{+} και \pyinline{-}, καθώς επίσης και το \pyinline{/} για τη διαίρεση, το \pyinline{//} για το πηλίκο της ακέραιας διαίρεσης και το \% για το υπόλοιπο της ακέραιας διαίρεσης.}
\begin{pyplain}
answer = |\pyhighlight{3 + 13 * 3}|
\end{pyplain}

Ποιά \emph{πιστεύετε} ότι θα είναι τώρα η τιμή της \pyinline{answer};

\begin{answer}[]
Η τιμή της \pyinline{answer} θα είναι \pyinline{42}. Η ιεραρχία των πράξεων είναι ίδια με τα μαθηματικά, επομένως θα προηγηθεί η πράξη του πολλαπασιασμού και στη συνέχεια θα εκτελεστεί η πράξη της πρόσθεσης.
\end{answer}

Εκτελέστε το πρόγραμμα. Ποιά είναι η τιμή της \pyinline{answer}; 

\begin{answer}
Η τιμή της \pyinline{answer} είναι \pyinline{42}, η οποία εμφανίζεται στην οθόνη.
\end{answer}

Η τιμή της \pyinline{answer} προέκυψε τώρα από τον \emph{υπολογισμό} της τιμής μιας \emph{έκφρασης}. Προσπαθήστε να γράψετε άλλες δύο παρόμοιες αριθμητικές εκφράσεις που χρησιμοποιούν διαφορετικά νούμερα και διαφορετικές πράξεις αλλά δίνουν την ίδια τιμή στην \pyinline{answer}.

\begin{note}
Προσπαθήστε να χρησιμοποιήσετε και τους τελεστές \pyinline{//} και \% για το πηλίκο και το υπόλοιπο της ακέραιας διαίρεσης.
\end{note}

\begin{answer}
Δύο παραδείγματα υπολογισμού είναι:
\renewcommand{\labelenumi}{\theenumi.}
\begin{enumerate}
  \renewcommand{\theenumi}{\roman{enumi}}%
  \item \pyinline{answer = 100 // 2 - 8}
  \item \pyinline{answer = 40 + 6 % 4}
\end{enumerate}
\end{answer}
\end{step}

\vspace{-6\parskip} 
\section{Ερωταποκρίσεις}

Θα προγραμματίσουμε τον Deep Thought έτσι ώστε να ζητάει το όνομα του χρήστη και να τον καλημερίζει κατάλληλα. Έτσι θα υπάρχει ένας στοιχειώδης διάλογος, πριν ανακοινωθεί η Απάντηση.

\begin{step}
\label{step:input}

Στην αρχή του προγράμματος \emph{προσθέστε} τις παρακάτω εντολές:

\begin{pynew}
print("Πώς σε λένε;")
name = input()
\end{pynew}

Η \pyinline{input()} επιστρέφει το κείμενο που πληκτρολόγησε ο χρήστης,
επιστρέφει δηλαδή μια \emph{αλφαριθμητική} τιμή. Εδώ χρησιμοποιούμε την
\pyinline{input()} για να διαβάσουμε την απάντηση του χρήστη, η οποία αποθηκεύεται στη μεταβλητή \pyinline{name}.
\end{step}

\begin{step}
\emph{Συμπληρώστε} την εντολή \pyinline{print("Καλημέρα.")} έτσι ώστε το πρόγραμμα να χαιρετά τον χρήστη χρησιμοποιώντας το όνομά του, το οποίο είναι αποθηκευμένο στη μεταβλητή \pyinline{name}. Για παράδειγμα:

\begin{pyterm}
Καλημέρα Μαρία
\end{pyterm}

Αν δυσκολευτείτε, ανατρέξτε στο βήμα~\ref{step:answer-assign}, όπου γίνεται κάτι ανάλογο με τη μεταβλητή~\pyinline{answer}.

\begin{answer}
Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:

\begin{pynew}
print("Καλημέρα", name)
\end{pynew}
\end{answer}

Εκτελέστε το πρόγραμμα σας 2--3 φορές και, \emph{παίζοντας το ρόλο του χρήστη}, πληκτρολογήστε κάθε φορά ένα διαφορετικό όνομα. Λειτουργεί το πρόγραμμα όπως θα περιμένατε;

\begin{answer}
Ναι, το πρόγραμμα χαιρετά τον χρήστη χρησιμοποιώντας το όνομα που πληκτρολόγησε.
\end{answer}

Ποιά θα ήταν η διαφορά αν επιχειρούσατε να καλημερίσετε τον χρήστη με την εντολή \pyinline{print("Καλημέρα name")};

\begin{answer}
Θα εμφανίζονταν στην οθόνη το μήνυμα \terminline{Καλημέρα name}. Οτιδήποτε βρίσκεται μέσα σε εισαγωγικά αποτελεί μια αλφαριθμητική τιμή, δηλαδή κείμενο και εμφανίζεται ως έχει, χωρίς να αναφέρεται σε ονόματα μεταβλητών.
\end{answer}

Ποιά θα ήταν η διαφορά αν, στο βήμα~\ref{step:input}, χρησιμοποιούσαμε την εντολή \pyinline{name = "Μαρία"}, αντί για την εντολή \pyinline{name = input()};

\begin{answer}
Η μεταβλητή \pyinline{name} θα ήταν καθορισμένη από τον προγραμματιστή και όχι από τον χρήστη και θα είχε σε κάθε εκτέλεση του προγράμματος την τιμή \terminline{"Μαρία"}.
\end{answer}

Ποιά θα ήταν η διαφορά αν, στο βήμα~\ref{step:answer-assign}, χρησιμοποιούσαμε την εντολή \pyinline{answer = input()} αντί για την εντολή \pyinline{answer = 42};

\begin{answer}
Ο χρήστης θα καθόριζε την τιμή της μεταβλητής \pyinline{answer}, ανάλογα με το τι θα πληκτρολογούσε σε κάθε εκτέλεση του προγράμματος Η μεταβλητή \pyinline{answer} δεν θα είχε απαραίτητα την τιμή \pyinline{42}.
\end{answer}
\end{step}

\section{Βιβλιοθήκες}

Για να προσθέσουμε λίγο σασπένς, θα θέλαμε να υπάρχει μια \emph{καθυστέρηση} πριν από την ανακοίνωση της Απάντησης. 

Επειδή στις βασικές εντολές της Python δεν συγκαταλέγεται κάποια εντολή καθυστέρησης, θα χρησιμοποιήσουμε τη \marginnote[4pt]{Οι βιβλιοθήκες είναι συλλογές από έτοιμα μικρά προγράμματα που μπορούμε να χρησιμοποιήσουμε στα προγράμματά μας.}\emph{βιβλιοθήκη} \pyinline{time}, η οποία παρέχει τη λειτουργικότητα που μας χρειάζεται. 

\begin{step}
\emph{Προσθέστε} στην αρχή του προγράμματος την εντολή που ακολουθεί, για να \emph{εισάγετε} στο πρόγραμμα τη βιβλιοθήκη \pyinline{time}:

\begin{pynew}
import time
\end{pynew}

Αμέσως πριν από την \pyinline{print} που ανακοινώνει την Απάντηση στο χρήστη, \emph{προσθέστε} τη γραμμή που ακολουθεί:

\begin{pynew}
time.sleep(3)
\end{pynew}

Εδώ χρησιμοποιείται η \emph{συνάρτηση} \pyinline{sleep}, από τη βιβλιοθήκη \pyinline{time}. Εκτελέστε το πρόγραμμα. Τί αποτέλεσμα έχει η προσθήκη αυτής της εντολής;

\begin{answer}
Εισάγεται μια καθυστέρηση ανάμεσα στην εμφάνιση των δύο μηνυμάτων.
\end{answer}

Διερευνήστε τί θα συμβεί αν χρησιμοποιήσουμε άλλη τιμή, διαφορετική από το \pyinline{3}, ως \emph{παράμετρο} της \pyinline{sleep}. Tί ρόλο πιστεύετε ότι παίζει η παράμετρος της \pyinline{sleep};

\begin{answer}
Η παράμετρος \pyinline{3} καθορίζει ότι θα υπάρχει μια καθυστέρηση τριών δευτερολέπτων. Αν χρησιμοποιήσουμε άλλον αριθμό στη θέση του \pyinline{3} θα αλλάξει η περίοδος της χρονικής καθυστέρησης.
\end{answer}

Μπορείτε να αναφέρετε ακόμα ένα ή δύο παραδείγματα εφαρμογών όπου θα χρησιμοποιούσατε την \pyinline{sleep};

\begin{answer}
Η \pyinline{sleep} μπορεί να χρησιμοποιηθεί σε οποιοδήποτε πρόγραμμα χρειάζεται να εισάγουμε καθυστέρηση μεταξύ της εκτέλεσης κάποιων εντολών. Ένα απλό παράδειγμα είναι η υλοποίηση ενός φωτεινού σηματοδότη που θα έδειχνε τα χρώματα κόκκινο, πορτοκαλί, πράσινο αφήνοντας ένα χρονικό διάστημα για να μεταβεί από το ένα στο άλλο ή ένα πρόγραμμα που θα προσομοίωνε τη λειτουργία ενός ανελκυστήρα που θα χρειαζόταν μια χρονική καθυστέρηση για να μεταβεί από τον έναν όροφο στον άλλον.
\end{answer}
\end{step}

\begin{step}
\label{step:wait-assign}
Πριν από το σημείο καθυστέρησης του προηγούμενου βήματος, \emph{προσθέστε} μια εντολή η οποία υπολογίζει πόσα δευτερόλεπτα αντιστοιχούν σε 7.5 εκατομμύρια χρόνια αναμονής και αποδίδει αυτή την τιμή σε μια νέα μεταβλητή \pyinline{wait}.

Αν δυσκολευτείτε, μπορείτε να ανατρέξετε στο βήμα~\ref{step:answer-compute}, όπου υπολογίζεται με ανάλογο τρόπο η τιμή της μεταβλητής \pyinline{answer}. 

\begin{answer}
Ο χρόνος αναμονής προκύπτει υπολογίζοντας (περίπου) τα δευτερόλεπτα που αντιστοιχούν σε 7.5 εκατομμύρια χρόνια. 

\begin{pynew}
wait = 7500000 * 365 * 24 * 60 * 60
\end{pynew}
\end{answer}
\end{step}

\begin{step}
\label{step:delay-75}
\marginnote[18pt]{Αν δεν θέλετε να περιμένετε, μπορείτε να διακόψετε την εκτέλεση του προγράμματός σας με τον συνδυασμό πλήκτρων \pyinline{Ctrl + C}.}
\emph{Τροποποιήστε προσωρινά} τη γραμμή όπου χρησιμοποιείται η \pyinline{sleep} έτσι ώστε, αντί για \pyinline{3} δευτερόλεπτα, η καθυστέρηση να διαρκεί \pyinline{wait} δευτερόλεπτα.

\marginnote[2pt]{\iconcaution}
\begin{note}
Σε ορισμένα περιβάλλοντα προκαλείται \emph{σφάλμα} με μια τόσο μεγάλη τιμή καθυστέρησης. Στην περίπτωση αυτή, δώστε τιμή στη μεταβλητή \pyinline{wait} που αντιστοιχεί σε μικρότερη καθυστέρηση, π.χ. έναν χρόνο.
\end{note}

\begin{answer}
Ο υπολογισμός των δευτερολέπτων που αντιστοιχεί σε ένα έτος μπορεί να γίνει παραλείποντας από την παραπάνω αριθμητική έκφραση τον αριθμό \pyinline{7500000} όπως παρακάτω:

\begin{pynew}
wait = 365 * 24 * 60 * 60
\end{pynew}
\end{answer}
\end{step}

\section{Επιλογές: Τί Ώρα Είναι;}

Ο Deep Thought, που γνωρίζει την Απάντηση για τη Ζωή, το Σύμπαν και τα Πάντα, δεν θα έπρεπε να καλημερίζει τον χρήστη ακόμα κι όταν είναι βράδι... Θα θέλαμε το πρόγραμμα να είναι περισσότερο ευέλικτο και να προσαρμόζει τον χαιρετισμό του ανάλογα με την ώρα της ημέρας.

\begin{step}
\label{step:hour-assign}
Πριν από το σημείο όπου το πρόγραμμά σας καλημερίζει το χρήστη, \emph{προσθέστε} την εντολή:

\begin{pynew}
hour = time.localtime().tm_hour
\end{pynew}

Εδώ χρησιμοποιήσαμε και πάλι τη βιβλιοθήκη \pyinline{time}. 
Οι συντακτικές λεπτομέρειες δεν έχουν σημασία, αυτό που μας νοιάζει είναι πως η τιμή της μεταβλητής \pyinline{hour} είναι η τρέχουσα ώρα του συστήματος: ένας ακέραιος από το \pyinline{0} μέχρι και το \pyinline{23}. Αν θέλετε να το επιβεβαιώσετε, μπορείτε να προσθέσετε προσωρινά μια \pyinline{print} που εμφανίζει την τιμή της \pyinline{hour} στην οθόνη.
\end{step}

\begin{step}
Αμέσως μετά την \pyinline{print("Καλημέρα", name)} με την οποία
το πρόγραμμα καλημερίζει το χρήστη, \emph{προσθέστε} την εντολή:

\begin{pynew}
print("Καλησπέρα", name)
\end{pynew}

Εκτελέστε το πρόγραμμα. Εμφανίζονται και τα δύο μηνύματα;  

\begin{answer}
Ναι, εμφανίζονται και τα δύο μηνύματα, αφού σε κάθε περίπτωση εκτελούνται και οι δύο \pyinline{print()}.
\end{answer}

Εμείς θέλουμε να εκτελείται μόνο η μία από τις δύο εντολές, \emph{ανάλογα με την ώρα της ημέρας}, δηλαδή την τιμή της μεταβλητής \pyinline{hour}. Θα πρέπει λοιπόν να προγραμματίσουμε τον Deep Thought έτσι ώστε να \emph{ελέγχει} την \pyinline{hour} και να εμφανίζει διαφορετικό μήνυμα ανάλογα με το αποτέλεσμα του ελέγχου. 
\end{step}

\begin{step}
\emph{Τροποποιήστε} το σημείο όπου το πρόγραμμα καλημερίζει το χρήστη:

\marginnote[18pt]{Για να συγκριθούν τιμές μεταξύ τους χρησιμοποιούμε τα \pyinline{<} (μικρότερο), \pyinline{<=} (μικρότερο ή ίσο), \pyinline{>} (μεγαλύτερο) και \pyinline{>=} (μεγαλύτερο ή ίσο). Επίσης, με τα \pyinline{==} (ίσο) και το \pyinline{!=} (διάφορο) ελέγχεται αν δύο τιμές είναι ίσες ή διαφορετικές.}
\begin{pynew}
if hour < 16:
\end{pynew}
\begin{pyplain}
print("Καλημέρα", name)
\end{pyplain}
\begin{pynew}
else:
\end{pynew}
\begin{pyplain}
print("Καλησπέρα", name)
\end{pyplain}

\marginnote[28pt]{\iconcaution}
Δοκιμάστε να εκτελέσετε το πρόγραμμά σας. Δεν πρόκειται να λειτουργήσει, θα εμφανιστεί ένα μήνυμα σφάλματος.

\begin{pyterm}
IndentationError: expected an indented block
\end{pyterm}

Στις περισσότερες γλώσσες προγραμματισμού δεν θα αντιμετωπίζατε κάποιο πρόβλημα, όμως η Python έχει μια ``ευαισθησία'': Οι εντολές που εκτελούνται στη μία ή στην άλλη περίπτωση πρέπει να \emph{ξεχωρίζουν}, πρέπει με κάποιον τρόπο να επισημανθεί ότι οι εντολές αυτές \emph{ανήκουν} αντίστοιχα στην \pyinline{if} και την \pyinline{else}. 

Στην Python, αυτό επιτυγχάνεται με τις \emph{εσοχές}.
\end{step}

%\clearpage
\begin{step}
\emph{Προσθέστε} 4 κενά πριν τις δύο \pyinline{print} κι εκτελέστε το πρόγραμμα.

\begin{pyplain}
if hour < 16:
|\pyhighlight{\vphantom{λρ}    }|print("Καλημέρα", name)
else:
|\pyhighlight{\vphantom{λρ}    }|print("Καλησπέρα", name)
\end{pyplain}

%\clearpage
Θυμηθείτε ότι η \pyinline{hour} αντιστοιχεί στην ώρα της ημέρας και η τιμή της κυμαίνεται από το \pyinline{0} μέχρι και το \pyinline{23}. Για ποιο διάστημα τιμών της \pyinline{hour} θα εμφανιστεί το \pyinline{"Καλημέρα"} και για ποιες το \pyinline{"Καλησπέρα"};

\begin{answer}
Όταν η τιμή της μεταβλητής \pyinline{hour} είναι μικρότερη του \pyinline{16} θα εμφανιστεί το μήνυμα \terminline{Καλημέρα}, ενώ όταν είναι από \pyinline{16} μεχρι και \pyinline{23} θα εμφανιστεί το μήνυμα \terminline{Καλησπέρα}.
\end{answer}

Εκτελέστε το πρόγραμμα. Συμπληρώστε παρακάτω την ώρα που το εκτελέσατε και ποιο από τα δύο μηνύματα εμφανίστηκε στην οθόνη.

\begin{answer}
Έστω ότι εκτελούμε το πρόγραμμα στις \pyinline{10} το πρωί. Η τιμή της hour θα είναι μικρότερη του \pyinline{16}, οπότε θα εμφανιστεί το μήνυμα \terminline{Καλημέρα}.
\end{answer}

Τί ώρα θα έπρεπε να εκτελέσετε το πρόγραμμα για να εμφανιστεί το \emph{αντίθετο} μήνυμα; Υπάρχουν πολλές εναλλακτικές, συμπληρώστε μία από αυτές.

\begin{answer}
Αν εκτελέσουμε το πρόγραμμα στις \pyinline{9} το βράδυ (\pyinline{21}) η συνθήκη της \pyinline{if} δεν θα ισχύει, επομένως θα εκτελεστούν οι εντολές της \pyinline{else} και θα εμφανιστεί το μήνυμα \terminline{Καλησπέρα}.
\end{answer}

Για να δείτε το άλλο μήνυμα να εμφανίζεται και να διαπιστώσετε ότι το πρόγραμμα πράγματι ``προσαρμόζεται'' ανάλογα με την ώρα, θα πρέπει να αλλάξετε την ώρα! \emph{Tροποποιήστε} λοιπόν προσωρινά την εντολή του βήματος~\ref{step:hour-assign} που δίνει τιμή στη μεταβλητή \pyinline{hour}. Ορίστε την τιμή της \pyinline{hour} να είναι ίση με την ώρα εκτέλεσης που συμπληρώσατε στην προηγούμενη ερώτηση.

Εμφανίστηκε το σωστό μήνυμα και σ' αυτή την περίπτωση;

\begin{answer}
Αν αντικαταστήσουμε την εντολή που αναθέτει τιμή στην \pyinline{hour} με την παρακάτω:

\begin{pynew}
hour = 21
\end{pynew}

και εκτελέσουμε το πρόγραμμα, τότε εμφανίζεται στην οθόνη το μήνυμα \terminline{Καλησπέρα}.
\end{answer}
\end{step}

\section{Κι Άλλες Επιλογές: Η Ηλικία Μετράει}

\begin{step}
Πριν την ανακοίνωση της Απάντησης, \emph{προσθέστε} τις κατάλληλες εντολές στο πρόγραμμα έτσι ώστε να ζητά από το χρήστη να πληκτρολογήσει το έτος γέννησής του και να το αποθηκεύει σε μια μεταβλητή με όνομα \pyinline{birth}. Για παράδειγμα:

%\clearpage
\begin{pyterm}
Ποιό έτος γεννήθηκες;
|\textbf{2001}|
\end{pyterm}

Αν δυσκολευτείτε, μπορείτε να ανατρέξετε στο βήμα~\ref{step:input}, όπου γίνεται κάτι ανάλογο για το όνομα του χρήστη.

\begin{answer}
Οι εντολές που θα προσθέσουμε στο πρόγραμμα είναι:

\begin{pynew}
print("Ποιο έτος γεννήθηκες;")
birth = input()
\end{pynew}
\end{answer}
\end{step}

\begin{step}
\emph{Προσθέστε} στο πρόγραμμά σας την παρακάτω εντολή, με την οποία η τιμή της μεταβλητής \pyinline{year} γίνεται ίση με το τρέχον έτος.

\begin{pynew}
year = time.localtime().tm_year
\end{pynew}
\end{step}

\begin{step}
Γνωρίζοντας το τρέχον έτος \pyinline{year} και το έτος γέννησης του χρήστη \pyinline{birth}, προσπαθήστε να υπολογίσετε την ηλικία του χρήστη και να αποθηκεύσετε την τιμή σε μια μεταβλητή \pyinline{age}. Aνατρέξτε στα βήματα~\ref{step:answer-compute} και~\ref{step:wait-assign} για παραδείγματα όπου γίνεται κάτι ανάλογο. 

\begin{answer}
Η ηλικία του χρήστη θα υπολογιστεί αφαιρώντας από το τρέχον έτος το έτος γέννησής του. Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:

\begin{pynew}
age = year - birth
\end{pynew}
\end{answer}

\marginnote[18pt]{\iconcaution}
Αν επιχειρήσετε να εκτελέσετε το πρόγραμμα θα διαπιστώσετε ότι δεν λειτουργεί, ακόμα κι αν ο υπολογισμός σας είναι σωστός. Θα δείτε να εμφανίζεται ένα (μάλλον ακατάληπτο) μήνυμα λάθους.
 
%\marginnote[16pt]{\iconcomputer}
\begin{pyterm}
TypeError: unsupported operand type(s) for -:
  'int' and 'str'
\end{pyterm}

Το μήνυμα εξηγεί ότι δεν είναι δυνατές οι πράξεις ανάμεσα σε αριθμούς και \emph{αλφαριθμητικές τιμες} (κείμενα). Ίσως αναρωτιέστε που βρέθηκε η αλφαριθμητική τιμή. Η \pyinline{input()}, που χρησιμοποιήσατε για να διαβάσετε το έτος γέννησης που πληκτρολογεί ο χρήστης, επιστρέφει την απάντηση του χρήστη σε μορφή κειμένου, κι έτσι η τιμή της \pyinline{birth} θα έχει τη μορφή \pyinline{"2001"} και όχι \pyinline{2001}.
\end{step}

\begin{step}
Επιστρέψτε στη γραμμή όπου διαβάζεται το έτος γέννησης του χρήστη και \emph{τροποποιήστε} την ως εξής:

\begin{pyplain}
birth = |\pyhighlight{int(}|input()|\pyhighlight{)}|
\end{pyplain}

H \pyinline{int} μετατρέπει το κείμενο που πληκτρολογεί ο χρήστης σε ακέραιο αριθμό. Εκτελέστε και πάλι το πρόγραμμά σας και επιβεβαιώστε ότι δεν εμφανίζεται πια μήνυμα λάθους.
\end{step}

\begin{step}
\emph{Συμπληρώστε} το πρόγραμμά σας, έτσι ώστε να εμφανίζει στο χρήστη την ηλικία του. Για παράδειγμα:

\marginnote[24pt]{\iconcomputer\hspace{1ex}\iconkeyboard}
\begin{pyterm}
Ποιό έτος γεννήθηκες;
|\textbf{2001}|
Είσαι 15 χρονών.
\end{pyterm}

\begin{answer}
Η εντολή που θα προσθέσουμε στο πρόγραμμα είναι:

\begin{pynew}
print("Είσαι", age, "χρονών.")
\end{pynew}
\end{answer}
\end{step}

\begin{step}
%Επειδή ο χρήστης πιθανότατα γνωρίζει ήδη την ηλικία του, 
\emph{Τροποποιήστε} το πρόγραμμα και χρησιμοποιήστε την \pyinline{if}, έτσι ώστε το μήνυμα που εμφανίζεται να εξαρτάται από το αν ο χρήστης έχει ξεπεράσει τα 18 έτη. Για παράδειγμα:

\marginnote[24pt]{\iconcomputer\hspace{1ex}\iconkeyboard}
\begin{pyterm}
Ποιό έτος γεννήθηκες;
|\textbf{2001}|
15 χρονών, η κατάλληλη ηλικία να μάθεις την Απάντηση.
\end{pyterm}

\begin{pyterm}
Ποιό έτος γεννήθηκες;
|\textbf{1976}|
Πάτησες τα 40, είναι λίγο αργά να μάθεις την Απάντηση.
\end{pyterm}

\begin{answer}
Εφόσον θέλουμε το πρόγραμμά μας να εκτελεί διαφορετικές εντολές ανάλογα με το αν η ηλικία είναι μικρότερη του 18 ή όχι θα χρησιμοποιήσουμε την \pyinline{if}--\pyinline{else}, ώστε το πρόγραμμα να εμφανίζει διαφορετικά μηνύματα σε κάθε περίπτωση όπως παρακάτω:

\begin{pynew}
if age < 18:
    print(age, "χρονών, η κατάλληλη ηλικία...")
else:
    print("Πάτησες τα", age, ", είναι λίγο αργά...")
\end{pynew}
\end{answer}

Εκτελέστε το πρόγραμμα σας δύο φορές. Την πρώτη, \emph{παίζοντας το ρόλο του χρήστη}, δώστε ένα έτος γέννησης που αντιστοιχεί σε ηλικία μικρότερη των 18 ετών, ενώ τη δεύτερη το αντίθετο. Εμφανίζεται το κατάλληλο μήνυμα σε κάθε περίπτωση;

\begin{answer}
Δεδομένου ότι το τρέχον έτος είναι \pyinline{2016}, δίνοντας τον αριθμό \pyinline{2001} ως έτος γέννησης εμφανίζεται το μήνυμα:

\begin{pyterm}
15 χρονών, η κατάλληλη ηλικία...
\end{pyterm}


ενώ δίνοντας τον αριθμό \pyinline{1978} εμφανίζεται το μήνυμα: 

\begin{pyterm}
Πάτησες τα 38, είναι λίγο αργά ...
\end{pyterm}
\end{answer}
\end{step}

\begin{step}
\emph{Τροποποιήστε} το πρόγραμμα έτσι ώστε η Απάντηση να εμφανίζεται \emph{μόνο} στην περίπτωση που ο χρήστης δεν έχει ξεπεράσει τα 18 έτη. Δεν χρειάζεται να γράψετε καμία νέα εντολή, μόνο να μετακινήσετε κάποια/κάποιες από τις ήδη υπάρχουσες \emph{μέσα} στην \pyinline{if} του προηγούμενου βήματος.

\begin{answer}
Θα μετακινήσουμε την εμφάνιση της απάντησης ``μέσα'' στην \pyinline{if}, όπως φαίνεται παρακάτω:

\begin{pyplain}
if age < 18:
    print(age, "χρονών, η κατάλληλη ηλικία...")
\end{pyplain}
\begin{pynew}
    print("Η Απάντηση είναι... ", answer)
\end{pynew}
\begin{pyplain}
else:
    print("Πάτησες τα", age, ", είναι λίγο αργά...")
\end{pyplain}
\end{answer}

\marginnote[18pt]{\iconcaution}
\begin{note}
Αν παρουσιαστεί κάποιο πρόβλημα, τότε θα πρέπει να βεβαιωθείτε ότι έχετε χρησιμοποιήσει σωστά τις \emph{εσοχές}, μπροστά από τις εντολές που βρίσκονται μέσα στην \pyinline{if}.
\end{note}

%Εκτελέστε το πρόγραμμα σας δύο φορές. Την πρώτη, \emph{παίζοντας το ρόλο του χρήστη}, δώστε ένα έτος γέννησης που αντιστοιχεί σε ηλικία μικρότερη των 18 ετών, ενώ τη δεύτερη το αντίθετο. Εμφανίζεται η Απάντηση \emph{μόνο} στην πρώτη περίπτωση;
\end{step}
\end{document}
